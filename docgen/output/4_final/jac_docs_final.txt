Abilities are special methods on nodes and walkers. Ability Syntax: can ability_name with [Node_Type] [entry|exit] { // Ability logic }. can ability_name defines an ability. with [Node_Type] [entry|exit] specifies trigger conditions. entry: walker enters node. exit: walker exits node. If Node_Type omitted, applies to any node interaction. root entry: special trigger for walkers, executed once at start. Keywords within Abilities: self: References the node or walker on which the ability is defined. here: References the current node being visited by a walker (when on walker) or the visiting walker (when on node). visitor: References the walker context within nodes/edges. Node Abilities: Callable abilities on nodes are standard methods. Visit-dependent abilities on nodes trigger when a specific walker type interacts with the node. node test_node { has value: int; def callable { print(f"===== Callable on {self}"); } can log_entry with entry { print(f">>> Some Walker entered the node: ", self); } can log_test_walker_entry with test_walker entry { print(f">>> {here} entered the node {self}"); here.callable(); } can log_test_walker_exit with test_walker exit { print(f"<<< {here} exited the node {self}"); } can log_exit with exit { print(f"<<< Some Walker exited the node {self}"); } } Walker Abilities: Walkers have attributes and abilities. Walkers prioritize their visit-dependent abilities before visited node's abilities. walker Walker { can entry1 with entry { print("walker entry"); } can entry2 with `root entry { print("walker enter to root"); visit [-->]; } can entry3 with Node entry { print(f"{here.val}-1"); } can exit1 with Node exit { print(f"{here.val}-6"); } can exit2 with exit { print("walker exit"); } } Walker Ability Trigger Variants: Entry through root: walker walker_name { can walker_ability with `root entry; } Entry through a specific node: walker walker_name { can walker_ability with specific_node entry; } Entry through root or a specific node: walker walker_name { can walker_ability with `root | specific_node entry; } Common Ability Patterns: Root Entry Abilities: Executed once at walker start for setup, data fetching, validation. can start with `root entry { print("Starting journey!"); visit [-->]; } can get_weather_data with `root entry { weather_info = f"Weather in {self.city}: Sunny, 25°C"; report {"city": self.city, "weather": weather_info}; } can create_new_note with `root entry { new_note = Note( title=self.title, content=self.content, author=self.author ); here ++> new_note; report {"message": "Note created", "id": new_note.id}; } can fetch_all_notes with `root entry { all_notes = [-->(`?Note)]; notes_data = [ {"id": n.id, "title": n.title, "author": n.author} for n in all_notes ]; report {"notes": notes_data, "total": len(notes_data)}; } can validate_and_create with `root entry { if len(self.title) < 3 { report {"error": "Title must be at least 3 characters"}; return; } new_note = Note(title=self.title, content=self.content); here ++> new_note; report {"message": "Note created successfully"}; } Node-Specific Entry Abilities: Execute when walker enters specific node type. can greet with Person entry { print(f"Hello, {here.name}!"); self.greeting_count += 1; visit [-->]; } API Endpoint Abilities: Abilities as API endpoints, using report to return data. import from datetime {datetime} walker public_info { obj __specs__ { static has methods: list = ["get"]; static has auth: bool = False; } can get_current_time with `root entry{ report { "timestamp": datetime.now().isoformat() }; } } walker search_users { has query: str; static has users: list = [ {"username": "alice", "email": "alice@example.com"}, {"username": "bob", "email": "bob@example.com"} ]; obj __specs__ { static has methods: list = ["get"]; static has as_query: list = ["query"]; static has auth: bool = False; } can search_by_name with `root entry{ for user in self.users { if user['username'] == self.query { report user; return; } } report {"error": f"User with username {self.query} not found"}; } } import from fastapi { UploadFile } walker single_file_upload { has file: UploadFile; obj __specs__ { static has methods: list = ["post"]; static has auth: bool = False; } can enter with `root entry { report { "output": f"Received file: {self.file.filename}" }; } } Caching and Metrics Abilities: Abilities implement caching and update metrics. can fetch_weather with `root entry { metrics["requests_total"] += 1; metrics["requests_per_city"][self.city] = metrics["requests_per_city"].get(self.city, 0) + 1; cached = [-->(`?WeatherData)](?city == self.city); if cached { metrics["cache_hits"] += 1; weather = cached[0]; report { "city": weather.city, "temperature": weather.temperature, "description": weather.description, "cached": True }; } else { metrics["cache_misses"] += 1; new_weather = WeatherData( city=self.city, temperature=22.5, description="Sunny", last_updated=datetime.now().isoformat() ); here ++> new_weather; report { "city": self.city, "temperature": 22.5, "description": "Sunny", "cached": False }; } } can check_health with `root entry { uptime = time() - metrics["start_time"]; cache_hit_rate = metrics["cache_hits"] / max(metrics["requests_total"], 1) * 100; report { "status": "healthy", "uptime_seconds": uptime, "total_requests": metrics["requests_total"], "cache_hit_rate_percent": round(cache_hit_rate, 2), "cached_cities": len([-->(`?WeatherData)]), "timestamp": datetime.now().isoformat() }; } AI Agents: AI Functions (Stateless): Perform specific tasks without memory. AI Agents (Stateful): Maintain persistent state across interactions. Agent Patterns: Agent Loop Example: with entry { history = []; while True { chat = chat_with_player(player, npc, history); history.append(chat); print("\n[[npc]] >> ", chat.message); inp = input("\n[[Player input]] >> "); history.append(Chat(person=player.name, message=inp)); } } Conversational AI Agent with State and Tools: def chat_with_player(player: Person, npc: Person, chat_history: list[Chat]) -> Chat by llm(method="ReAct", tools=[make_transaction]); Maintains State (chat_history), Reasons (ReAct), Acts (tools), Persists Context, Tool Integration, State Management. Agentic Node Patterns: Nodes act as agents, maintaining local state and responding to visitor events. can execute with <walker_name> entry is common entry point. Example: Task Handling Agent: node TaskHandling { def get_current_time() -> str { import:py time; return time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime()); } def add_task(task: str, date: str, time: str) -> str { task_created = Task(task=task, date=date, time=time); self ++> task_created; return "Task added successfully"; } def summarize_tasks -> str { scheduled_tasks = [self-->(`?Task)]; return str(scheduled_tasks); } def route_and_run(utterance: str) -> str by llm( method="ReAct", tools=([self.add_task, self.get_current_time, self.summarize_tasks]) ); can execute with task_manager entry { print("[TaskHandling Node Activated]"); response = self.route_and_run(visitor.cur_task.task); print("→", response); report { "utterance": visitor.cur_task.task, "response": response, "node_type": self.__class__.__name__ }; } } Example: Email Handling Agent: node EmailHandling { def write_email_content(utterance: str) -> str by llm(); def route_and_run(utterance: str) -> str by llm( method="ReAct", tools=([self.write_email_content]) ); can execute with task_manager entry { print("[EmailHandling Node Activated]"); response = self.route_and_run(visitor.cur_task.task); print("→", response); report { "utterance": visitor.cur_task.task, "response": response, "node_type": self.__class__.__name__ }; } } Example: General Chat Agent: node GeneralChat { def chat(utterance: str) -> str by llm(); can execute with task_manager entry { print("[GeneralChat Node Activated]"); response = self.chat(visitor.cur_task.task); print("→", response); report { "utterance": visitor.cur_task.task, "response": response, "node_type": self.__class__.__name__ }; } } Example: Task Manager Walker (Agent Loop): walker task_manager { has utterance: str = ""; has cur_task: TaskPartition = None; def route_to_node(utterance: str) -> RoutingNodes by llm(); def plan_tasks(main_task: str) -> list[TaskPartition] by llm(); can execute with `root entry { subtasks = self.plan_tasks(self.utterance); print("[Planned Subtasks]:", subtasks); node_map = { RoutingNodes.TASK_HANDLING: TaskHandling, RoutingNodes.EMAIL_HANDLING: EmailHandling, RoutingNodes.GENERAL_CHAT: GeneralChat }; } } Node and Walker Definitions with Abilities: Profile Node: node Profile { has username: str = ""; can update with update_profile entry; can get with get_profile entry; can follow with follow_request entry; can un_follow with un_follow_request entry; } Tweet Node: node Tweet { has content: str; has embedding: list; has created_at: str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"); can update with update_tweet exit; can delete with remove_tweet exit; can like_tweet with like_tweet entry; can remove_like with remove_like entry; can comment with comment_tweet entry; def get_info() -> TweetInfo; can get with load_feed entry; } Walker Examples: walker create_tweet(visit_profile) { has content: str; can tweet with Profile entry; } walker visit_profile { can visit_profile with `root entry; } walker load_feed(visit_profile) { has search_query: str = ""; has results: list = []; can load with Profile entry; } AI Abilities: LLM Integration: Streaming with ReAct Tool Calling: Real-time streaming for ReAct with tools. by llm() Feature Methods as Tools: Add class methods as LLM tools. obj = ToolHolder() response = by llm(tools=[obj.tool]). LLM Function Overriding: Override functions with LLM-powered implementation at runtime. function_call() by llm(). Semantic Strings: Attach natural language descriptions to code elements for LLM-powered code generation/execution. str "..." AI Integration with byLLM: byLLM is an AI integration framework for Jaseci, implementing Meaning Typed Programming (MTP). Core Concepts: by llm(): Language-level construct in Jac for optimized prompt generation and LLM integration. Enables functions to process any input type and generate contextually appropriate outputs of specified type, auto-generating prompts and ensuring strict return type adherence. Semantic Strings (str "..." or sem): Attach natural language descriptions to code elements (functions, classes, parameters) for LLM-