## Abilities

Abilities are special methods defined on nodes and walkers.

### Ability Syntax

```jac
can ability_name with [Node_Type] [entry|exit] {
    // Ability logic
}
```

-   `can ability_name`: Defines an ability.
-   `with [Node_Type] [entry|exit]`: Specifies trigger conditions.
    -   `entry`: Triggered when a walker enters a node.
    -   `exit`: Triggered when a walker exits a node.
    -   If `Node_Type` is omitted, it applies to any node interaction.
    -   `root entry`: Special trigger for walkers, executed once at the beginning of the walker's operation.

### Keywords within Abilities

-   `self`: References the node or walker on which the ability is defined.
-   `here`: References the current node being visited by a walker (when defined on a walker) or the visiting walker (when defined on a node).
-   `visitor`: References the walker context within nodes/edges.

### Node Abilities

Callable abilities on nodes are standard methods. Visit-dependent abilities on nodes are triggered when a specific type of walker interacts with the node.

```jac
node test_node {
    has value: int;

    // Callable ability
    def callable {
        print(f"===== Callable on {self}");
    }

    // Visit-dependent abilities
    can log_entry with entry { // Triggered by any walker entering
        print(f">>> Some Walker entered the node: ", self);
    }
    can log_test_walker_entry with test_walker entry { // Triggered by 'test_walker' entering
        print(f">>> {here} entered the node {self}");
        here.callable(); // Accessing a callable ability of the visiting walker
    }
    can log_test_walker_exit with test_walker exit { // Triggered by 'test_walker' exiting
        print(f"<<< {here} exited the node {self}");
    }
    can log_exit with exit { // Triggered by any walker exiting
        print(f"<<< Some Walker exited the node {self}");
    }
}
```

### Walker Abilities

Walkers can have their own attributes and abilities. Walkers prioritize their visit-dependent abilities before executing the abilities of the visited node.

```jac
walker Walker {
    can entry1 with entry { // Triggered once when the walker is spawned
        print("walker entry");
    }

    can entry2 with `root entry { // Triggered once at the beginning of traversal
        print("walker enter to root");
        visit [-->]; // Traverse outgoing edges
    }

    can entry3 with Node entry { // Triggered when entering any Node type
        print(f"{here.val}-1"); // 'here' refers to the Node
    }

    can exit1 with Node exit { // Triggered when exiting any Node type
        print(f"{here.val}-6"); // 'here' refers to the Node
    }

    can exit2 with exit { // Triggered once when the walker finishes traversal
        print("walker exit");
    }
}
```

#### Walker Ability Trigger Variants

-   **Entry through root:**
    ```jac
    walker walker_name {
      can walker_ability with `root entry;
    }
    ```
-   **Entry through a specific node:**
    ```jac
    walker walker_name {
      can walker_ability with specific_node entry;
    }
    ```
-   **Entry through root or a specific node:**
    ```jac
    walker walker_name {
      can walker_ability with `root | specific_node entry;
    }
    ```

### Common Ability Patterns

#### Root Entry Abilities

Executed once when the walker starts, often for initial setup, data fetching, or validation.

```jac
can start with `root entry {
    print("Starting journey!");
    visit [-->];
}
```

```jac
can get_weather_data with `root entry {
    weather_info = f"Weather in {self.city}: Sunny, 25°C";
    report {"city": self.city, "weather": weather_info};
}
```

```jac
can create_new_note with `root entry {
    new_note = Note(
        title=self.title,
        content=self.content,
        author=self.author
    );
    here ++> new_note; // Create an edge from 'here' (root) to the new note
    report {"message": "Note created", "id": new_note.id};
}
```

```jac
can fetch_all_notes with `root entry {
    all_notes = [-->(`?Note)]; // Traverse all paths to find nodes of type Note
    notes_data = [
        {"id": n.id, "title": n.title, "author": n.author}
        for n in all_notes
    ];
    report {"notes": notes_data, "total": len(notes_data)};
}
```

```jac
can validate_and_create with `root entry {
    // Jac automatically validates types before this runs
    if len(self.title) < 3 {
        report {"error": "Title must be at least 3 characters"};
        return;
    }
    new_note = Note(title=self.title, content=self.content);
    here ++> new_note;
    report {"message": "Note created successfully"};
}
```

#### Node-Specific Entry Abilities

Execute when a walker enters a node of a specific type.

```jac
can greet with Person entry {
    print(f"Hello, {here.name}!"); // 'here' refers to the Person node
    self.greeting_count += 1; // 'self' refers to the walker
    visit [-->];
}
```

#### API Endpoint Abilities

Abilities can serve as API endpoints, using `report` to return data.

```jac
import from datetime {datetime}

walker public_info {
    obj __specs__ {
        static has methods: list = ["get"];
        static has auth: bool = False;
    }

    can get_current_time with `root entry{
        report {
            "timestamp": datetime.now().isoformat()
        };
    }
}
```

```jac
walker search_users {
    has query: str;
    static has users: list = [
        {"username": "alice", "email": "alice@example.com"},
        {"username": "bob", "email": "bob@example.com"}
    ];

    obj __specs__ {
        static has methods: list = ["get"];
        static has as_query: list = ["query"];
        static has auth: bool = False;
    }

    can search_by_name with `root entry{
        for user in self.users {
            if user['username'] == self.query {
                report user;
                return;
            }
        }
        report {"error": f"User with username {self.query} not found"};
    }
}
```

```jac
import from fastapi { UploadFile }

walker single_file_upload {
    has file: UploadFile;

    obj __specs__ {
        static has methods: list = ["post"];
        static has auth: bool = False;
    }

    can enter with `root entry {
        report {
            "output": f"Received file: {self.file.filename}"
        };
    }
}
```

#### Caching and Metrics Abilities

Abilities can implement caching logic and update metrics.

```jac
can fetch_weather with `root entry {
    // Update metrics
    metrics["requests_total"] += 1;
    metrics["requests_per_city"][self.city] = metrics["requests_per_city"].get(self.city, 0) + 1;

    // Check cache first
    cached = [-->(`?WeatherData)](?city == self.city);

    if cached {
        metrics["cache_hits"] += 1;
        weather = cached[0];
        report {
            "city": weather.city,
            "temperature": weather.temperature,
            "description": weather.description,
            "cached": True
        };
    } else {
        metrics["cache_misses"] += 1;
        // Simulate external API call
        new_weather = WeatherData(
            city=self.city,
            temperature=22.5,
            description="Sunny",
            last_updated=datetime.now().isoformat()
        );
        here ++> new_weather;

        report {
            "city": self.city,
            "temperature": 22.5,
            "description": "Sunny",
            "cached": False
        };
    }
}
```

```jac
can check_health with `root entry {
    uptime = time() - metrics["start_time"];
    cache_hit_rate = metrics["cache_hits"] / max(metrics["requests_total"], 1) * 100;

    report {
        "status": "healthy",
        "uptime_seconds": uptime,
        "total_requests": metrics["requests_total"],
        "cache_hit_rate_percent": round(cache_hit_rate, 2),
        "cached_cities": len([-->(`?WeatherData)]),
        "timestamp": datetime.now().isoformat()
    };
}
```

## AI Agents

### AI Functions vs. AI Agents

-   **AI Functions (Stateless):** Perform specific tasks without retaining memory of past interactions.
-   **AI Agents (Stateful):** Maintain persistent state across interactions, building understanding over multiple turns.

### Agent Patterns

#### Agent Loop Example

```jac
with entry {
    // ... character generation and setup ...

    history = [];

    while True {
        // AI agent generates response with state
        chat = chat_with_player(player, npc, history);
        history.append(chat);

        // ... display game state ...

        // Show NPC response and get player input
        print("\n[[npc]] >> ", chat.message);
        inp = input("\n[[Player input]] >> ");
        history.append(Chat(person=player.name, message=inp));
    }
}
```

#### Conversational AI Agent with State and Tools

```jac
def chat_with_player(player: Person, npc: Person, chat_history: list[Chat]) -> Chat
    by llm(method="ReAct", tools=[make_transaction]);
```
-   **Maintains State**: Uses `chat_history` to remember previous interactions.
-   **Reasons**: Processes conversation context using the `ReAct` method.
-   **Acts**: Can use tools like `make_transaction` when appropriate.
-   **Persists Context**: Builds understanding across multiple conversation turns.
-   **Tool Integration**: Accesses application functions (e.g., `make_transaction`) through the `tools` parameter. The AI extracts parameters from natural language, and tool results are incorporated into responses.
-   **State Management**: Achieved through structured data objects (`Person`, `InventoryItem`), conversation history (`Chat` objects), and global registries (`person_record`).

### Agentic Node Patterns

Nodes can act as agents, maintaining local state and responding to visitor events. The `can execute with <walker_name> entry` ability is a common entry point for agent behavior.

#### Example: Task Handling Agent
```jac
node TaskHandling {
  def get_current_time() -> str {
    import:py time;
    return time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime());
  }

  def add_task(task: str, date: str, time: str) -> str {
    task_created = Task(task=task, date=date, time=time);
    self ++> task_created;
    return "Task added successfully";
  }

  def summarize_tasks -> str {
    scheduled_tasks = [self-->(`?Task)];
    return str(scheduled_tasks);
  }

  def route_and_run(utterance: str) -> str by llm(
    method="ReAct",
    tools=([self.add_task, self.get_current_time, self.summarize_tasks])
  );

  can execute with task_manager entry {
    print("[TaskHandling Node Activated]");
    response = self.route_and_run(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### Example: Email Handling Agent
```jac
node EmailHandling {
  def write_email_content(utterance: str) -> str by llm();
  def route_and_run(utterance: str) -> str by llm(
    method="ReAct",
    tools=([self.write_email_content])
  );
  can execute with task_manager entry {
    print("[EmailHandling Node Activated]");
    response = self.route_and_run(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### Example: General Chat Agent
```jac
node GeneralChat {
  def chat(utterance: str) -> str by llm();
  can execute with task_manager entry {
    print("[GeneralChat Node Activated]");
    response = self.chat(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### Example: Task Manager Walker (Agent Loop)
```jac
walker task_manager {
  has utterance: str = "";
  has cur_task: TaskPartition = None;

  def route_to_node(utterance: str) -> RoutingNodes by llm();
  def plan_tasks(main_task: str) -> list[TaskPartition] by llm();

  can execute with `root entry {
    # Step 1: Plan - decompose the user's request
    subtasks = self.plan_tasks(self.utterance);
    print("[Planned Subtasks]:", subtasks);

    # Step 2: Map agent types to node classes
    node_map = {
      RoutingNodes.TASK_HANDLING: TaskHandling,
      RoutingNodes.EMAIL_HANDLING: EmailHandling,
      RoutingNodes.GENERAL_CHAT: GeneralChat
    };

    # Step 3: Execute - route
    // ... (rest of the agent loop logic)
  }
}
```

### Node and Walker Definitions with Abilities

#### Profile Node
```jac
node Profile {
    has username: str = "";

    can update with update_profile entry;
    can get with get_profile entry;
    can follow with follow_request entry;
    can un_follow with un_follow_request entry;
}
```

#### Tweet Node
```jac
node Tweet {
    has content: str;
    has embedding: list;
    has created_at: str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S");

    can update with update_tweet exit;
    can delete with remove_tweet exit;
    can like_tweet with like_tweet entry;
    can remove_like with remove_like entry;
    can comment with comment_tweet entry;

    def get_info() -> TweetInfo;
    can get with load_feed entry;
}
```

#### Walker Examples
```jac
walker create_tweet(visit_profile) {
    has content: str;
    can tweet with Profile entry;
}
```
```jac
walker visit_profile {
    can visit_profile with `root entry;
}
```
```jac
walker load_feed(visit_profile) {
    has search_query: str = "";
    has results: list = [];
    can load with Profile entry;
}
```

## AI Abilities

### LLM Integration
-   **Streaming with ReAct Tool Calling**: Real-time streaming support for ReAct method when using tools. After tool execution, the LLM streams the final synthesized answer token-by-token.
-   **`by llm()` Feature Methods as Tools**: Supports adding methods of classes as tools for the LLM.
    ```jac
    obj = ToolHolder()
    response = by llm(tools=[obj.tool])
    ```
-   **LLM Function Overriding**: Override any regular function with an LLM-powered implementation at runtime.
    ```jac
    function_call() by llm()
    ```

### Semantic Strings
-   Attach natural language descriptions to code elements (functions, classes, parameters) for LLM-powered code generation and execution.
    ```jac
    str "..."
    ```

## AI Integration with byLLM

byLLM is an AI integration framework for the Jaseci ecosystem, implementing the Meaning Typed Programming (MTP) paradigm. It embeds prompt engineering directly into code semantics, making AI interactions more natural and maintainable.

### Core Concepts
-   **`by llm()`**: A language-level construct in Jac that automatically generates optimized prompts and integrates with LLMs. It enables functions to process inputs of any type and generate contextually appropriate outputs of the specified type, auto-generating prompts and ensuring strict adherence to the return type.
-   **Semantic Strings (`str "..."` or `sem`)**: Attach natural language descriptions to code elements (functions, classes, parameters) for LLM-