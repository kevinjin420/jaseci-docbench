# api


## From: litellm_proxy.md

```python
from byllm.lib import Model

llm = Model(
    model_name="gpt-4o",                # The model name to be used
    api_key="your_litellm_api_key",     # LiteLLM proxy server key
    proxy_url="http://localhost:8000",  # URL of the LiteLLM proxy server
)
```

Note that the `api_key` parameter is necessary to authenticate the connection, which is not the OpenAI API key but the virtual key (or master key) generated by the LiteLLM proxy server.


## From: introduction.md

- Deploy your Jac applications as RESTful APIs, WebSocket services, and scheduled tasks
- Simply replace `jac run` with `jac serve` to transform your application into a fully-featured web service
- **Instant API Generation**
- Automatically converts Jac walkers into REST endpoints
- Supports all HTTP methods (GET, POST, PUT, DELETE, etc.)
- Built-in OpenAPI/Swagger documentation at `/docs`
- Serve as an API
```bash
jac serve main.jac
```
Your application will be available at `http://localhost:8000` with automatic API documentation at `http://localhost:8000/docs`.
- **Walker Endpoints**: Automatic REST API generation from walker declarations
- **Data Processing APIs**: Transform and analyze data at scale
- **AI/ML Services**: Deploy machine learning models as APIs


## From: deployment.md

### 4. Add OpenAI API Key (Optional)

If your application uses OpenAI services, add your API key as a Kubernetes secret:

```bash
# Encode your API key in base64
echo -n "your-openai-key" | base64
```

Then, update the base64 value in the `data.openai-key` field of the secret definition in `jac-cloud.yml` and apply it:

```bash
kubectl apply -f jac-cloud/scripts/jac-cloud.yml
```

| Variable         | Description                         | Default Value   |
| ---------------- | ----------------------------------- | --------------- |
| `OPENAI_API_KEY` | OpenAI API key (from secret)        | None            |


## From: sso_implementation.md

#### 3. Call the Callback Endpoint

Once the `id_token` is obtained, call the callback endpoint provided by JAC Cloud

##### Endpoint Format
```
$GET {backendURL}/sso/${provider}/register/callback?id_token=${id_token}
```

##### Curl Example for apple with id_token
```bash
curl -X 'GET' \
  'http://localhost:8000/sso/apple/register/callback?id_token=eyJraWQiOiJFNnE4M1JCMTVuIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoibGlmZS50b2J1IiwiZXhwIjoxNzU2NTYxOTg0LCJpYXQiOjE3NTY0NzU1ODQsInN1YiI6IjAwMDkwNC5hMTI5MDJmMzA1ZGE0ZWY1ODE5MGVmN2VjMGQ3ODE1OS4xMzU3IiwiY19oYXNoIjoiQksxdTdBYmlua2RsMUlBWUVISWp2dyIsImVtYWlsIjoicWM5N2s3Mm5mN0Bwcml2YXRlcmVsYXkuYXBwbGVpZC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiaXNfcHJpdmF0ZV9lbWFpbCI6dHJ1ZSwiYXV0aF90aW1lIjoxNzU2NDc1NTg0LCJub25jZV9zdXBwb3J0ZWQiOnRydWV9.iC_vnj2Ar268Z2IW0Ums1gr6OT0UFZocUFJaU_X1S9fudnd_pmIvgOgnlYO8Y7_P134xzjyrHV2-sB_APjZluaUNid7dUkLu7FaCEjU4GReuXlav9Ek9pZfV0FY0D2wqEJhMZ2EcQfgBJbthSewlbbwIeEF4OTHOPB3Pfw8jVJxEMseJ6glxOL0UHC7jRAJNsyYePG2ld1o66UMiFpOaIuuoTjJmigaPA4Mwe1Tiu_ZtGPONd9TEZo7xCXP_c2E68Rh9dLZcqULXAot58l71XEJJok63SQfGMfolR-ibCRAbWvqfe-ZFYYuxVIplva1MnLmiwuPCsb76nUxn0nNa5Q' \
  -H 'accept: application/json'
```

#### Supported Providers

The `${provider}` parameter can take the following values based on your frontend platform.

| Platform | Provider Value |
|----------|----------------|
| Apple (any platform) | `apple` |
| Google Web | `google` |
| Google Android | `google_android` |
| Google iOS | `google_ios` |

This will register your user with jac cloud and sso platform and returns you the required user informations like name,email etc
#### Example Calls

```bash
# For Apple Sign-In
curl "${backendURL}/sso/apple/register/callback?id_token=${id_token}"

# For Google Web
curl "${backendURL}/sso/google/register/callback?id_token=${id_token}"

# For Google Android
curl "${backendURL}/sso/google_android/register/callback?id_token=${id_token}"

# For Google iOS
curl "${backendURL}/sso/google_ios/register/callback?id_token=${id_token}"
```


## From: create_own_lm.md

This guide shows how to create a custom Model class for byLLM that bypasses the default LiteLLM integration. This is useful when you want to use a self-hosted language model, a custom API, or any service not supported by LiteLLM. The example demonstrates this by implementing a custom class using the OpenAI SDK.

=== "Python"
    ```python linenums="1"
    from byllm.llm import BaseLLM
    from openai import OpenAI

    class MyOpenAIModel(BaseLLM):
        def __init__(self, model_name: str, **kwargs: object) -> None:
            """Initialize the MockLLM connector."""
            super().__init__(model_name, **kwargs)

        def model_call_no_stream(self, params):
            client = OpenAI(api_key=self.api_key)
            response = client.chat.completions.create(**params)
            return response

        def model_call_with_stream(self, params):
            client = OpenAI(api_key=self.api_key)
            response = client.chat.completions.create(stream=True, **params)
            return response
    ```
=== "Jac"
    ```jac linenums="1"
    import from byllm.llm { BaseLLM }
    import from openai { OpenAI }

    obj  MyOpenAIModel(BaseLLM){
        has model_name: str;
        has config: dict = {};

        def post_init() {
            super().__init__(model_name=self.model_name, **kwargs);
        }

        def model_call_no_stream(params: dict) {
            client = OpenAI(api_key=self.api_key);
            response = client.chat.completions.create(**params);
            return response;
        }

        def model_call_with_stream(params: dict) {
            client = OpenAI(api_key=self.api_key);
            response = client.chat.completions.create(stream=True, **params);
            return response;
        }
    }
    ```


## From: streamlit.md

### 1. Full Streamlit API Access

You can use all Streamlit components and features in your Jac applications:

```jac
import streamlit as st;
import pandas as pd;
import numpy as np;

with entry {
    st.title("Data Dashboard");

    # Create sample data
    data = pd.DataFrame({
        'x': np.random.randn(100),
        'y': np.random.randn(100)
    });

    # Display chart
    st.line_chart(data);

    # Add sidebar
    st.sidebar.header("Controls");
    chart_type = st.sidebar.selectbox("Chart Type", ["line", "bar", "area"]);

    if chart_type == "bar" {
        st.bar_chart(data);
    } elif chart_type == "area" {
        st.area_chart(data);
    }
}
```
```jac
def make_api_call(token: str, endpoint: str, payload: dict) -> dict {
    response = requests.post(
        "http://localhost:8000/" + endpoint,
        json=payload,
        headers={"Authorization": "Bearer " + token}
    );
    return response.json() if response.status_code == 200 else {};
}
```


## From: task-manager-lite.md

1. **Start the backend server:**
   ```bash
   jac serve task_manager.jac
   ```
   The API server will be available at `http://localhost:8000`

1. Start the Jac Cloud server:
   ```bash
   jac serve task_manager.jac
   ```

The API server will be available at `http://localhost:8000`

### Calendar Systems
- **Calendar APIs**: Support for various calendar service APIs

### Communication Platforms
- **Email Services**: Connect with SMTP servers for automated email sending

### Project Management Tools
- **Custom APIs**: Flexible integration with proprietary systems

### Authentication and Authorization
- **API Security**: Token-based authentication for API access


## From: fantasy_trading_game.md

Required dependencies:

```bash
pip install byllm
```

OpenAI API key configuration:
```bash
export OPENAI_API_KEY="your-api-key-here"
```


## From: jac_serve.md

The `jac serve` command turns your Jac programs into authenticated REST APIs automatically.

## Overview

When you run `jac serve`, it:
1. Executes your target Jac module
2. Converts all functions into REST API endpoints with introspected signatures
3. Converts all walkers into REST APIs where:
   - Walker fields (has variables) become the API interface
   - An additional `target_node` field specifies where to spawn the walker
4. Creates a user management system where each user has their own persistent root node
5. Requires authentication via token-based auth for all protected endpoints

## API Endpoints

### Public Endpoints (No Authentication Required)

#### GET /
Returns API information and available endpoints.

**Example:**
```bash
curl http://localhost:8000/
```

#### POST /user/create
Create a new user account. Each user gets their own persistent root node.

**Request Body:**
```json
{
  "username": "alice",
  "password": "secret123"
}
```

**Response:**
```json
{
  "username": "alice",
  "token": "abc123...",
  "root_id": "uuid-of-root-node"
}
```

**Example:**
```bash
curl -X POST http://localhost:8000/user/create \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret123"}'
```

#### POST /user/login
Authenticate and receive a token.

**Request Body:**
```json
{
  "username": "alice",
  "password": "secret123"
}
```

**Response:**
```json
{
  "username": "alice",
  "token": "abc123...",
  "root_id": "uuid-of-root-node"
}
```

**Example:**
```bash
curl -X POST http://localhost:8000/user/login \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret123"}'
```

### Protected Endpoints (Authentication Required)

All protected endpoints require an `Authorization` header with a Bearer token:

```
Authorization: Bearer YOUR_TOKEN_HERE
```

#### GET /functions
List all available functions in the module.

**Example:**
```bash
curl http://localhost:8000/functions \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Response:**
```json
{
  "functions": ["add_numbers", "greet", "calculate_stats"]
}
```

#### GET /function/<name>
Get the signature and parameter information for a specific function.

**Example:**
```bash
curl http://localhost:8000/function/add_numbers \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Response:**
```json
{
  "name": "add_numbers",
  "signature": {
    "parameters": {
      "a": {
        "type": "int",
        "required": true,
        "default": null
      },
      "b": {
        "type": "int",
        "required": true,
        "default": null
      }
    },
    "return_type": "int"
  }
}
```

#### POST /function/<name>
Call a function with the provided arguments.

**Request Body:**
```json
{
  "args": {
    "a": 5,
    "b": 10
  }
}
```

**Response:**
```json
{
  "result": 15,
  "reports": []
}
```

**Example:**
```bash
curl -X POST http://localhost:8000/function/add_numbers \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"args": {"a": 5, "b": 10}}'
```

#### GET /walkers
List all available walkers in the module.

**Example:**
```bash
curl http://localhost:8000/walkers \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Response:**
```json
{
  "walkers": ["CreateTask", "ListTasks", "CompleteTask"]
}
```

#### GET /walker/<name>
Get the field information for a specific walker.

**Example:**
```bash
curl http://localhost:8000/walker/CreateTask \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Response:**
```json
{
  "name": "CreateTask",
  "info": {
    "fields": {
      "title": {
        "type": "str",
        "required": true,
        "default": null
      },
      "priority": {
        "type": "int",
        "required": false,
        "default": "1"
      },
      "target_node": {
        "type": "str (node ID, optional)",
        "required": false,
        "default": "root"
      }
    }
  }
}
```

#### POST /walker/<name>
Spawn a walker with the provided fields.

**Request Body:**
```json
{
  "fields": {
    "title": "Buy groceries",
    "priority": 2,
    "target_node": "optional-node-id"
  }
}
```

**Response:**
```json
{
  "result": "Walker executed successfully",
  "reports": []
}
```

**Example:**
```bash
curl -X POST http://localhost:8000/walker/CreateTask \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"fields": {"title": "Buy groceries", "priority": 2}}'
```

## Complete Workflow Example

Here's a complete example using the `example_api.jac` file:

### 1. Start the server
```bash
jac serve example_api.jac
```

### 2. Create a user
```bash
TOKEN=$(curl -s -X POST http://localhost:8000/user/create \
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "password": "secret123"}' \
  | jq -r '.token')

echo "Token: $TOKEN"
```

### 3. Call a function
```bash
curl -X POST http://localhost:8000/function/add_numbers \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"args": {"a": 15, "b": 27}}'
```

### 4. Create tasks using walkers
```bash
# Create first task
curl -X POST http://localhost:8000/walker/CreateTask \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"fields": {"title": "Buy groceries", "priority": 2}}'

# Create second task
curl -X POST http://localhost:8000/walker/CreateTask \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"fields": {"title": "Write documentation", "priority": 1}}'
```

### 5. List all tasks
```bash
curl -X POST http://localhost:8000/walker/ListTasks \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"fields": {}}'
```

### 6. Complete a task
```bash
curl -X POST http://localhost:8000/walker/CompleteTask \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"fields": {"title": "Buy groceries"}}'
```

## Key Features

1. **Automatic API Generation**: Functions and walkers automatically become REST endpoints
2. **Type Introspection**: Function signatures are analyzed to generate API documentation
6. **CORS Support**: Includes CORS headers for web application integration

## Notes

- The server binds to `0.0.0.0` by default, making it accessible on all network interfaces

