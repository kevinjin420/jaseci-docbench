# Control Flow

## Control Flow Statements

| Keyword | Description |
| --- | --- |
| `if` / `elif` / `else` | Executes code blocks conditionally. |
| `for` | Iterates over a sequence. |
| `while` | Creates a loop that executes as long as a condition is true. |
| `match` / `case` | Implements structural pattern matching. |
| `try` / `except` / `finally` | Handles exceptions. |
| `break` | Exits the current loop. |
| `continue` | Proceeds to the next iteration of a loop. |
| `raise` | Triggers an exception. |
| `skip` | Terminates current location execution for a walker and proceeds to the next location in its traversal queue. |
| `disengage` | Terminates a walker's entire object-spatial traversal. |

### Conditional Statements (`if`, `elif`, `else`)

Used for decision-making based on conditions. All control blocks require brackets, but not parentheses.

```jac
def learnFlowControl() {
	x = 9;

	if x < 5 {
		print("Doesn't run");
	} elif x < 10 {
		print("Run");
	} else {
		print("Also doesn't run");
	}
}
```

**Comparison Operators:**

| Operator | Meaning | Example |
|----------|---------|---------|
| `>` | Greater than | `x > 5` |
| `<` | Less than | `x < 10` |
| `>=` | Greater than or equal | `age >= 18` |
| `<=` | Less than or equal | `score <= 100` |
| `==` | Equal to | `name == "Alice"` |
| `!=` | Not equal to | `status != "done"` |

**Logical Operators:**

*   `and`: Both conditions must be true.
*   `or`: At least one condition must be true.
*   `not`: Reverses the condition.

```jac
with entry {
    age = 25;
    has_license = True;

    if age >= 16 and has_license {
        print("You can drive!");
    }

    if age < 18 or age > 65 {
        print("Discounted ticket price!");
    }

    if not has_license {
        print("You need a license!");
    }
}
```

### Match Statements (`match`, `case`)

Provides structural pattern matching, often replacing chains of `if-elif-else`.

```jac
def learnFlowControl() {
	x = 9;

	match x {
		case 1:
			print("Exactly one");
		case int() if 10 <= x < 15:
			print("Within a range");
		case _:
			print("Everything else");
	}
}
```

### For Loops (`for`)

Iterates over sequences or ranges. Does not use parentheses.

```jac
def learnFlowControl() {
	# Indexed for loop
	for i = 10 to i <= 20 by i += 2 {
		print(f"element: {i}");
	}

	# Range-based for loop
	for x in ["a", "b", "c"] {
		print(f"element: {x}");
	}
}
```

### While Loops (`while`)

Executes a block of code as long as a condition is true.

```jac
def learnFlowControl() {
	a = 4;
	while a != 1{
		a /= 2;
	}
}
```

**Agent Loop Example:**

```jac
walker MyAgent {
    has max_checks: int = 5;
    has checks_done: int = 0;

    can run_checks with entry {
        while self.checks_done < self.max_checks {
            // Perform some check or action
            print(f"Performing check {self.checks_done + 1}");
            self.checks_done += 1;

            // Simulate some condition to break early
            if self.checks_done == 3 {
                print("Condition met, stopping early.");
                break; // Exit the while loop
            }
        }
        print("Agent finished checks.");
    }
}
```

### Exception Handling (`try`, `except`, `finally`, `raise`)

Manages errors and unexpected events during execution.

```jac
# Read text file safely
def read_file(filepath: str) -> str | None {
    try {
        with open(filepath, 'r') as file {
            return file.read();
        }
    } except FileNotFoundError {
        print(f"File not found: {filepath}");
        return None;
    } except Exception as e {
        print(f"Error reading file: {e}");
        return None;
    }
}
```

### Walker Control Flow (`skip`, `disengage`)

These statements provide fine-grained control over walker traversal execution.

#### `skip` Statement

Terminates execution at the current location and proceeds to the next location in the walker's traversal queue. Analogous to `continue` in traditional loops.

```jac
                // Skip if no more connections
                connections = [-->];
                if not connections {
                    print("No more students to check");
                    self.report_final();
                    skip; // Proceeds to the next location in the queue
                }
```

#### `disengage` Statement

Terminates a walker's entire object-spatial traversal and returns it to an inactive state. Analogous to `break` in traditional loops.

```jac
                if self.checks_done >= self.max_checks {
                    print(f"Reached maximum checks ({self.max_checks})");
                    self.report_final();
                    disengage;  // Stop the walker
                }
```

## Standard Library

### File I/O
Module: `file`

- `open(path: str, mode: str) -> File`: Opens a file. `mode` can be 'r' for read, 'w' for write, etc.
- `File.read() -> str`: Reads the entire content of an opened file.
- `File.write(content: str) -> None`: Writes content to an opened file.

```jac
# Read text file safely
def read_file(filepath: str) -> str | None {
    try {
        with open(filepath, 'r') as file {
            return file.read();
        }
    } except FileNotFoundError {
        print(f"File not found: {filepath}");
        return None;
    } except Exception as e {
        print(f"Error reading file: {e}");
        return None;
    }
}

# Write text file safely
def write_file(filepath: str, content: str) -> bool {
    try {
        with open(filepath, 'w') as file {
            file.write(content);
        }
        return True;
    } except Exception as e {
        print(f"Error writing file: {e}");
        return False;
    }
}
```

### JSON Serialization
Module: `json`

- `json.load(file: File) -> Any`: Deserializes a JSON document from a file-like object.
- `json.dump(obj: Any, file: File, indent: int) -> None`: Serializes `obj` as a JSON formatted stream to `file`.
- `json.loads(s: str) -> Any`: Deserializes a JSON document from a string.
- `json.dumps(obj: Any, indent: int) -> str`: Serializes `obj` to a JSON formatted string.

```jac
# Read JSON file
def read_json(filepath: str) -> dict | None {
    try {
        with open(filepath, 'r') as file {
            return json.load(file);
        }
    } except FileNotFoundError {
        print(f"JSON file not found: {filepath}");
        return None;
    } except json.JSONDecodeError {
        print(f"Invalid JSON in file: {filepath}");
        return None;
    }
}

impl ConfigReader.save_config {
    try {
        with open(self.config_file, 'w') as file {
            json.dump(self.config_data, file, indent=2);
        }
        print(f"Config saved to {self.config_file}");
        return True;
    } except Exception as e {
        print(f"Error saving config: {e}");
        return False;
    }
}
```

### Operating System Interaction
Module: `os`

- `os.path.exists(path: str) -> bool`: Returns `True` if `path` refers to an existing path or an open file descriptor.

```jac
impl ConfigReader.load_config {
    if not os.path.exists(self.config_file) {
        print(f"Config file {self.config_file} not found, creating default");
        self.create_default_config();
        return True;
    }
    // ...
}
```

# Control Flow

## Conditional Statements

Jac uses `if`, `elif`, and `else` for conditional execution. Curly braces `{}` define code blocks.

### If Statement
Executes code if a condition is true.

```jac
# We can specify multiple possible return types using the '|' symbol.
def divide(a: float, b: float) -> float | str {
    # Check if b is zero before dividing.
    if b == 0.0 {
        return "Error: Cannot divide by zero!";
    }
    # If b is not zero, we can safely perform the division.
    return a / b;
}
```

### If-Elif-Else
Handles multiple conditions sequentially.

```jac
def classify_grade(score: int) -> str {
    if score >= 90 {
        return "A";
    } elif score >= 80 {
        return "B";
    } elif score >= 70 {
        return "C";
    } elif score >= 60 {
        return "D";
    } else {
        return "F";
    }
}

with entry {
    # Raw test scores
    test_scores: list[int] = [78, 85, 92, 69, 88, 95, 72];

    # Get passing grades (70 and above)
    passing_scores: list[int] = [score for score in test_scores if score >= 70];
    print(f"Passing scores: {passing_scores}");

    # Apply curve (+5 points)
    curved_scores: list[int] = [score + 5 for score in test_scores];
    print(f"
```

Example of `if` with `report`:
```jac
                if cached {
                    weather = cached[0];
                    report {
                        "city": weather.city,
                        "temperature": weather.temperature,
                        "description": weather.description,
                        "cached": True
                    };
                } else {
                    # Simulate API call
                    new_weather = WeatherData(
                        city=self.city,
                        temperature=22.5,
                        description="Sunny",
                        last_updated="2024-01-15T10:00:00Z"
                    );
                    here ++> new_weather;

                    report {
                        "city": self.city,
                        "temperature": 22.5,
                        "description": "Sunny",
                        "cached": False
                    };
                }
```
Another example with `metrics`:
```jac
            if cached {
                metrics["cache_hits"] += 1;
                weather = cached[0];
                report {
                    "city": weather.city,
                    "temperature": weather.temperature,
                    "description": weather.description,
                    "cached": True
                };
            } else {
                metrics["cache_misses"] += 1;
                # Simulate external API call
                new_weather = WeatherData(
                    city=self.city,
                    temperature=22.5,
                    description="Sunny",
                    last_updated=datetime.now().isoformat()
                );
                here ++> new_weather;

                report {
                    "city": self.city,
                    "temperature": 22.5,
                    "description": "Sunny",
                    "cached": False
                };
            }
```
Conditional status update:
```jac
            status = "healthy";
            if metrics["requests_total"] == 0 and time() - metrics["start_time"] > 300 {
                status = "warning";  # No requests in 5 minutes
            }
```

## Loops

### For Loop
Iterates over elements in a collection.

```jac
for person in nyc {
    print(f"  {person.name}, age {person.age}");
}
```
```jac
for person in young_nyc {
    print(f"  {person.name}, age {person.age}");
}
```
```jac
for friend in close_friends {
    print(f"  {friend.name}");
}
```
```jac
for person in young_family {
    print(f"  {person.name}, age {person.age}");
}
```
```jac
for person in nyc_connections {
    print(f"  {person.name}");
}
```
```jac
for person in friends_of_friends {
    print(f"  {person.name}");
}
```
```jac
for person in all_people {
    person.level = 0;
}
```
Example with `visit`:
```jac
for child in children {
    child.level = here.level + 1;
}
visit children;
```
Example with `visit` and priority:
```jac
for child in children {
    child.level = here.level + 1;
}
visit :0: children;
```
Example with conditional `for` and `visit`:
```jac
if connections {
    print(f"  Found {len(connections)} connections");
    for conn in connections {
        print(f"    {conn.name} (priority: {conn.priority})");
    }

    # Visit highest priority first using :0:
    visit :0: connections;
}
```
Looping to create objects:
```jac
    for i in range(num_users) {
        user = Profile(username=f"user_{i}");
        users.append(user);

        # Every 10th user follows central user
        if i % 10 == 0 {
            user spawn follow_request();
        }
    }
```
Looping for memory efficiency testing:
```jac
    for batch in range(5) {
        # Create batch of tweets
        for i in range(20) {
            root spawn create_tweet(content=f"Batch {batch} tweet {i}");
        }

        # Delete half of them
        tweets = [root --> Profile ->:Post:-> Tweet];
        for i in range(10) {
            if len(tweets) > i {
                tweets[i] spawn remove_tweet();
            }
        }
    }
```

## Walker Control Flow

### `can` Statement
Defines actions a walker can perform on specific node types.

```jac
walker visit_profile {
    can visit_profile with `root entry {
        visit [-->Profile] else {
            new_profile = here ++> Profile();
            visit new_profile;
        }
    }
}
```

```jac
walker follow_request {
    can follow_user with Profile entry {
        current_profile = [root --> Profile][0];
        if current_profile != here {
            current_profile +>:Follow:+> here;
            here.follower_count += 1;
            report {"message": f"Now following {here.username}"};
        } else {
            report {"error": "Cannot follow yourself"};
        }
    }
}
```

```jac
walker unfollow_request {
    can unfollow_user with Profile entry {
        current_profile = [root --> Profile][0];
        follow_edges = [edge current_profile ->:Follow:-> here];
        if follow_edges {
            del follow_edges[0];
            here.follower_count -= 1;
            report {"message": f"Unfollowed {here.username}"};
        } else {
            report {"error": "Not following this user"};
        }
    }
}
```

```jac
walker like_tweet {
    can like_post with Tweet entry {
        current_profile = [root --> Profile][0];
        existing_likes = [edge current_profile ->:Like:-> here];

        if not existing_likes {
            current_profile +>:Like:+> here;
            here.like_count += 1;
            report {"message": "Tweet liked"};
        } else {
            report {"error": "Already liked this tweet"};
        }
    }
}
```

```jac
walker unlike_tweet {
    can unlike_post with Tweet entry {
        current_profile = [root --> Profile][0];
        like_edges = [edge current_profile ->:Like:-> here];

        if like_edges {
            del like_edges[0];
            here.like_count -= 1;
            report {"message": "Tweet unliked"};
        } else {
            report {"error": "Haven't liked this tweet"};
        }
    }
}
```

### `visit` Statement
Used within walkers to traverse the graph.

```jac
walker debug_graph {
    has visited_nodes: list[str] = [];
    has visited_edges: list[str] = [];
    has max_depth: int = 3;
    has current_depth: int = 0;

    can debug_node with Profile entry {
        if self.current_depth >= self.max_depth {
            print(f"Max depth {self.max_depth} reached at {here.username}");
            return;
        }

        node_info = f"Profile: {here.username} (followers: {here.follower_count})";
        self.visited_nodes.append(node_info);
        print(f"Depth {self.current_depth}: {node_info}");

        # Debug outgoing relationships
        following = [->:Follow:->];
        tweets = [->:Post:->];

        print(f"  Following: {len(following)} users");
        print(f"  Posted: {len(tweets)} tweets");

        # Visit connected nodes
        self.current_depth += 1;
        visit following;
        visit tweets;
        self.current_depth -= 1;
    }
}
```

```jac
walker feed_loader {
    has user_id: str;
    has loaded_tweets: list[dict] = [];
    has users_visited: set[str] = set();
    has errors: list[str] = [];

    can load_user_feed with Profile entry {
        if here.username in self.users_visited {
            self.errors.append(f"Duplicate visit to {here.username}");
            return;
        }

        self.users_visited.add(here.username);

        # Load user's tweets
        user_tweets = [->:Post:-> Tweet];
        for tweet in user_tweets {
            tweet_data = {
                "author": here.username,
                "content": tweet.content,
                "likes": tweet.like_count,
                "created_at": tweet.created_at
            };
            self.loaded_tweets.append(tweet_data);
        }

        # Visit followed users
        following = [->:Follow:-> Profile];
        visit following;
    }
}
```

## Error Handling

### `try-except`
Handles exceptions during execution.

```jac
test error_conditions {
    # Test operations without profile
    try {
        root spawn create_tweet(content="No profile tweet");
        check False;  # Should not reach here
    } except Exception {
        check True;  # Expected behavior
    }

    # Create profile for other tests
    root spawn visit_profile();
    root spawn update_profile(new_username="test_user");

    # Test self-follow prevention
    alice_profile = [root --> Profile][0];
    result = alice_profile spawn follow_request();

    # Should not create self-follow
    self_follows = [alice_profile ->:Follow:-> alice_profile];
    check len(self_follows) == 0;
}
```

## Control Flow

### Conditional Statements (`if`, `else`, `else if`)
Conditional statements execute blocks of code based on whether a condition is true or false.

```jac
if not counter_nodes {
    counter = Counter();
    root ++> counter;
} else {
    counter = counter_nodes[0];
}
```

```jac
if (note.owner == self.user_id or
    self.user_id in note.shared_with or
    note.is_public) {
    // ...
}
```

```jac
if user_profile {
    current_role = user_profile[0].role;
} else {
    new_profile = UserProfile(email=self.user_id);
    here ++> new_profile;
    current_role = Role.VIEWER;
}
```

### Loops (`for`)
Loops iterate over collections or sequences.

```jac
for user in self.users {
    if user['username'] == self.query {
        report user;
        return;
    }
}
```

```jac
for note in all_notes {
    // ...
}
```

### Early Exit (`return`)
The `return` statement exits the current function or walker and can optionally return a value.

```jac
if not manager_nodes {
    report {"error": "No counter manager found"};
    return;
}
```

### Walker Entry Points (`can ... with `root entry`)
Walkers define entry points for execution, often interacting with the graph from the `root` node.

```jac
walker get_counter {
    obj __specs__ {
        static has auth: bool = False;
    }

    can get_counter_endpoint with `root entry {
        counter_nodes = [root --> Counter];
        if not counter_nodes {
            counter = Counter(created_at="2024-01-15");
            root ++> counter;
            report {"value": 0, "status": "created"};
        } else {
            counter = counter_nodes[0];
            report {"value": counter.value, "status": "existing"};
        }
    }
}
```

```jac
walker create_counter {
    has name: str;

    obj __specs__ {
        static has auth: bool = False;
    }

    can create_counter_endpoint with `root entry {
        manager_nodes = [root --> CounterManager];
        if not manager_nodes {
            manager = CounterManager(created_at=str(datetime.now()));
            root ++> manager;
        } else {
            manager = manager_nodes[0];
        }

        result = manager.create_counter(self.name);
        report result;
    }
}
```

### Function Definitions (`def`)
Functions encapsulate reusable blocks of code.

```jac
def create_counter(name: str) -> dict {
    existing = [self --> Counter](?name == name);
    if existing {
        return {"status": "exists", "counter": existing[0].name};
    }

    new_counter = Counter(name=name, value=0);
    self ++> new_counter;
    return {"status": "created", "counter": name};
}
```

### Access Control (`_.allow_root`)
The `_.allow_root` function is used to grant specific access levels to nodes in the graph.

```jac
for member_id in self.team_members {
    _.allow_root(here, NodeAnchor.ref(member_id), self.access_level);
}
```

```jac
if is_friend {
    _.allow_root(here, NodeAnchor.ref(self.viewer_id), "READ");
    report "Access granted to friend!";
} else {
    report "Access denied - not a friend!";
}
```

# Control Flow

## Conditionals

### `if`/`elif`/`else` Statements
Executes code blocks based on conditions.

```jac
if condition {
    // Code to execute if condition is true
} elif another_condition {
    // Code to execute if another_condition is true
} else {
    // Code to execute if no conditions are true
}
```

### `switch`/`case` Statements
Executes code blocks based on matching values. Supports JavaScript-style fallthrough.

```jac
switch value {
    case 1 {
        // Code for value 1
    }
    case 2 {
        // Code for value 2
        // Fallthrough if no break
    }
    default {
        // Code if no case matches
    }
}
```

### Typed Context Blocks (OSP)
Conditional code execution based on runtime types for Object-Spatial Programming.

```jac
-> NodeType {
    // Code executes if current node is NodeType
}

-> WalkerType {
    // Code executes if current walker is WalkerType
}
```

## Loops

### `for` Loop
Iterates over a sequence or range.

```jac
for item in data {
    process_item(item);
}
```

```jac
for i in range(10) {
    process_chunk(i);
}
```

```jac
# Series connection (one after the other)
node_1 ++> node_list[0];
for i to i < length(node_list) by i+=1 {
    node_list[i] ++> node_list[i+1];
}
```

### `while` Loop
Repeats a block of code as long as a condition is true. Supports an `else` part.

```jac
while condition {
    // Code to repeat
} else {
    // Code to execute if loop finishes without a break
}
```

### Agent Loops
Common pattern for agents to continuously process.

```jac
walker MyAgent {
    has results: list = [];
    can complex_computation(item);

    spawn entry {
        while (by llm()) { // Loop until LLM decides to stop
            // Agent logic here
            for item in dataset {
                processed = complex_computation(item);
                self.results.append(processed);
            }
        }
    }
}
```

## Error Handling

### `try`/`except`
Handles exceptions during execution.

```jac
try {
    // Code that might raise an error
    data = fetch_data(self.input_id);
    if not data {
        self.error_message = "No data found";
        return;
    }
    self.results = process_data(data);
    self.success = True;
} except e {
    // Code to execute if an error occurs
    self.error_message = str(e);
    log_error(self.input_id, str(e));
}
```

## Concurrency

### `async`/`await`
Jac supports Python's `async`/`await` for asynchronous operations.

```jac
async def fetch_data():
    await some_async_operation()
```

### `flow`/`wait`
Jac-specific keywords for concurrent execution. `flow` initiates parallel execution, and `wait` synchronizes these operations.

```jac
flow {
    // Expressions to run in parallel
    expr1();
    expr2();
}
wait; // Synchronize parallel operations
```

## Control Flow Graph (CFG)

### `cfg.` CLI Command
Generates a dot graph of the control flow graph(s) for a specified `.jac` file.

```bash
jac cfg. my_file.jac
```

### CFG Structure
Control Flow Graphs are built to analyze program flow, identifying basic blocks, linking them with edges, and tracking loop structures and conditional branches.

```mermaid
graph TD
    subgraph "CFG Construction"
        A[Entry Block] --> B[Basic Block 1]
        B --> C{If Statement}
        C -->|True| D[Then Block]
        C -->|False| E[Else Block]
        D --> F[Merge Block]
        E --> F
        F --> G[Exit Block]
    end
```

### `UniCFGNode`
Represents a node in the Control Flow Graph.

```python
class UniCFGNode(UniNode):
    """Node participating in control flow"""
    bb_in: list[UniCFGNode]   # Incoming edges
    bb_out: list[UniCFGNode]  # Outgoing edges
```

## Graph Breaks (Static Analysis)

Graph breaks occur when static analysis cannot determine the control flow due to data-dependent operations, preventing optimization.

### Common Graph Break Causes:
1.  **Data-dependent conditionals**: `if tensor.sum() > 0`
2.  **Data-dependent loops**: `for i in range(tensor.item())`
3.  **Python I/O operations**: `print`, file operations
4.  **Unsupported Python builtins**: `getattr`, `inspect` module
5.  **Dynamic attribute access**
6.  **Certain tensor operations that create dynamic shapes**

### Example of Data-Dependent Conditional
```python
def forward(self, x):
    x = self.linear1(x)

    # GRAPH BREAK: Data-dependent control flow
    if x.sum() > 0:  # Cannot evaluate Proxy to bool
        x = self.linear2(x)
    else:
        x = self.linear3(x)

    return self.output(x)
```

### Workarounds for Graph Breaks:
*   **Conditionals**: Use `torch.where()` or masking for data-dependent `if`/`else`.
    ```python
    # Before
    if condition:
        x = tensor_a
    else:
        x = tensor_b

    # After (transformed to)
    x = torch.where(condition, tensor_a, tensor_b)
    ```
*   **Loops**: Use static loop bounds or vectorize operations for dynamic loops.
    *   Static loop bounds (e.g., `range(constant)`, list literals) can be unrolled.
    *   Dynamic loop bounds (e.g., `range(tensor.item())`) cause graph breaks.

## Control Flow

### Functions
Functions are defined using the `def` keyword, followed by the function name, parameters with optional type hints, and a return type.

```jac
def make_transaction(buyer_name: str, seller_name: str, item_name: str, price: int| None = None) -> bool {
    buyer = person_record[buyer_name];
    seller = person_record[seller_name];

    # Find item in seller's inventory
    item_to_buy = None;
    item_index = -1;
    for i in range(len(seller.inventory)) {
        if seller.inventory[i].name.lower() == item_name.lower() {
            item_to_buy = seller.inventory[i];
            item_index = i;
            break;
        }
    }

    price = price or item_to_buy.price;

    # Validate transaction
    if not item_to_buy or buyer.money < price {
        return False;
    }

    # Execute transfer
    buyer.money -= price;
    seller.money += price;
    buyer.inventory.append(item_to_buy);
    seller.inventory.pop(item_index);
    return True;
}
```

### Loops
Jac supports `for` and `while` loops for iteration.

#### For Loop
Iterate over a range or collection.
```jac
for i in range(len(seller.inventory)) {
    if seller.inventory[i].name.lower() == item_name.lower() {
        item_to_buy = seller.inventory[i];
        item_index = i;
        break;
    }
}
```

#### While Loop (Agent Loop Pattern)
Used for continuous execution, often seen in agent-based systems.
```jac
while True {
    # AI agent generates response with state
    chat = chat_with_player(player, npc, history);
    history.append(chat);

    # Display game state
    for p in [player, npc] {
        print(p.name, ":  $", p.money);
        for i in p.inventory {
            print("  ", i.name, ":  $", i.price);
        }
    }

    # Show NPC response and get player input
    print("\n[[npc]] >> ", chat.message);
    inp = input("\n[[Player input]] >> ");
    history.append(Chat(person=player.name, message=inp));
}
```

### Conditional Statements
`if`, `elif`, and `else` are used for conditional execution.
```jac
if len(self.prev_levels) > 3 {
    self.prev_levels.pop(0);
    self.prev_level_maps.pop(0);
}
```
```jac
if self.current_level % 2 == 0 {
    self.current_difficulty += 1;
}
```

### Entry Point
The `with entry` block defines the main execution point of a Jac program.
```jac
with entry {
    level_manager = LevelManager();

    print("Generating 3 AI-powered levels...\n");

    for i in range(3) {
        level, map_obj = level_manager.get_next_level();
        visual_map = level_manager.get_map(map_obj);

        print(f"=== LEVEL {i+1} ===");
        print(f"Difficulty: {level.difficulty}");
        print(f"Enemies: {level.num_enemies}");
        print(f"Walls: {level.num_wall}");
        print("Map:");
        for row in visual_map {
            print(row);
        }
        print("\n");
    }
}
```

### Imports
`import from` is used to bring definitions from other modules into the current scope.
```jac
import from level_manager { LevelManager }
```