# Error Handling

# Error Handling

## General Concepts
-   **Output Panel**: Displays program output, including print statements, results, error messages, and debugging information.
-   **Graceful Handling**: Essential for robust applications, especially in AI integrations and asynchronous operations.
-   **Runtime Error Reporting**: Improvements to CLI reporting for runtime errors.
-   **Parser Fixes**: Resolved infinite recursion issues with malformed tuple assignments.
-   **Syntax Error Messages**: Enhanced clarity and descriptiveness, highlighting location and cause (e.g., "Missing semicolon").
-   **TypeChecker Diagnostics**: Static analysis for early error detection and improved code quality.
    -   **Type Annotation Validation**: Checks for type mismatches in explicit annotations.
    -   **Type Inference**: Simple inference with validation against declared types.
    -   **Member Access Type Checking**: Validates `obj.field.subfield` patterns.
    -   **Import Symbol Type Checking**: Basic inference for imported symbols.
    -   **Function Call Return Type Validation**: Checks return types (parameter validation not yet supported).
    -   **Magic Method Support**: Type checking for `__call__`, `__add__`, `__mul__`.
    -   **Binary Operation Type Checking**: Validates operators, including custom ones.
    -   **Class Instantiation**: Type checking for constructor calls and member access.
    -   **Cyclic Symbol Detection**: Identifies self-referencing variable assignments.
    -   **Missing Import Detection**: Flags imports from non-existent modules.
-   **VS Code Extension (VSCE)**: Type errors appear with highlighting during editing.
-   **Windows LSP Improvements**: Ensures only current errors are displayed.

## Error Handling Constructs

### `try...except`
Used for catching and handling exceptions during execution.

```jac
try {
    // Code that might raise an exception
} except FileNotFoundError {
    print(f"File not found: {filepath}");
    return None;
} except Exception as e {
    print(f"An unexpected error occurred: {e}");
    return None;
}
```

### `raise`
Used to explicitly raise an exception.

```jac
impl Calculator.divide {
    if b == 0.0 {
        raise ValueError("Division by zero");
    }
    result = a / b;
    return round(result, self.precision);
}
```

### `assert`
Used for testing and validation, raising an `AssertionError` if the condition is false.

```jac
test error_conditions {
    try {
        root spawn create_tweet(content="No profile tweet");
        check False;  # Should not reach here
    } except Exception {
        check True;  # Expected behavior
    }
}
```

## Standard Library Error Handling

### File I/O (`file`, `os`)
-   **`open(path: str, mode: str) -> File`**: Opens a file.
-   **`file.read() -> str`**: Reads the entire content of an opened file.
-   **`file.write(content: str) -> None`**: Writes content to an opened file.
-   **`os.path.exists(path: str) -> bool`**: Checks if a path exists.

```jac
# Read text file safely
def read_file(filepath: str) -> str | None {
    try {
        with open(filepath, 'r') as file {
            return file.read();
        }
    } except FileNotFoundError {
        print(f"File not found: {filepath}");
        return None;
    } except Exception as e {
        print(f"Error reading file: {e}");
        return None;
    }
}

# Write text file safely
def write_file(filepath: str, content: str) -> bool {
    try {
        with open(filepath, 'w') as file {
            file.write(content);
        }
        return True;
    } except Exception as e {
        print(f"Error writing file: {e}");
        return False;
    }
}

impl ConfigReader.load_config {
    if not os.path.exists(self.config_file) {
        print(f"Config file {self.config_file} not found, creating default");
        self.create_default_config();
        return True;
    }
    // ... (rest of the try-except block)
}
```

### JSON (`json`)
-   **`json.load(file_object) -> dict | list`**: Deserializes a JSON document from a file-like object.
-   **`json.dump(obj, file_object, indent: int) -> None`**: Serializes `obj` as a JSON formatted stream to a file-like object.
-   **`json.dumps(obj) -> str`**: Serializes `obj` to a JSON formatted string.
-   **`json.loads(s: str) -> dict | list`**: Deserializes a JSON document from a string.

```jac
# Read JSON file
def read_json(filepath: str) -> dict | None {
    try {
        with open(filepath, 'r') as file {
            return json.load(file);
        }
    } except FileNotFoundError {
        print(f"JSON file not found: {filepath}");
        return None;
    } except json.JSONDecodeError {
        print(f"Invalid JSON in file: {filepath}");
        return None;
    }
}

impl ConfigReader.load_config {
    try {
        with open(self.config_file, 'r') as file {
            self.config_data = json.load(file);
        }
        print(f"Config loaded from {self.config_file}");
        return True;
    } except json.JSONDecodeError {
        print(f"Invalid JSON in {self.config_file}");
        return False;
    } except Exception as e {
        print(f"Error loading config: {e}");
        return False;
    }
}

impl ConfigReader.save_config {
    try {
        with open(self.config_file, 'w') as file {
            json.dump(self.config_data, file, indent=2);
        }
        print(f"Config saved to {self.config_file}");
        return True;
    }
    // ... (rest of the try-except block)
}
```

## Agent Patterns and Error Handling

### Robust AI Integration
Using `try...except` blocks within agent methods to provide fallback mechanisms or detailed error reporting.

```jac
obj RobustCaptioner {
    has fallback_enabled: bool = True;

    """Generate caption with error handling."""
    def safe_caption(image_path: str) -> dict {
        try {
            caption = self.generate_caption_ai(image_path);
            return {
                "success": True,
                "caption": caption,
                "source": "ai"
            };
        } except Exception as e {
            if self.fallback_enabled {
                fallback_caption = f"Image analysis unavailable for {image_path}";
                return {
                    "success": False,
                    "caption": fallback_caption,
                    "source": "fallback",
                    "error": str(e)
                };
            } else {
                raise e;
            }
        }
    }

    """AI-powered caption generation."""
    def generate_caption_ai(image_path: str) -> str by reliable_llm();
}
```

### Asynchronous Walker Error Handling
Walkers can capture error states and messages.

```jac
async walker safe_process {
    has input_id: str;
    has success: bool = False;
    has error_message: str = "";
    has results: dict = {};

    can enter with `root entry {
        try {
            data = fetch_data(self.input_id);
            if not data{
                self.error_message = "No data found";
                return;
            }
            self.results = process_data(data);
            self.success = True;
        } except e {
            self.error_message = str(e);
            log_error(self.input_id, str(e));
        }
    }
}
```

### Walker Error Accumulation
Walkers can collect errors encountered during traversal.

```jac
walker feed_loader {
    has user_id: str;
    has loaded_tweets: list[dict] = [];
    has users_visited: set[str] = set();
    has errors: list[str] = [];

    can load_user_feed with Profile entry {
        if here.username in self.users_visited {
            self.errors.append(f"Duplicate visit to {here.username}");
            return;
        }
    }
}
```

## Imports and Error Handling

### `import:py`
Used for Python interop.

### Unsupported Import Patterns
| Pattern | Why Not Supported | Workaround |
|---------|-------------------|------------|
| `default` or `*` in non-`cl` imports | No Python equivalent for default/namespace exports | Use `cl import` instead |
| Side-effect only imports | Not yet implemented | Use regular Python import for now |
| Dynamic imports | Runtime feature, not syntax | Use JavaScript directly or add to roadmap |
| Import assertions (JSON, CSS) | Stage 3 proposal, specialized | May add in future |

```jac
# ❌ Incorrect Usage
import from react { default as React }   # Error: default requires cl
import from lodash { * as _ }            # Error: namespace requires cl
cl import from lodash { * as _, map }    # Generates invalid JS

# ❌ Incorrect Usage - Without quotes
cl import from react-dom { render }  # Error: hyphen not allowed in identifier
```

### Validation
-   `pyast_gen_pass.py`: Logs errors for `default` or `*` without `cl`, and string literal imports without `cl`.

## UI/Streamlit Error Display

```jac
            if num2 != 0 {
                result = num1 / num2;
            } else {
                st.error("Cannot divide by zero!");
                return;
            }
```