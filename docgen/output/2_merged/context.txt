# Walker Context

## Context

### Walker Context
- **Jac Clouds Traverse API**:
    - `source`: Starting node/edge. Defaults to root.
    - `detailed`: If response includes archetype context. Defaults to `false`.
    - `depth`: How deep the traversal from source. Count includes edges. Defaults to 1.
    - `node_types`: Node filter by name. Defaults to no filter.
    - `edge_types`: Edge filter by name. Defaults to no filter.
- `save(...)` should not override root in runtime.
- Each request executes in the context of the authenticated user's root node.
- All walker execution happens in the context of the authenticated user.

### WebSocket Walker Event Context
When triggering a walker event via WebSocket, context can be provided in the request payload.

```python
{
    "type": "walker",
    "walker": "your_event_name",
    "response": true,
    "context": {
        "val": 1
    }
}
```

```js
// TRIGGER WALKER EVENT
client.send(JSON.stringify({
	"type": "walker",
	"walker": "your_walker_name",
	"response": true,
	"context": {}
}));
```

### Node-Based Filtering
Restricts traversal to specific nodes that satisfy predefined conditions.
- Limit traversal to nodes with certain attributes or properties.
- Filter nodes dynamically based on walker state or external context.

### Edge-Based Filtering
Controls traversal by selecting edges based on specific attributes or conditions. Useful for weighted graphs or context-sensitive connections.

### Context Gathering
Identifying relevant libraries, frameworks, and patterns.

### `detailed` Parameter
- `detailed`: `boolean` - If `true`, the response will include the archetype's context for each traversed item. Default: `false`.

### Context-Aware `by llm()` Methods
`by llm()` automatically adds attributes of the initialized object into the LLM prompt, providing extra context.

```jac
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has age: int;

    def introduce() -> str by llm();
    def suggest_hobby() -> str by llm();
}

with entry {
    alice = Person("Alice", 25);
    print(alice.introduce());
    print(alice.suggest_hobby());
}
```

### Adding Explicit Context for Functions, Methods and Objects

#### Adding Context with Docstrings
Docstrings provide context for LLM-integrated functions, helping the LLM understand function purpose and expected behavior.

```jac
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

"""Translate text to the target language."""
def translate(text: str, target_language: str) -> str by llm();

"""Generate a professional email response based on the input message tone."""
def generate_email_response(message: str, recipient_type: str) -> str by llm();
```

#### Adding Context with Semantic Strings (Semstrings)
The `sem` keyword provides semantic information for object attributes and function parameters.

```jac
obj Person {
    has name;
    has dob;
    has ssn;
}

sem Person = "Represents the personal record of a person";
sem Person.name = "Full name of the person";
sem Person.dob = "Date of Birth";
sem Person.ssn = "Last four digits of the Social Security Number of a person";

"""Calculate eligibility for various services based on person's data."""
def check_eligibility(person: Person, service_type: str) -> bool by llm();
```

#### Additional Context with `incl_info`
The `incl_info` parameter provides additional context to LLM methods for context-aware processing.

```jac
import from byllm.llm { Model }
import from datetime { datetime }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has date_of_birth: str;

    # Uses the date_of_birth attribute and "today" information
    # from incl_info to calculate the person's age
    def calculate_age() -> str by llm(
        incl_info={
            "today": datetime.now().strftime("%d-%m-%Y"),
        }
    );
}
```

#### When to Use Each Approach
- **Docstrings**: For function-level context and behavior description.
- **Semstrings**: For attribute-level descriptions and domain-specific terminology.
- **`incl_info`**: To selectively include relevant object state in method calls.

### AI Agents (Stateful)
AI agents can maintain persistent state and context across interactions.

```jac
obj Chat {
    has person: str;
    has message: str;
}
```

```jac
def chat_with_player(player: Person, npc: Person, chat_history: list[Chat]) -> Chat
    by llm(method="ReAct", tools=[make_transaction]);
```
- **Maintains State**: Uses `chat_history` to remember previous interactions.
- **Reasons**: Processes conversation context using ReAct method.
- **Persists Context**: Builds understanding across multiple conversation turns.
- **State Management**: Achieved through structured data objects (`Person`, `InventoryItem`), conversation history (`Chat` objects), and global registries (`person_record`).