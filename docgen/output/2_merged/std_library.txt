# Standard Library

## Standard Library Reference

### File I/O
Module: `file`

-   `file.open(path: str, mode: str = "r") -> File`
    Opens a file at the specified `path` with the given `mode`.
    -   `mode`: "r" (read), "w" (write), "a" (append), "b" (binary).
    ```jac
    with file.open("my_file.txt", "w") as f:
        f.write("Hello, Jac!")
    ```

-   `File.read(size: int = -1) -> str`
    Reads `size` bytes from the file. If `size` is -1, reads the entire file.
    ```jac
    with file.open("my_file.txt", "r") as f:
        content = f.read()
    ```

-   `File.write(data: str) -> int`
    Writes `data` to the file. Returns the number of characters written.
    ```jac
    with file.open("my_file.txt", "w") as f:
        f.write("New content.")
    ```

-   `File.close()`
    Closes the file. (Automatically called when using `with` statement).

### Operating System Interaction
Module: `os`

-   `os.getenv(key: str, default: str | None = None) -> str | None`
    Returns the value of the environment variable `key`. If not found, returns `default`.
    ```jac
    api_key = os.getenv("MY_API_KEY")
    ```

-   `os.setenv(key: str, value: str)`
    Sets the environment variable `key` to `value`.
    ```jac
    os.setenv("TEMP_VAR", "some_value")
    ```

-   `os.system(command: str) -> int`
    Executes a shell command. Returns the exit status.
    ```jac
    status = os.system("ls -l")
    ```

-   `os.mkdir(path: str)`
    Creates a directory at `path`.
    ```jac
    os.mkdir("new_directory")
    ```

-   `os.rmdir(path: str)`
    Removes an empty directory at `path`.
    ```jac
    os.rmdir("empty_directory")
    ```

-   `os.remove(path: str)`
    Removes a file at `path`.
    ```jac
    os.remove("old_file.txt")
    ```

-   `os.path.exists(path: str) -> bool`
    Checks if a path exists.
    ```jac
    if os.path.exists("my_file.txt"):
        print("File exists.")
    ```

-   `os.path.join(*paths: str) -> str`
    Joins path components intelligently.
    ```jac
    full_path = os.path.join("dir1", "dir2", "file.txt")
    ```

### JSON Serialization
Module: `json`

-   `json.dumps(obj: Any, indent: int | None = None) -> str`
    Serializes `obj` to a JSON formatted string.
    -   `indent`: If provided, pretty-prints JSON with the specified indent level.
    ```jac
    import:py from json {dumps};
    data = {"name": "Alice", "age": 30}
    json_str = dumps(data, indent=2)
    ```

-   `json.loads(s: str) -> Any`
    Deserializes a JSON formatted string `s` to a Jac object.
    ```jac
    import:py from json {loads};
    json_str = '{"name": "Bob", "age": 25}'
    data = loads(json_str)
    ```

### Logging
Module: `logging`

-   `logging.debug(msg: str)`
    Logs a message with level `DEBUG`.
    ```jac
    logging.debug("This is a debug message.")
    ```

-   `logging.info(msg: str)`
    Logs a message with level `INFO`.
    ```jac
    logging.info("Application started.")
    ```

-   `logging.warning(msg: str)`
    Logs a message with level `WARNING`.
    ```jac
    logging.warning("Disk space low.")
    ```

-   `logging.error(msg: str)`
    Logs a message with level `ERROR`.
    ```jac
    logging.error("Failed to connect to database.")
    ```

-   `logging.critical(msg: str)`
    Logs a message with level `CRITICAL`.
    ```jac
    logging.critical("System crashed!")
    ```

### Imports
-   `import:py`
    Imports Python modules or specific components from them.
    ```jac
    import:py math;
    import:py from collections {defaultdict};
    ```

### Spawning
-   `spawn`
    Creates new nodes or edges. Can be used on single nodes, lists, or groups.
    ```jac
    node User;
    node Post;

    walker create_user {
        can spawn User;
        root {
            u = spawn User;
            u.name = "Alice";
        }
    }

    walker create_post {
        can spawn Post;
        root {
            p = spawn Post;
            p.title = "My First Post";
            // Spawning an edge between existing nodes
            spawn edge from root to p;
        }
    }

    // Spawning multiple nodes from a list
    walker create_users_from_list {
        can spawn User;
        root {
            names = ["Bob", "Charlie"];
            for name in names:
                spawn User(name=name);
        }
    }
    ```

### Type Annotations
-   `has x: type`
    Explicitly defines the type of a field or variable.
    ```jac
    node Person {
        has name: str;
        has age: int;
        has is_active: bool = true;
    }

    walker greet {
        has message: str = "Hello";
        root {
            val: float = 3.14;
            print(message);
        }
    }
    ```

### Reference Operator
-   `&`
    Used to pass arguments by reference, allowing modification of the original variable within a function or walker.
    ```jac
    walker modify_list {
        can take_list(l: &list) {
            l.append(4);
        }
        root {
            my_list = [1, 2, 3];
            take_list(&my_list);
            print(my_list); // Output: [1, 2, 3, 4]
        }
    }
    ```

### Node Properties
-   `.edges`
    A property of a node that returns a list of all edges connected to it.
    ```jac
    node A;
    node B;
    edge E;

    walker connect_nodes {
        root {
            a = spawn A;
            b = spawn B;
            spawn E(from a, to b);
            print(a.edges); // List of edges connected to 'a'
        }
    }
    ```

### Semantic Strings
-   `str "..."`
    Defines a string with semantic meaning, often used for LLM interactions or specific data types.
    ```jac
    walker ask_llm {
        root {
            question = str "What is the capital of France?";
            response = by llm(question);
            print(response);
        }
    }
    ```

### Asynchronous Operations
-   `async`, `await`
    Keywords for defining and calling asynchronous functions (walkers).
    ```jac
    async walker fetch_data {
        root {
            // Simulate an async operation
            print("Fetching data...");
            await sleep(1); // Assuming 'sleep' is an async function
            return "Data fetched!";
        }
    }

    walker main {
        root {
            result = await fetch_data();
            print(result);
        }
    }
    ```

### Assertions
-   `assert`
    Used for testing and validation. Raises an error if the condition is false.
    ```jac
    walker test_function {
        root {
            x = 10;
            assert x > 5, "x should be greater than 5";
            assert x == 10;
            print("Assertions passed.");
        }
    }
    ```

### Persistence
-   `save`, `load`
    Used to persist and retrieve graph data.
    ```jac
    node MyNode { has value: int; }

    walker create_and_save {
        root {
            n = spawn MyNode(value=42);
            save "my_graph.jac";
        }
    }

    walker load_and_inspect {
        root {
            load "my_graph.jac";
            // Access the loaded graph
            for n in @.nodes:
                if n is MyNode:
                    print(n.value);
        }
    }
    ```

### Agent Patterns
-   Agent Loops with `by llm()`
    Common pattern for iterative agent behavior driven by an LLM.
    ```jac
    node State { has history: list = []; }

    walker AgentLoop {
        root {
            state = spawn State;
            while (state.history.len < 5) {
                prompt = str "Current history: " + state.history.to_str() + ". What should I do next?";
                action = by llm(prompt);
                state.history.append(action);
                print("Agent decided: " + action);
            }
            print("Agent loop finished.");
        }
    }
    ```