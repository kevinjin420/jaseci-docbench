# Abilities and Interactions

# Abilities and Interactions

## Abilities

Abilities are special methods that can be defined on nodes and walkers. They can be callable (like standard OOP methods) or visit-dependent, triggering when a walker interacts with a node.

### Ability Syntax

```jac
can ability_name with [Node_Type] [entry|exit] {
    // Ability logic
}
```

-   `can ability_name`: Defines an ability named `ability_name`.
-   `with [Node_Type] [entry|exit]`: Specifies when the ability is triggered.
    -   `entry`: Triggered when a walker enters a node.
    -   `exit`: Triggered when a walker exits a node.
    -   If `Node_Type` is omitted, it applies to any node interaction.
    -   `root entry`: A special trigger for walkers, executed once at the beginning of the walker's operation.

### Keywords within Abilities

-   `self`: References the node or walker on which the ability is defined.
-   `here`: References the current node being visited by a walker (when defined on a walker) or the visiting walker (when defined on a node).

### Node Abilities

Callable abilities on nodes are similar to standard methods. Visit-dependent abilities on nodes are triggered when a specific type of walker interacts with the node.

```jac
node test_node {
    has value: int;

    // Callable ability
    def callable {
        print(f"===== Callable on {self}");
    }

    // Visit-dependent abilities
    can log_entry with entry { // Triggered by any walker entering
        print(f">>> Some Walker entered the node: ", self);
    }
    can log_test_walker_entry with test_walker entry { // Triggered by 'test_walker' entering
        print(f">>> {here} entered the node {self}");
        here.callable(); // Accessing a callable ability of the visiting walker
    }
    can log_test_walker_exit with test_walker exit { // Triggered by 'test_walker' exiting
        print(f"<<< {here} exited the node {self}");
    }
    can log_exit with exit { // Triggered by any walker exiting
        print(f"<<< Some Walker exited the node {self}");
    }
}
```

### Walker Abilities

Walkers can have their own attributes and abilities, including both callable and visit-dependent ones. Walkers prioritize their visit-dependent abilities before executing the abilities of the visited node.

```jac
walker Walker {
    can entry1 with entry { // Triggered once when the walker is spawned
        print("walker entry");
    }

    can entry2 with `root entry { // Triggered once at the beginning of traversal
        print("walker enter to root");
        visit [-->]; // Traverse outgoing edges
    }

    can entry3 with Node entry { // Triggered when entering any Node type
        print(f"{here.val}-1"); // 'here' refers to the Node
    }

    can exit1 with Node exit { // Triggered when exiting any Node type
        print(f"{here.val}-6"); // 'here' refers to the Node
    }

    can exit2 with exit { // Triggered once when the walker finishes traversal
        print("walker exit");
    }
}
```

### Common Ability Patterns

#### Root Entry Abilities

These abilities are executed once when the walker starts. They are often used for initial setup, data fetching, or validation.

```jac
can start with `root entry {
    print("Starting journey!");
    visit [-->];
}
```

```jac
can get_weather_data with `root entry {
    weather_info = f"Weather in {self.city}: Sunny, 25°C";
    report {"city": self.city, "weather": weather_info};
}
```

```jac
can create_new_note with `root entry {
    new_note = Note(
        title=self.title,
        content=self.content,
        author=self.author
    );
    here ++> new_note; // Create an edge from 'here' (root) to the new note
    report {"message": "Note created", "id": new_note.id};
}
```

```jac
can fetch_all_notes with `root entry {
    all_notes = [-->(`?Note)]; // Traverse all paths to find nodes of type Note
    notes_data = [
        {"id": n.id, "title": n.title, "author": n.author}
        for n in all_notes
    ];
    report {"notes": notes_data, "total": len(notes_data)};
}
```

```jac
can validate_and_create with `root entry {
    // Jac automatically validates types before this runs
    if len(self.title) < 3 {
        report {"error": "Title must be at least 3 characters"};
        return;
    }
    new_note = Note(title=self.title, content=self.content);
    here ++> new_note;
    report {"message": "Note created successfully"};
}
```

#### Node-Specific Entry Abilities

These abilities execute when a walker enters a node of a specific type.

```jac
can greet with Person entry {
    print(f"Hello, {here.name}!"); // 'here' refers to the Person node
    self.greeting_count += 1; // 'self' refers to the walker
    visit [-->];
}
```

#### API Endpoint Abilities

Abilities can serve as API endpoints, using `report` to return data.

```jac
import from datetime {datetime}

walker public_info {
    obj __specs__ {
        static has methods: list = ["get"];
        static has auth: bool = False;
    }

    can get_current_time with `root entry{
        report {
            "timestamp": datetime.now().isoformat()
        };
    }
}
```

```jac
walker search_users {
    has query: str;
    static has users: list = [
        {"username": "alice", "email": "alice@example.com"},
        {"username": "bob", "email": "bob@example.com"}
    ];

    obj __specs__ {
        static has methods: list = ["get"];
        static has as_query: list = ["query"];
        static has auth: bool = False;
    }

    can search_by_name with `root entry{
        for user in self.users {
            if user['username'] == self.query {
                report user;
                return;
            }
        }
        report {"error": f"User with username {self.query} not found"};
    }
}
```

```jac
import from fastapi { UploadFile }

walker single_file_upload {
    has file: UploadFile;

    obj __specs__ {
        static has methods: list = ["post"];
        static has auth: bool = False;
    }

    can enter with `root entry {
        report {
            "output": f"Received file: {self.file.filename}"
        };
    }
}
```

#### Caching and Metrics Abilities

Abilities can implement caching logic and update metrics.

```jac
can fetch_weather with `root entry {
    // Update metrics
    metrics["requests_total"] += 1;
    metrics["requests_per_city"][self.city] = metrics["requests_per_city"].get(self.city, 0) + 1;

    // Check cache first
    cached = [-->(`?WeatherData)](?city == self.city);

    if cached {
        metrics["cache_hits"] += 1;
        weather = cached[0];
        report {
            "city": weather.city,
            "temperature": weather.temperature,
            "description": weather.description,
            "cached": True
        };
    } else {
        metrics["cache_misses"] += 1;
        // Simulate external API call
        new_weather = WeatherData(
            city=self.city,
            temperature=22.5,
            description="Sunny",
            last_updated=datetime.now().isoformat()
        );
        here ++> new_weather;

        report {
            "city": self.city,
            "temperature": 22.5,
            "description": "Sunny",
            "cached": False
        };
    }
}
```

```jac
can check_health with `root entry {
    uptime = time() - metrics["start_time"];
    cache_hit_rate = metrics["cache_hits"] / max(metrics["requests_total"], 1) * 100;

    report {
        "status": "healthy",
        "uptime_seconds": uptime,
        "total_requests": metrics["requests_total"],
        "cache_hit_rate_percent": round(cache_hit_rate, 2),
        "cached_cities": len([-->(`?WeatherData)]),
        "timestamp": datetime.now().isoformat()
    };
}
```

```
## Abilities and Interactions

### Walker Abilities
Walkers can define special abilities that trigger based on their entry point.

-   **Entry through root:**
    ```jac
    walker walker_name {
      can walker_ability with `root entry;
    }
    ```
-   **Entry through a specific node:**
    ```jac
    walker walker_name {
      can walker_ability with specific_node entry;
    }
    ```
-   **Entry through root or a specific node:**
    ```jac
    walker walker_name {
      can walker_ability with `root | specific_node entry;
    }
    ```
-   **Accessing the current walker instance:** Within a walker's object-spatial ability, `self` refers to the current walker instance.
    ```jac
    walker walker_name {
        can walker_ability with node_name entry{
            print("Current walker : ", self);
        }
    }
    ```

### Node Abilities
Nodes can define special abilities that trigger when a specific walker visits them.

-   **Node ability triggered by a walker:**
    ```jac
    node node_name {
      can node_ability with walker_name entry;
    }
    ```
-   **Accessing the visiting walker instance:** Within a node's object-spatial ability, `here` refers to the current walker instance.
    ```jac
    walker walker_name {
        can log_visit with test_node entry{
            print("Visiting node : ", here);
        }
    }
    ```
    ```jac
    node node_name {
        can node_ability with walker_name entry{
            print("Current walker : ", here);
        }
    }
    ```

### Agentic Node Patterns

Nodes can act as agents, maintaining local state and responding to visitor events. The `can execute with <walker_name> entry` ability is a common entry point for agent behavior.

#### Example: Task Handling Agent
```jac
node TaskHandling {
  def get_current_time() -> str {
    return time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime());
  }

  def add_task(task: str, date: str, time: str) -> str {
    task_created = Task(task=task, date=date, time=time);
    self ++> task_created;
    return "Task added successfully";
  }

  def summarize_tasks -> str {
    scheduled_tasks = [self-->(`?Task)];
    return str(scheduled_tasks);
  }

  def route_and_run(utterance: str) -> str by llm(
    method="ReAct",
    tools=([self.add_task, self.get_current_time, self.summarize_tasks])
  );

  can execute with task_manager entry {
    print("[TaskHandling Node Activated]");
    response = self.route_and_run(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### Example: Email Handling Agent
```jac
node EmailHandling {
  def write_email_content(utterance: str) -> str by llm();
  def route_and_run(utterance: str) -> str by llm(
    method="ReAct",
    tools=([self.write_email_content])
  );
  can execute with task_manager entry {
    print("[EmailHandling Node Activated]");
    response = self.route_and_run(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### Example: General Chat Agent
```jac
node GeneralChat {
  def chat(utterance: str) -> str by llm();
  can execute with task_manager entry {
    print("[GeneralChat Node Activated]");
    response = self.chat(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### Example: Task Manager Walker (Agent Loop)
```jac
walker task_manager {
  has utterance: str = "";
  has cur_task: TaskPartition = None;

  def route_to_node(utterance: str) -> RoutingNodes by llm();
  def plan_tasks(main_task: str) -> list[TaskPartition] by llm();

  can execute with `root entry {
    # Step 1: Plan - decompose the user's request
    subtasks = self.plan_tasks(self.utterance);
    print("[Planned Subtasks]:", subtasks);

    # Step 2: Map agent types to node classes
    node_map = {
      RoutingNodes.TASK_HANDLING: TaskHandling,
      RoutingNodes.EMAIL_HANDLING: EmailHandling,
      RoutingNodes.GENERAL_CHAT: GeneralChat
    };

    # Step 3: Execute - route
    // ... (rest of the agent loop logic)
  }
}
```

### Node and Walker Definitions with Abilities

#### Profile Node
```jac
node Profile {
    has username: str = "";

    can update with update_profile entry;
    can get with get_profile entry;
    can follow with follow_request entry;
    can un_follow with un_follow_request entry;
}
```

#### Tweet Node
```jac
node Tweet {
    has content: str;
    has embedding: list;
    has created_at: str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S");

    can update with update_tweet exit;
    can delete with remove_tweet exit;
    can like_tweet with like_tweet entry;
    can remove_like with remove_like entry;
    can comment with comment_tweet entry;

    def get_info() -> TweetInfo;
    can get with load_feed entry;
}
```

#### Walker Examples
```jac
walker create_tweet(visit_profile) {
    has content: str;
    can tweet with Profile entry;
}
```
```jac
walker visit_profile {
    can visit_profile with `root entry;
}
```
```jac
walker load_feed(visit_profile) {
    has search_query: str = "";
    has results: list = [];
    can load with Profile entry;
}
```
```
