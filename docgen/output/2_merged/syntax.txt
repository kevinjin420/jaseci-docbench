# Core Syntax

## Core Syntax

Jac is a superset of Python, incorporating all Python features while adding capabilities for graph-based and AI-first programming. Jac and Python code can be freely mixed.

Statements end with a semicolon. Program execution begins in a `with entry { ... }` block.

### Comments

```jac
# Single line comment
#*
    Multi-line
    Comment
*#
```

### Variables and Assignment

```jac
x = 3;     # Variable assignment.
(add, mult) = learnMultiple(x, y);       # Function returns two values.
```

### Type Annotations

Explicit type annotations are supported:

```jac
has name: str;
def learnMultiple(x: int, y: int = 5) -> (int, int) { ... }
```

### F-strings

Values can be formatted with f-strings:

```jac
print(f"sum: {add} prod:{mult}");
```

### Control Flow

#### If/Elif/Else

All control blocks require brackets, but not parentheses.

```jac
if x < 5 {
    print("Doesn't run");
} elif x < 10 {
    print("Run");
} else {
    print("Also doesn't run");
}
```

#### Match Statements

Chains of if-else can be replaced with match statements.

```jac
match x {
    case 1:
        print("Exactly one");
    case int() if 10 <= x < 15:
        print("Within a range");
    case _:
        print("Everything else");
}
```

#### For Loops

Jac provides both indexed and range-based for loops.

```jac
for i = 10 to i <= 20 by i += 2 {
    print(f"element: {i}");
}

for x in ["a", "b", "c"] {
    print(f"element: {x}");
}
```

#### While Loops

```jac
a = 4;
while a != 1{
    a /= 2;
}
```

### Functions

Functions are defined with the `def` keyword and a control block. Jac supports default parameters and multiple return values.

```jac
def nextFunction {
    x = 3;
    y = 4;
    (add, mult) = learnMultiple(x, y);
    print(f"sum: {add} prod:{mult}");
    learnFlowControl();
}

def learnMultiple(x: int, y: int = 5) -> (int, int) {
    return (x + y, x * y); # Return two values.
}
```

#### Lambda Functions

Lambdas create anonymous functions.

```jac
add = lambda a: int, b: int -> int : a + b;
print(add(5, 3));
```

### Collections

#### Lists and Slicing

```jac
fruits = ["apple", "banana", "cherry"];
print(fruits[1]);  # banana
print(fruits[:1]); # [apple, banana]
print(fruits[-1]); # cherry
```

#### List Comprehensions

```jac
squares = [i ** 2 for i in range(5)];
print(squares);  # [0, 1, 4, 9, 16]

# With condition
evens = [i for i in range(10) if i % 2 == 0];
print(evens);  # [0, 2, 4, 6, 8]
```

#### Dictionaries

```jac
person = {
    "name": "Alice",
    "age": 25,
    "city": "Seattle"
};

# Access values by key
print(person["name"]);  # Alice
print(person["age"]);   # 25
```

#### Tuples

Tuples are immutable lists and can be unpacked.

```jac
point = (10,20);
print(point[0]);  # 10
print(point[1]);  # 20

# tuples can be unpacked with parentheses
(x, y) = point;
print(f"x={x}, y={y}");
```

### Classes and Objects

#### `class`

The `class` keyword follows default Python behavior; all members are static.

```jac
class Cat {
    has name: str = "Unnamed";
    def meow {
        print(f"{self.name} says meow!");
    }
}

your_cat = Cat();
my_cat = Cat();
my_cat.name = "Shrodinger";

my_cat.meow();   # Shrodinger says meow!
your_cat.meow(); # Shrodinger says meow!
```

#### `obj`

The `obj` keyword follows the behavior of Python dataclasses; all members are per-instance.

```jac
obj Dog {
    has name: str = "Unnamed";
    has age: int = 0;

    def bark {
        print(f"{self.name} says Woof!");
    }
}
your_dog = Dog();
my_dog = Dog();
my_dog.name = "Buddy";
my_dog.age = 3;

your_dog.bark(); # Unnamed says Woof!
my_dog.bark();   # Buddy says Woof!
```

#### Inheritance

```jac
obj Puppy(Dog){
    has parent: str = 0;
    def bark { # override
        print(f"Child of {self.parent} says Woof!");
    }
}
```

### Object Spatial Programming (OSP)

Jac supports graph relationships within the type system.

#### Nodes

Nodes are `obj`s with special properties.

```jac
node Person {
    has name: str;
    has age: int;
}
```

#### Edges

Connection operators create edges between nodes. Edges can be typed.

```jac
a = Person(name="Alice",age=25);
b = Person(name="Bob",age=30);
c = Person(name="Charlie",age=28);

# connection operators create edges between nodes
a ++>  b; # forward a->b
b <++  c; # backward c->b
a <++> c; # bidirectional a <-> c

# edges can be typed, providing additional meaning
edge Friend {
    has since: int;
}

a +>:Friend(since=2020):+> b;
a +>:Friend(since=1995):+> c;
```

#### Edge and Node Queries

Edges and nodes can be queried with filters.

```jac
# returns all outgoing nodes with friend edges since 2018
old_friend_nodes = [node a ->:Friend:since > 2018:->];

# returns all outgoing friend edges since 2018
old_friend_edges = [edge a->:Friend:since > 2017:->];
```

#### Walkers

Walkers are objects that "walk" across nodes doing operations. They contain automatic methods called abilities that trigger on events.

```jac
walker Visitor {
    has name: str;

    # abilities follow can <name> with <type> <operation> syntax
    # runs when walker spawns at root
    can start with `root entry {
        print(f"Starting!");
        # visit moves to an adjacent node
        visit [-->]; # [-->] corresponds to outgoing connections
        # visit [<--]; incoming connections
        # visit [<-->]; all connections
    }

    # runs when walker visits any person
    can meet_person with Person entry {
        # here refers to current node
        # self refers to walker
        print(f"Visiting {here.name} with walker {self.name}");
        if here.name == "Joe" {
            print("Found Joe");
            disengage; # stop traversal immediately
        }

        # report returns a value without stopping exeuction
        # all reported values are accessed as a list after traversal
        report here.name;
        visit [-->];
    }

    # runs when walker is done
    can finish with exit {
        print("Ending!");
    }
}

# nodes can also have abilities
node FriendlyPerson(Person) {
    has name:str;
    can greet with Visitor entry{
        print(f"Welcome, visitor");
    }
}

f = FriendlyPerson(name="Joe",age=10);

# root is a special named node in all graphs
root ++> f ++> a;

# walker can then be spawned at a node in the graph
root spawn Visitor("Jim");
```

#### Spawning on Lists/Groups

```jac
# Example: Spawning a walker on a list of nodes
root spawn greeter;
```

### Walrus Operator

The walrus operator (`:=`) allows assignment within expressions.

```jac
result = (y := 20) + 10;
print(f"y = {y}, result = {result}");
```

### Asynchronous Programming (`async`, `await`, `flow`, `wait`)

`flow`/`wait` is Jac's equivalent to `async`/`await` for concurrency, executed in a thread pool.

```jac
def compute(x: int, y: int) -> int {
    print(f"Computing {x} + {y}");
    return x + y;
}

def slow_task(n: int) -> int {
    print(f"Task {n} started");
    time.sleep(1);
    print(f"Task {n} done");
    return n * 2;
}

task1 = flow slow_task(42);
task2 = flow compute(5, 10);
task3 = flow compute(3, 7);

result1 = wait task1;
result2 = wait task2;
result3 = wait task3;
print(f"Results: {result1}, {result2}, {result3}");
```

### Imports

#### Standard Imports

```jac
# Simple imports
import os;
import sys, json;
import time;

# Import with alias
import datetime as dt;

# Import from with specific items
import from math { sqrt, pi, log as logarithm }
```

#### Python Imports (`import:py`)

Used for Python interop.

```jac
import:py from json {dumps};
```

#### Client Imports (`cl import`)

For client-side (e.g., JavaScript) compatibility.

-   **Default imports** (`default as Name`) and **namespace imports** (`* as Name`) **MUST** use `cl` prefix.
-   **Named imports** work with or without `cl` prefix (but `cl` generates JavaScript).

```jac
# ✅ Correct Usage
cl import from react { useState }
cl import from react { default as React }
cl import from react { * as React }
cl import from react { default as React, useState }
```

#### String Literal Imports for Special Characters

For package names containing special characters (hyphens, @-scopes, etc.), use string literals.

```jac
# ✅ Correct Usage - String literals for hyphenated packages
cl import from "react-dom" { render }
cl import from "styled-components" { default as styled }
```

#### Relative Path Conversion

Jac uses Python-style dots for relative imports, which are automatically converted to JavaScript format.

| Jac Syntax | JavaScript Output | Description         |
| :--------- | :---------------- | :------------------ |
| `.utils`   | `"./utils"`       | Current directory   |
| `..lib`    | `"../lib"`        | Parent directory    |
| `...config`| `"../../config"`  | Grandparent directory |

### Standard Library Modules

#### `file`

Module: `file`

-   `open(path: str) -> File`

#### `os`

Module: `os`

#### `json`

Module: `json`

-   `dumps(obj: Any, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, cls: type = None, indent: int | str = None, separators: tuple[str, str] = None, default: Callable = None, sort_keys: bool = False) -> str`
-   `loads(s: str | bytes | bytearray, *, cls: type = None, object_hook: Callable = None, parse_float: Callable = None, parse_int: Callable = None, parse_constant: Callable = None, object_pairs_hook: Callable = None) -> Any`

#### `logging`

Module: `logging`

### Persistence

#### `save`

```jac
# Example: Saving a graph or object
save my_graph to "graph.json";
```

#### `load`

```jac
# Example: Loading a graph or object
my_graph = load "graph.json";
```

### Semantic Strings (`str "..."`)

```jac
str "This is a semantic string."
```

### Testing/Validation (`assert`)

```jac
assert x == 5;
```

### Agent Patterns (LLM Integration)

The `by llm()` keyword enables integration with Large Language Models. The Jaseci runtime automatically generates an optimized prompt, checks errors, and converts LLM output to the correct return type.

```jac
import from byllm.lib { Model }
glob llm = Model(model_name="gpt-4o");

enum Personality {
    INTROVERT,
    EXTROVERT,
    AMBIVERT
}

def get_personality(name: str) -> Personality by llm();

with entry {
    name = "Albert Einstein";
    result = get_personality(name);
    print(f"{result} detected for {name}");
}
```

#### Agent Loops

```jac
# Example of an agent loop using `by llm()`
walker MyAgent {
    can run_loop with `root entry {
        while True {
            response = get_llm_response() by llm();
            if response.should_stop {
                break;
            }
            process_response(response);
            visit [-->];
        }
    }
}
```

## Core Syntax

### Program Entry Point
Programs begin execution within a `with entry` block.
```jac
with entry {
    // Your code starts here
    print("Hello, World!");
}
```

### Comments
- Single-line comments start with `#`.
- Multi-line comments are enclosed in `/* ... */`.
```jac
# Single line comment
/*
   Multi-line
   comment
*/
```

### Statements and Blocks
- Statements end with a semicolon `;`.
- Code blocks are defined by curly braces `{}`.
```jac
x = 5;
if x > 0 {
    print("positive");
}
```

### Variables and Assignment
- Use `=` for assignment.
- Multiple assignment using tuples is supported.
```jac
x = 5;
(a, b) = (10, 20);
```

### Data Types
- Explicit type annotations are supported using `has x: type`.
```jac
obj Person {
    has name: str;
    has age: int;
}
```

### Operators
#### Arithmetic
- `+` (addition)
- `-` (subtraction)
- `*` (multiplication)
- `/` (division)
- `%` (modulo)
- `**` (exponentiation)

#### Assignment Shortcuts
- `x += y` (x = x + y)
- `x -= y` (x = x - y)
- `x *= y` (x = x * y)
- `x /= y` (x = x / y)

#### Comparison
- `==` (equality)
- `!=` (inequality)
- `>` (greater than)
- `<` (less than)
- `>=` (greater than or equal to)
- `<=` (less than or equal to)

### String Formatting
- F-strings (formatted string literals) are supported using `f"..."`.
- Semantic strings are denoted by `str "..."`.
```jac
name = "Alice";
age = 25;
message = f"Hello, {name}! You are {age} years old.";
print(str "This is a semantic string.");
```

### Control Flow
#### Conditional Statements
```jac
if n == 0 {
    return 1;
} else {
    return n * factorial(n-1);
}
```

#### Ternary Operator
```jac
result = "adult" if age >= 18 else "minor";
```

### Functions
Functions are defined using `def`. Type hints for parameters and return values are supported.
```jac
def factorial(n: int) -> int {
    if n == 0 { return 1; }
    else { return n * factorial(n-1); }
}
```

### Objects and Classes
Objects are defined using `obj`. They can have properties (`has`) and methods (`def`).
```jac
obj Person {
    has name: str;
    has age: int;

    def greet() -> None {
        print(f"Hello, my name is {self.name} and I'm {self.age} years old.");
    }
}
```

### Lists and Dictionaries
#### List Comprehension
```jac
squares = [x ** 2 for x in range(10)];
```

#### Dictionary Comprehension
```jac
square_dict = {x: x**2 for x in range(5)};
```

### Graph Operations
#### Node Definition
```jac
node Task {
    has name: str;
    has priority: int;
}
```

#### Spawning Nodes/Walkers
- `spawn` creates new instances.
- `here ++> task;` connects the current node to `task`.
```jac
walker TaskCreator {
    can create with `root entry {
        task = Task(title="Build API");
        here ++> task;
    }
}

with entry {
    root spawn TaskCreator();
}
```
- Spawning on lists/groups:
```jac
# Example: Spawning a walker on a list of nodes
nodes_to_process = [node1, node2, node3];
nodes_to_process spawn MyWalker();
```

#### Node Properties
- `.edges` provides access to a node's connected edges.
```jac
# Example: Iterating over edges of a node
for edge in my_node.edges {
    print(edge);
}
```

### Asynchronous Programming
- `async` and `await` keywords are used for asynchronous operations.
```jac
async def fetch_data(url: str) -> str {
    # ...
    data = await some_async_call(url);
    return data;
}
```

### Persistence
- `save` and `load` are used for object persistence.
```jac
my_object = MyClass();
save my_object to "my_object.jac_data";

loaded_object = load MyClass from "my_object.jac_data";
```

### Testing and Validation
- `assert` is used for testing and validation.
```jac
assert 5 == 5;
assert "hello" != "world", "Strings should not be equal";
```

### Agent Patterns
#### Agent Loop
Agents can run in a loop, often driven by an LLM.
```jac
walker MyAgent {
    has state: str = "initial";

    can run_loop with `entry {
        while state != "finished" by llm() {
            # Agent logic here
            print(f"Current state: {state}");
            state = "next_state"; // Update state based on LLM output
        }
        print("Agent finished.");
    }
}
```

## Interoperability

### Python Interoperability
Jac is a superset of Python, allowing seamless integration.

#### Importing Python Modules
- Use `import:py` for Python modules.
- Standard `import` syntax works for both Jac and Python modules after `import jaclang` is used in Python.
```jac
import:py from json {dumps};
import pandas as pd;
import numpy as np;
```

#### Inline Python
Embed Python code directly within `.jac` files using `::py::` blocks.
```jac
::py::
def validate_title(title):
    return len(title) > 3 and title.strip() != ""
::py::
```

## Standard Library

### `file` Module
Module: `file`
- `open(path: str) -> File`: Opens a file at the given path. Returns a `File` object.
- `read(file_obj: File) -> str`: Reads the entire content of the file object as a string.
- `write(file_obj: File, content: str) -> None`: Writes the given content to the file object.

### `os` Module
Module: `os`
- `getenv(key: str) -> str | None`: Returns the value of the environment variable `key`, or `None` if not found.
- `environ: dict[str, str]`: A dictionary representing the user's environment variables.

### `json` Module
Module: `json`
- `dumps(obj: Any, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, cls: type | None = None, indent: int | str | None = None, separators: tuple[str, str] | None = None, default: Callable | None = None, sort_keys: bool = False) -> str`: Serialize `obj` to a JSON formatted `str`.
- `loads(s: str, *, cls: type | None = None, object_hook: Callable | None = None, parse_float: Callable | None = None, parse_int: Callable | None = None, parse_constant: Callable | None = None, object_pairs_hook: Callable | None = None) -> Any`: Deserialize `s` (a `str`, `bytes` or `bytearray` instance containing a JSON document) to a Python object.

### `logging` Module
Module: `logging`
- `getLogger(name: str | None = None) -> Logger`: Return a logger with the specified name, creating it if necessary.
- `debug(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level `DEBUG` on the root logger.
- `info(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level `INFO` on the root logger.
- `warning(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level `WARNING` on the root logger.
- `error(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level `ERROR` on the root logger.
- `critical(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level `CRITICAL` on the root logger.
- `basicConfig(**kwargs: Any) -> None`: Configures the logging system. Common arguments include `level`, `format`, `filename`.

## Core Syntax

### Basic Structure
```jac
import time at t; # Import a module, optionally aliasing it

def example(){ # Function definition
    number = 1+2; # Variable assignment
    print(f"Calculated {number}"); # String interpolation
    t.sleep(2); # Function call
    if number < 4 { # Conditional statement
        print("Small number");
    }
}

# jac's equivalent of main
with entry { # Entry point for execution
    print("Hello world!");
    example();
}
```

### Object-Oriented Programming

#### Nodes
Nodes are fundamental entities in Jac, representing data and behavior.
```jac
node Person {
    has name: str; # Property with type annotation
    has age: int;

    def greet -> str { # Method definition with return type
        return f"Hello, I'm {self.name}!"; # 'self' refers to the current instance
    }

    def celebrate_birthday {
        self.age += 1;
        print(f"{self.name} is now {self.age}!");
    }
}

with entry {
    alice = Person(name="Alice", age=25); # Node instantiation
    bob = Person(name="Bob", age=30);
    print(alice.greet());  # Method call
}
```

#### Inheritance
Nodes can inherit properties and methods from other nodes.
```jac
node Entity {
    has id: str;
    has created: str;
}

node Person(Entity) { # Person inherits from Entity
    has email: str;
    def notify(msg: str) {
        print(f"To {self.email}: {msg}");
    }
}

# Person inherits from Entity, gets id/created fields
# plus its own email field and notify method
```

### Graph Operations

#### Edge Creation
Edges define relationships between nodes.
```jac
alice ++> bob;      # Alice → Bob (forward relationship)
alice <++ bob;      # Bob → Alice (backward)
alice <++> bob;     # Alice ↔ Bob (bidirectional)
```

#### Custom Edges
Edges can also have properties and methods.
```jac
node Person { has name: str; }

edge Friend {
    has since: int;
    has strength: int = 5; # Default value

    def is_strong -> bool {
        return self.strength >= 7;
    }
}

with entry {
    # Create a Friend edge with properties
    alice +>:Friend(since=2015, strength=9):+> bob;

    # Query all Friend relationships from alice
    friends = [alice ->:Friend:->];
    print(f"Alice has {len(friends)} friend(s)");
}
```

#### Graph Traversal / Queries
```jac
# All outgoing connections (any type)
all_out = [alice -->];

# Only Friend edges
type_out = [alice ->:Friend:->];

# Friend edges filtered by property
filtered = [alice ->:Friend:since < 2018:->];

# Each query returns a list of connected nodes, ready to use
```

### Walkers (Agents)

Walkers are autonomous agents that traverse the graph.

#### Walker Definition
```jac
walker Greeter {
    has greeting_count: int = 0; # Walker state

    can start with `root entry { # Entry point for the walker
        print("Starting journey!");
        visit [-->];  # Begin traversal from root's outgoing edges
    }

    can greet with Person entry { # Executes when visiting a Person node
        print(f"Hello, {here.name}!");  # 'here' refers to the current node
        self.greeting_count += 1;
        visit [-->];  # Continue traversal
    }
}

with entry {
    alice = Person(name="Alice");
    bob = Person(name="Bob");

    root ++> alice ++> bob;
    root spawn Greeter();  # Launch walker, it navigates autonomously
}
```

#### Walker State and Accumulation
```jac
walker DataCollector {
    has counter: int = 0;          # Walker state, persists across visits
    has visited_names: list = [];  # Accumulates data during traversal

    can collect with NodeType entry {  # Executes when visiting NodeType
        self.visited_names.append(here.name);
        self.counter += 1;
        visit [-->];  # Default: depth-first traversal
    }
}
```
```jac
walker AgeCollector {
    has ages: list = [];

    can collect with Person entry {
        self.ages.append(here.age);  # Accumulate in walker state
        visit [-->];
    }
}

# After execution: walker.ages contains [25, 30, 28]
```

#### Traversal Control
```jac
walker Explorer {
    can explore with Person entry {
        # Visit all outgoing connections (depth-first)
        visit [-->];

        # Visit only Friend edges
        visit [->:Friend:->];

        # Friend edges with strength > 5
        visit [->:Friend:strength > 5:->];
    }
}
```
```jac
walker FindPerson {
    has target: str;
    has found: bool = False;

    can search with Person entry {
        if here.name == self.target {
            self.found = True;
            disengage;  # Stop immediately, don't visit further
        }
        visit [-->];  # Keep searching if not found
    }
}
```
```jac
# Visit immediate neighbors
visit [-->];

# Visit only via Friend edges
visit [->:Friend:->];

# Visit via Friend edges from before 2020
visit [->:Friend:since < 2020:->];

# Multi-hop: friends of friends
visit [here ->:Friend:-> ->:Friend:->];
```

#### Reporting Results
```jac
walker FindFirstMatch {
    can search with Person entry {
        if here.name == self.target {
            report here;  # Send back the node
            disengage;    # Stop traversing immediately
        }
        visit [-->];
    }
}
```

#### Multiple `can` Blocks
Walkers can have multiple `can` blocks to handle different node types.
```jac
walker Tourist {
    can meet_person with Person entry {
        print(f"Met {here.name}, age {here.age}");
        visit [-->];
    }

    can visit_city with City entry {
        print(f"Visiting {here.name}, pop {here.population}");
        visit [-->];
    }
}
```

#### Node `can` Blocks
Nodes can also define `can` blocks to react to walker visits.
```jac
node Person {
    has name: str;

    can receive_greeting with Greeter entry {
        print(f"{self.name} acknowledges greeting");
    }
}
```
When both a walker and a node have `can` blocks for the same entry, the node's `can` block executes first.
```jac
node Person {
    can greet_visitor with Visitor entry {
        print(f"{self.name} says: Welcome!");  # Executes first
    }
}

walker Visitor {
    can meet_person with Person entry {
        print(f"Visitor says: Hello, {here.name}!");  # Executes second
        visit [-->];
    }
}
```

#### Agent Loops
```jac
node Task {
    has title: str;
    has status: str = "pending";
}

edge DependsOn {}

walker TaskAnalyzer {
    has ready_tasks: list = [];

    can analyze with Task entry {
        if here.status != "pending": return;

        # Get all dependencies
        deps = [here ->:DependsOn:->];

        # Check if all complete
        all_done = all(dep.status == "complete" for dep in deps);

        if all_done {
            self.ready_tasks.append(here.title);
        }

        visit [-->];  # Continue to next task
    }
}

# Usage: spawn analyzer, then check analyzer.ready_tasks
```

## Standard Library

### File I/O
Module: `file`
- `open(path: str) -> File`
- `read(file_object: File) -> str`
- `write(file_object: File, content: str)`

### OS Module
Module: `os`
- `getenv(key: str) -> str | None`
- `environ: dict` (Environment variables)

### JSON Module
Module: `json`
- `dumps(obj: any) -> str` (Serialize Python object to JSON string)
- `loads(json_string: str) -> any` (Deserialize JSON string to Python object)

### Logging Module
Module: `logging`
- `getLogger(name: str) -> Logger`
- `Logger.debug(msg: str)`
- `Logger.info(msg: str)`
- `Logger.warning(msg: str)`
- `Logger.error(msg: str)`
- `Logger.critical(msg: str)`

## Client-Side (JSX)

Jac supports client-side development using a JSX-like syntax. Client-side code is prefixed with `cl`.

### Client-Side Declarations
```jac
// Client function - executes in browser, can return JSX
cl def homepage() -> dict {
    return <div>
        <h1>Welcome</h1>
        <button onclick={load_feed()}>Load Feed</button>
    </div>;
}

// Client object - available on both client and server
cl obj ButtonProps {
    has label: str = "Hello";
    has count: int = 0;
}

// Client global - literal value sent to browser
cl let API_BASE_URL: str = "https://api.example.com";
```

### JSX Syntax
```jac
cl def render_example() {
    // Basic elements
    let basic = <div>Hello World</div>;

    // Elements with attributes
    let with_attrs = <button id="submit" class="btn">Click</button>;

    // Expression attributes and children
    let name = "Alice";
    let greeting = <h1 data-user={name}>Welcome, {name}!</h1>;

    // Spread attributes
    let props = {"class": "card", "id": "main"};
    let with_spread = <div {...props}>Content</div>;

    // Fragment syntax
    let fragment = <>
        <div>First</div>
        <div>Second</div>
    </>;

    // Component usage (capitalized names)
    let component = <Button label="Click Me" />;

    return <div>{greeting}{component}</div>;
}
```

### Client-Side Runtime Imports
```jac
cl import from jac:client_runtime {
    renderJsxTree,
    jacLogin,
    jacLogout,
    jacSignup,
    jacIsLoggedIn,
    createSignal,
    createState,
    createRouter,
    Route,
    Link,
    navigate,
    createEffect
}
```

### Reactive Primitives

#### `createSignal`
For simple, reactive values.
```jac
cl def Counter() {
    [count, setCount] = createSignal(0);

    def increment() {
        setCount(count() + 1);  // Read with (), set by calling setter
    }

    return <div>
        <p>Count: {count()}</p>
        <button onclick={increment}>Increment</button>
    </div>;
}
```

#### `createState`
For more complex, object-based reactive state.
```jac
cl def TodoList() {
    [state, setState] = createState({
        "todos": [],
        "filter": "all"
    });

    def addTodo(text: str) {
        todos = state().todos;
        todos.push({"text": text, "done": False});
        setState({"todos": todos});  // Shallow merge with existing state
    }

    return <div>
        <ul>
            {[<li>{todo.text}</li> for todo in state().todos]}
        </ul>
    </div>;
}
```

#### `createEffect`
To run side effects when reactive dependencies change.
```jac
cl def DataFetcher() {
    [userId, setUserId] = createSignal(1);
    [userData, setUserData] = createSignal(None);

    createEffect(lambda -> None {
        id = userId();  // Track dependency!
        console.log("Fetching user", id);
        # In real app, would fetch from API
        setUserData({"id": id, "name": "User " + str(id)});
    });

    return <div>
        <button onclick={lambda: setUserId(userId() + 1)}>Next User</button>
        <p>Current: {userData() and userData().name or "Loading..."}</p>
    </div>;
}
```

### Routing

#### `createRouter` and `Route`
```jac
cl def App() {
    routes = [
        Route("/", HomePage),
        Route("/about", AboutPage),
        Route("/profile", ProfilePage, guard=jacIsLoggedIn) # Guard for access control
    ];

    router = createRouter(routes, defaultRoute="/");

    return <div>
        <nav>
            <Link href="/">Home</Link>
            <Link href="/about">About</Link>
            <Link href="/profile">Profile</Link>
        </nav>
        <main>{router.render()}</main>
    </div>;
}
```

#### `Link` Component
```jac
<Link href="/about">About Page</Link>

# Equivalent to:
<a href="#/about" onclick={handleClick}>About Page</a>
```

#### `navigate` Function
```jac
cl def LoginForm() {
    def handleSubmit() {
        # After successful login
        navigate("/dashboard");
    }

    return <form onsubmit={handleSubmit}>...</form>;
}
```

#### Route Guards
```jac
cl def AccessDenied() {
    return <div>
        <h1>Access Denied</h1>
        <button onclick={lambda: navigate("/login")}>Login</button>
    </div>;
}

Route("/admin", AdminPanel, guard=jacIsLoggedIn)
```

## Miscellaneous

### Python Interop
- `import:py` for importing Python modules.

### Spawning
- `spawn` for launching walkers on nodes or groups of nodes.
```jac
root spawn Greeter();
```

### Type Annotations
- `has x: type` for explicit type annotations on properties and parameters.
```jac
has name: str;
def notify(msg: str);
```

### Reference Operator
- `&` (Reference operator)

### Node Property
- `.edges` (Node property to access connected edges)

### Semantic String
- `str "..."` (Semantic String)

### Asynchronous Operations
- `async`, `await` (Keywords for asynchronous programming)

### Assertions
- `assert` (For testing and validation)

### Persistence
- `save`, `load` (For saving and loading graph data)

## Core Syntax

### Node and Edge Declaration
```jac
node Person {
    has name: str;
    has age: int;
    has interests: list[str] = [];
    has visited: bool = False; # Default value
}

edge FriendsWith {
    has since: str;
    has closeness: int; # 1-10 scale
}
```

### Node and Edge Creation
- `++>`: Creates a new node and connects it.
- `<+:EdgeType(attributes):+>`: Creates a bidirectional edge.
- `+>:EdgeType(attributes):+>`: Creates a bidirectional edge.
- `+>:EdgeType(attributes):+>`: Creates a bidirectional edge.

```jac
# Create nodes
alice = root ++> Person(name="Alice", age=25, interests=["coding", "music"]);
bob = root ++> Person(name="Bob", age=27, interests=["music", "sports"]);

# Create relationships
alice <+:FriendsWith(since="2020-01-15", closeness=8):+> bob;
parent +>:FamilyRelation(relationship_type="parent"):+> child1;
```

### Node and Edge Properties
- `.edges`: Access edges connected to a node.
- `has x: type`: Explicit type annotation for properties.

```jac
node User {
    has username: str;
    has email: str;
}
```

### Graph Traversal and Filtering
- `-->`: Follows outgoing edges.
- `<--`: Follows incoming edges.
- `[-->]`: Collects all outgoing neighbors.
- `[<--]`: Collects all incoming neighbors.

#### Filtering by Node Type
- `(-->(`?NodeType)`: Traverses to nodes of a specific type.

```jac
# Example: Visit all Student nodes connected to the root
walker FindStudents {
    can start with `root entry {
        visit [-->(`?Student)];
    }
}
```

#### Filtering by Node Attributes
- `(-->(`?NodeType: attr1 op value1, ...)`: Traverses to nodes matching attribute conditions.

| Operator   | Description                    | Example                             |
|------------|--------------------------------|-------------------------------------|
| `==`       | Equality                       | `grade == 90`                        |
| `!=`       | Inequality                     | `status != "inactive"`              |
| `<`        | Less than                      | `age < 18`                           |
| `>`        | Greater than                   | `score > 70`                         |
| `<=`       | Less than or equal to          | `temp <= 100`                       |
| `>=`       | Greater than or equal to       | `hour >= 12`                        |
| `is`       | Identity comparison            | `mood is "happy"`                   |
| `is not`   | Negative identity comparison   | `type is not "admin"`              |
| `in`       | Membership (value in list)     | `role in ["student", "teacher"]`    |
| `not in`   | Negative membership            | `status not in ["inactive", "banned"]` |

```jac
# Find all students with a grade above 85
walker FindTopStudents {
    can start with `root entry {
        visit [-->(`?Student: grade > 85)];
    }
}
```

#### Filtering by Edge Type and Attributes
- `[->:EdgeType->]`: Traverses only edges of a specific type.
- `[->:EdgeType: attr1 op val1, ...:->]`: Traverses edges matching attribute conditions.

```jac
# Only follow "enrolled_in" edges
visit [->:enrolled_in->];

# Follow "graded" edges where score is above 80
visit [->:graded: score > 80:->];
```

### Walkers
Walkers are agents that traverse the graph.
- `walker WalkerName { ... }`: Declares a walker.
- `can ability_name with NodeType entry { ... }`: Defines an ability that runs when the walker lands on a `NodeType`.
- `spawn`: Initiates a walker on a node or list of nodes.

```jac
walker GreetFriends {
    can greet with Person entry {
        if not here.visited {
            here.visited = True;
            print(f"Hello, {here.name}!");
            visit [->:FriendsWith:->];
        }
    }
}

with entry {
    alice[0] spawn GreetFriends();
}
```

### Functions and Methods
- `def function_name(parameters) -> return_type { ... }`: Function declaration.
- `impl NodeType.method_name { ... }`: Implementation of a method for a node type.

```jac
def calculate_average(numbers: list[float]) -> float {
    if len(numbers) == 0 {
        return 0.0;
    }
    return sum(numbers) / len(numbers);
}

node Counter {
    has count: int = 0;
    def increment() -> None;
}

impl Counter.increment {
    self.count += 1;
    print(f"Counter is now: {self.count}");
}
```

### Lambda Functions
- `lambda parameters: return_type: expression`: Anonymous function.

```jac
add = lambda x: float, y: float: x + y;
```

### Decorators
- `@decorator_name`: Applies a decorator to a function.

```jac
@decorator_name
def function_name(parameters) -> return_type {
    # function body
}
```

### Control Flow
- `if`, `elif`, `else`: Conditional statements.
- `for ... in ...`: Iteration.
- `while`: Loop.

```jac
if avg >= 90.0 {
    print("Excellent performance!");
} elif avg >= 80.0 {
    print("Good performance!");
} else {
    print("Needs improvement.");
}

for child in children {
    print(f"  - {child.name} (age {child.age})");
}

while True by llm() {
    # Agent loop
}
```

### Type Annotations
- `variable: type`: Explicit type annotation.

```jac
a: float = 10.0;
```

### Semantic Strings
- `str "..."`: Declares a semantic string.
- `sem MyObject.value is "A value stored in MyObject"`: Alternative syntax for semantic string declaration.

### Imports
- `import:py from module {item}`: Imports Python modules/items.

```jac
import:py from json {dumps};
```

### Standard Library Modules

#### `file` Module
- `file.open(path: str) -> File`: Opens a file.
- `file.read(file_obj: File) -> str`: Reads content from a file.
- `file.write(file_obj: File, content: str) -> None`: Writes content to a file.

#### `os` Module
- `os.getenv(key: str) -> str | None`: Gets an environment variable.
- `os.environ: dict[str, str]`: Dictionary of environment variables.

#### `json` Module
- `json.dumps(obj: Any, indent: int = 2) -> str`: Serializes a Python object to a JSON formatted string.
- `json.loads(s: str) -> Any`: Deserializes a JSON formatted string to a Python object.

#### `logging` Module
- `logging.debug(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level DEBUG.
- `logging.info(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level INFO.
- `logging.warning(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level WARNING.
- `logging.error(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level ERROR.
- `logging.critical(msg: str, *args: Any, **kwargs: Any) -> None`: Logs a message with level CRITICAL.

### Persistence
- `save`: Saves the current graph state.
- `load`: Loads a graph state.

### Testing and Validation
- `assert condition, message: str`: Asserts a condition is true, optionally with a message.

### Server
- `jac serve filename.jac`: Runs a Jac file as a server.

### Miscellaneous
- `&`: Reference operator (e.g., `&my_variable`).
- `with entry { ... }`: The entry point for program execution.
- `here`: Refers to the current node a walker is on.
- `root`: The root node of the graph.
- `obj`: Keyword for object declaration (replaces `class`).
- `;`: Statement terminator.
- `{}`: Code block delimiter (replaces indentation).

## Core Syntax

### Type Annotations
Jac enforces type annotations for all collections and variables, ensuring type safety and clarity.
```jac
x: int = 5;
grades: list[int] = [88, 92, 85];
```

### Entry Point
Executable scripts require an `entry` block.
```jac
with entry {
    // Your code here
}
```

### Control Flow

#### Conditional Statements
`if`, `elif`, and `else` statements are used for conditional execution, using curly braces `{}` to group code blocks.
```jac
if condition {
    // code if condition is true
} elif another_condition {
    // code if another_condition is true
} else {
    // code if no condition is true
}
```

#### Loops

##### `for-to-by` Loop
A special loop for iterating within a specific range with a defined step.
```jac
for i: int = 0 to 10 by 2 {
    print(i); // Prints 0, 2, 4, 6, 8, 10
}
```

##### List Comprehension
Similar to Python's list comprehension.
```jac
[expression for item in iterable if condition]
```
- `expression`: Value to include in the new list.
- `item`: Variable representing each element in the original collection.
- `iterable`: The collection being processed.
- `condition`: Optional filter.

#### Pattern Matching (`match`)
Provides a cleaner way to handle complex conditional logic based on variable types or values.
```jac
def process_grade_input(input: any) -> str {
    match input {
        case int() if 90 <= input <= 100:
            return f"Excellent work! Score: {input}";
        case int() if 80 <= input < 90:
            return f"Good job! Score: {input}";
        case int() if 70 <= input < 80:
            return f"Satisfactory. Score: {input}";
        case int() if 0 <= input < 70:
            return f"Needs improvement. Score: {input}";
        case str() if input in ["A", "B", "C", "D", "F"]:
            return f"Letter grade received: {input}";
        case list() if len(input) > 0:
            avg = sum(input) / len(input);
            return f"Average of {len(input)} grades: {avg}";
        case _: // Catch-all case
            return "Invalid grade input";
    }
}

with entry {
    print(process_grade_input(95));
    print(process_grade_input("A"));
    print(process_grade_input([88, 92, 85]));
}
```

### Functions and Methods

#### Function Definition (`def`)
Use `def` for traditional functions and methods.
```jac
def add(x: int, y: int) -> int {
    return x + y;
}

node Person {
    has name: str;
    def get_name -> str {
        return self.name;
    }
}
```

#### Abilities (`can`)
`can` statements are used for object-spatial abilities.
```jac
node Person {
    can greet with speak_to entry {
        return "Hello " + visitor.name + ", my name is " + self.name;
    }
}
```

#### Method Implementation (`impl`)
The `impl` keyword provides a way to implement abilities and methods for objects, nodes, and edges.
```jac
impl Circle.area -> float {
    return math.pi * self.radius * self.radius;
}

impl Person.greet with Room entry {
    return "Hello, I am " + self.name;
}

impl calculate_distance(x: float, y: float) -> float {
    return math.sqrt(x*x + y*y);
}
```

#### Lambda Functions
Anonymous functions using `lambda`.
```jac
with entry {
    square_func = lambda x: int: x * x;
    print(square_func(5)); // Prints 25
}
```

### Object-Oriented Programming

#### Inheritance
Inheritance uses parentheses `()` to specify base classes.
```jac
obj Vehicle {
    has wheels: int;
}

obj Car(Vehicle) {
    has doors: int = 4;
}

node BaseUser {
    has username: str;
}

node AdminUser(BaseUser) {
    has is_admin: bool = true;
}
```

### Error Handling (`try...except`)
Use `try...except` blocks to manage potential errors. The `raise` keyword can be used to create custom errors.
```jac
def safe_calculate_gpa(grades: list[int]) -> float {
    try {
        if len(grades) == 0 {
            raise ValueError("No grades provided");
        }
        total = sum(grades);
        return total / len(grades);
    } except ValueError as e {
        print(f"Error: {e}");
        return 0.0;
    }
}

def validate_grade(grade: int) -> None {
    if grade < 0 or grade > 100 {
        raise ValueError(f"Grade {grade} is out of valid range (0-100)");
    }
}

with entry {
    valid_grades: list[int] = [85, 90, 78];
    gpa: float = safe_calculate_gpa(valid_grades);
    print(f"The calculated GPA is: {gpa}");

    try {
        validate_grade(150);
    } except ValueError as e {
        print(f"A validation error occurred: {e}");
    }
}
```

### Testing and Validation (`assert`)
The `assert` keyword is used for testing and validation. In `test` blocks, it reports failures; outside, it raises `AssertionError`.
```jac
glob a: int = 5;
glob b: int = 2;

test test_equality {
    assert a == 5;
    assert b == 2, "b should be 2";
}

test test_comparison {
    assert a > b;
    assert a - b == 3;
}
```

### Imports

#### General Imports
The compiler automatically resolves imports based on context and file extensions.
```jac
import requests;
import graph_utils;
import json, os, sys;
```

#### Specific Imports from a Module
Use curly braces `{}` to import specific components from a module.
```jac
import from pygame_mock { color, display };
import from utils { helper, math_utils, string_formatter };
```

#### Python Imports (`import:py`)
Explicitly import Python modules.
```jac
import:py from json {dumps};
```

### Standard Library Modules

#### `file` Module
Provides file I/O operations.
- `open(path: str) -> File`: Opens a file at the given path.
- `read(file: File) -> str`: Reads the entire content of a file.
- `write(file: File, content: str) -> None`: Writes content to a file.

#### `os` Module
Provides operating system-dependent functionality.

#### `json` Module
Provides JSON encoding and decoding.
- `dumps(obj: any) -> str`: Serializes a Python object to a JSON formatted string.
- `loads(s: str) -> any`: Deserializes a JSON formatted string to a Python object.

#### `logging` Module
Provides a flexible event logging system.

### Persistence (`save`, `load`)
Used for saving and loading data.
```jac
save data_object to "path/to/file.jac";
loaded_data = load "path/to/file.jac";
```

### Reference Operator (`&`)
Used to get a reference to a variable or object.
```jac
x: int = 10;
ref_x: &int = &x;
```

### Semantic String (`str "..."`)
Used to define semantic strings, which can carry additional metadata or meaning.
```jac
my_semantic_string: str "greeting" = "Hello, World!";
```

### Asynchronous Programming (`async`, `await`)
Jac supports asynchronous operations.
```jac
async def fetch_data(url: str) -> str {
    // ...
}

async def main() {
    data = await fetch_data("http://example.com");
    print(data);
}
```

### Graph Operations

#### Node Properties (`.edges`)
Access edges connected to a node.
```jac
node_instance.edges
```

#### Spawning
Creating new nodes or edges.
```jac
spawn node MyNode; // Spawning a single node
spawn node MyNode on list_of_nodes; // Spawning on a list of nodes
spawn edge MyEdge from node_a to node_b; // Spawning an edge
```

#### Data Spatial Arrow Notation
Used for creating and referencing edges.
- `->:MyEdge:->`: Reference an edge.
- `<+:MyEdge:attr=value:<+`: Create an edge with attributes.
```jac
friends = [->:Friendship:->];
alice <+:Friendship:strength=0.9:<+ bob;
```

### Agent Patterns
Agent loops typically use a `while` loop with `by llm()`.
```jac
agent MyAgent {
    has state: str = "initial";

    with entry {
        while state != "finished" by llm() {
            // Agent logic here
            // Update state based on LLM output
        }
    }
}
```

### Global and Nonlocal Variables
Use `global` and `nonlocal` keywords to modify variables in enclosing scopes.
```jac
glob x = "Jaclang ";

def outer_func -> None {
    global x;
    x = 'Jaclang is ';
    y = 'Awesome';
    def inner_func -> tuple[str, str] {
        nonlocal y;
        y = "Fantastic";
        return (x, y);
    }
    print(x, y);
    print(inner_func());
}

with entry {
    outer_func();
}
```

### Comments
Jac supports single-line and multi-line comments.
```jac
// This is a single-line comment
# This is also a single-line comment

/*
    This is a
    multi-line comment.
*/
```

## Core Syntax

### Declarations

#### Object/Node/Edge
```jac
obj Person {
    has name: str;
    has email: str;
}

node EmailNode {
    has sender: str;
    has recipients: str;
    has date: str;
    has subject: str;
    has body: str;
    has email_uuid: str;
}

obj Position {
    has x: int, y: int;
}
```

#### Global Variables
```jac
glob llm = Model(model_name="gpt-3.5-turbo");
```

#### Functions
- `def` keyword for traditional Python-like functions and methods.
- `can` keyword for object-spatial abilities.
```jac
def get_map(map: Map) -> str {
    // ...
}

can test_plugin {
    result = get_answer("What is 2+2?") by llm();
    print(result);
}
```

#### Abilities
- Ability declarations now support optional names.
```jac
can with entry {
    // ...
}
```

#### Implementations
- `impl` keyword for implementing abilities and methods.
```jac
impl MyObject {
    can my_ability {
        // ...
    }
}
```

### Type Annotations
- Explicit type annotations: `has x: type`
```jac
has name: str;
```

### Inheritance
- Parentheses for inheritance: `obj Car(Vehicle)`
```jac
obj Car(Vehicle)
```

### Imports
- `import:py` for Python interop.
- `import from` syntax uses curly braces for specific modules.
- Compiler automatically resolves imports without explicit language annotations (`:py`, `:jac`).
```jac
import:py from json {dumps};
import from byllm.lib { Model };
```

### Control Flow

#### For Loops
- `for` statement supports iteration.
```jac
for node in recipientNodes {
    // ...
}
```

#### Switch Case
- `switch` statement with JavaScript-style fallthrough.
```jac
switch my_var {
    case 1:
        // ...
    case 2:
        // ...
        break;
    default:
        // ...
}
```

#### Match Case
- Attribute patterns supported in `match case`.
```jac
match my_object {
    case a.b.c:
        // ...
}
```

### String Literals
- Formatted String Literals (f-strings) with full Python-style feature parity.
- Triple-quoted f-strings for multi-line.
- Unicode characters are properly preserved.
```jac
name = "World";
message = f"Hello, {name}!";
multi_line_message = f"""
    Hello,
    {name}!
""";
```

### Lambda Functions
- Updated syntax: `lambda x: int: x * x;`
```jac
my_lambda = lambda x: int: x * x;
```

### Object-Spatial Operations

#### Node and Edge Creation
```jac
node Person{
    has name: str;
}
node Email;

senderNode = Person(name="Alice");
emailNode = Email();
```

#### Edge Creation
- `++>` for outgoing edges.
```jac
senderNode ++> emailNode;
```

#### Object-Spatial Arrow Notation
- Typed arrow notations: `->:MyEdge:->` and `+>:MyEdge:+>`
```jac
node_a ->:MyEdge:-> node_b;
node_c +>:MyOtherEdge:+> node_d;
```

#### Walker Definition
```jac
walker FindSenderNode {
    has target: str;
    has person: Person = None;

    can start with `root entry {
        visit [-->];
        return self.person;
    }

    can search with Person entry {
        if here.email == self.target {
            self.person = here;
            disengage;
        }
    }
}
```
- `has <memberVariable>: <type>`: Create member variables for walker.
- `can <attributeName> with <nodeType> entry`: Assigns walker behavior when it is on the node type (root must have `` `root ``).
- `disengage`: Stops the walker immediately.
- `visit [-->]`: Explores all nodes reachable from this one along outgoing edges.
- `.edges`: Node property to access edges.

#### Spawning Walkers
- `spawn` for initiating walker traversal.
```jac
root spawn FindSend;
```

### Asynchronous Programming
- `async`, `await` keywords for asynchronous operations.
```jac
async def fetch_data():
    data = await some_async_call();
    return data;
```

### Testing and Validation
- `assert` statements for testing and validation.
- In regular code, `assert` raises `AssertionError`.
- Within `test` blocks, `assert` integrates with the testing framework.
```jac
assert 2 + 2 == 4, "Math is broken!";
```

### Persistence
- `save`, `load` for persistence operations.
```jac
save my_object to "data.jac";
loaded_object = load "data.jac";
```

### Standard Library

#### `file` Module
- `file.open(path: str) -> File`
```jac
file.open("my_file.txt");
```
- `read()`
- `write()`

#### `os` Module
(No specific functions provided in input, but `os` is a protected module.)

#### `json` Module
- `dumps(obj: Any) -> str`
- `loads(s: str) -> Any`
```jac
import:py from json {dumps, loads};

my_dict = {"key": "value"};
json_string = dumps(my_dict);
parsed_dict = loads(json_string);
```

#### `logging` Module
(No specific functions provided in input, but `logging` is a protected module.)

### Agent Patterns

#### `by llm()`
- The `by llm()` syntax triggers registered plugins that implement the `call_llm` hook.
```jac
can get_answer(question: str) -> str by llm();

def summarize(presented_option: list[str], convo_history: list[dict]) -> str by llm();

def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
-> Level by llm();
```

#### Agent Loops
- Example of an agent loop using `by llm()`.
```jac
with entry {
    level_manager = LevelManager();

    print("Generating 3 AI-powered levels...\n");

    for i in range(3) {
        level, map_obj = level_manager.get_next_level();
        // ...
    }
}
```

### Semantic Strings
- `str "..."` for semantic annotations.
```jac
sem Response = "Structured response used by an agentic traversal logic.";
sem Response.option = "A control token defining action: @selected@, @query@, or @end@.";
```

### Python Interoperability
- Complete Python function parameter syntax support, including positional-only (`/`), keyword-only (`*`), and complex combinations.
```jac
def foo(a, b, /, *, c, d=1, **kwargs):
    // ...
```

### JavaScript Export Semantics
- Declarations annotated with `:pub` generate JavaScript `export` statements.
```jac
obj MyClass :pub {
    // ...
}
def my_function :pub {
    // ...
}
```