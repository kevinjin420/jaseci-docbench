# Collections and Data Structures

# Collections and Data Structures

## Lists

Ordered, mutable collections of items.

```jac
# Create a list
fruits = ["apple", "banana", "cherry"];
print(fruits);  # ['apple', 'banana', 'cherry']

# Access items by index (0-based)
print(fruits[0]);   # apple
print(fruits[-1]);  # cherry (last item)

# Modify an item
fruits[1] = "blueberry";
print(fruits);  # ["apple", "blueberry", "cherry"]

# Add to end
fruits.append("date");
print(fruits);  # ["apple", "blueberry", "cherry", "date"]

# Insert at specific position
fruits.insert(0, "apricot"); # Insert "apricot" at index 0
print(fruits);  # ["apricot", "apple", "blueberry", "cherry", "date"]

# Remove by value
fruits.remove("blueberry");
print(fruits);  # ["apricot", "apple", "cherry", "date"]

# Remove by index
fruits.pop(0); # Remove first item
print(fruits);  # ["apple", "cherry", "date"]

# Length
print(len(fruits));  # 3

# Concatenation
more_fruits = fruits + ["grape", "kiwi"];
print(more_fruits);  # ["apple", "cherry", "date", "grape", "kiwi"]

# Repetition
repeated_zeros = [0] * 3;
print(repeated_zeros);  # [0, 0, 0]

# Membership
if "apple" in fruits {
    print("Apple is in the list!");
}

# Looping through items
for fruit in fruits {
    print(f"I like {fruit}");
}

# Looping with index
for i = 0 to i < len(fruits) by i += 1 {
    print(f"{i}: {fruits[i]}");
}
```

### List Slicing

Extract a portion of a list.

```jac
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

# [start:end] - start is included, end is excluded
print(numbers[2:5]);   # [2, 3, 4]

# [:end] - from beginning to end (exclusive)
print(numbers[:3]);    # [0, 1, 2]

# [start:] - from start to end of list
print(numbers[7:]);    # [7, 8, 9]

# [start:end:step] - with step size
print(numbers[0:9:2]); # [0, 2, 4, 6, 8]
```

### List Comprehensions

Concise way to create lists.

```jac
# Basic list comprehension
squares = [i ** 2 for i in range(5)];
print(squares);  # [0, 1, 4, 9, 16]

# With condition
evens = [i for i in range(10) if i % 2 == 0];
print(evens);  # [0, 2, 4, 6, 8]
```

## Dictionaries

Unordered collections of key-value pairs. Keys must be unique and immutable.

```jac
# Create a dictionary
person = {
    "name": "Alice",
    "age": 25,
    "city": "Seattle"
};

# Access values by key
print(person["name"]);  # Alice
print(person["age"]);   # 25

# Add or modify a key-value pair
person["job"] = "Engineer";
person["age"] = 26; # Modifies existing value

print(person); # {"name": "Alice", "age": 26, "city": "Seattle", "job": "Engineer"}

# Looping through keys
scores = {
    "Alice": 95,
    "Bob": 87,
    "Charlie": 92
};
for name in scores {
    print(f"{name}: {scores[name]}");
}
```

## Tuples

Ordered, immutable collections of items.

```jac
# Create a tuple
point = (10, 20);

# Access items like a list
print(point[0]);  # 10
print(point[1]);  # 20

# Unpack into variables
(x, y) = point;
print(f"x={x}, y={y}");

# Tuples cannot be modified after creation
# point[0] = 5;  # This would cause an error
```

## Sets

Unordered collections of unique items.

```jac
unique_numbers: set = {1, 2, 3, 2, 1};
print(unique_numbers); # {1, 2, 3} (duplicates are removed)
```

## Collections and Data Structures

### Path Collections ($\mathcal{P}$)
A higher-order topological construct representing an ordered sequence of nodes and edges within the object-spatial structure. Path collections are first-class citizens and can be created, modified, and manipulated. They bridge graph theory and computation, providing a formal way to express how walkers move through connected data structures.

**Definition:**
$\mathcal{P} = [p_1, p_2, \ldots, p_k]$ where each $p_i \in N \cup E$ (node or edge).

**Constraints:**
1.  **Origin Connectivity:** $p_1$ must be connected to an origin node $n_{\text{origin}}$.
2.  **Sequential Connectivity:** For $i > 1$, $p_i$ must be connected to a preceding element $p_j$ ($j < i$).
3.  **Path Completeness:** A path from $n_{\text{origin}}$ to $p_i$ must exist, with all intermediate elements present in $\{p_1, \ldots, p_{i-1}\}$.
4.  **Traversal Coherence:** Relative ordering of eligible elements follows Breadth-First Search (BFS) semantics.

**Construction:**
1.  **Explicit Construction:**
    ```jac
    # Example (conceptual)
    P = [node_A, edge_AB, node_B, edge_BC, node_C];
    ```
    Elements must satisfy reachability and ordering constraints. Edges must immediately precede the nodes they connect to on the reachability path from the origin.

2.  **Query-Based Construction:**
    `path(n_origin, predicate, includeEdges, d)`
    -   `n_origin`: Origin node ($N$).
    -   `predicate`: Function `(N | E) -> bool` to determine element inclusion.
    -   `includeEdges`: `bool` to specify if edges are explicitly included.
    -   `d`: Traversal direction (`outgoing`, `incoming`, `any`).

    **Example (conceptual):**
    ```jac
    # Path following specific edge types
    P = path(n_origin, lambda e: type(e) in [edge_type_1, edge_type_2] in sequence, true, outgoing);
    ```
    This performs a BFS from `n_origin`, adding elements based on the predicate and `includeEdges`.

### Walker Destination Queues ($Q_w$)
Represent the actual execution sequence a walker follows. Each active walker $w$ maintains an internal traversal queue $Q_w$.

**Definition:**
$Q_w = [q_1, q_2, \ldots, q_m]$ where $q_i \in N \cup E$.

**Properties:**
1.  **First-In-First-Out (FIFO) Processing:** Elements are processed in order.
2.  **Dynamic Modification:** Queues can be modified during traversal.
    ```jac
    visit(w, n) # Adds node n to walker w's queue
    ```
3.  **Automatic Edge-to-Node Transitions:** Traversing an edge automatically adds the destination node to the queue.
4.  **Path-to-Queue Conversion:** When a walker spawns on or visits a path collection, the path is converted into queue entries.
    ```jac
    visit(w, P) # Expands path P into w's queue
    ```
    The `expandPath(P, L(w))` function transforms the path collection into a physically traversable sequence from the walker's current location `L(w)`, inserting necessary intermediate nodes/edges while maintaining relative ordering and connectivity.
5.  **Activity Persistence:** A walker remains active until its queue is exhausted or it is explicitly disengaged.

### Standard Collections

#### Lists
Ordered, mutable sequences of elements.
```jac
has interests: list[str] = [];
has visited_locations: list[str] = [];
has messages: list[str] = [];
has present_students: list[str] = [];
has absent_students: list[str] = [];
has visited_nodes: list[str] = [];
has visited_edges: list[str] = [];
has loaded_tweets: list[dict] = [];
has errors: list[str] = [];
has recommendations: list[dict] = [];
```

#### Sets
Unordered collections of unique elements.
```jac
has rooms_visited: set[str] = {};
has users_visited: set[str] = set();
```

### Type Annotations
Explicitly define the type of variables, parameters, and return values.
```jac
def calculate_average(numbers: list[float]) -> float {
    // ...
}

node Person {
    has name: str;
    has age: int;
    has interests: list[str] = [];
}

walker FindCommonInterests {
    has target_person: Person;
    has common_interests: list[str] = [];
}

walker debug_graph {
    has visited_nodes: list[str] = [];
    has visited_edges: list[str] = [];
    has max_depth: int = 3;
    has current_depth: int = 0;
}

walker feed_loader {
    has user_id: str;
    has loaded_tweets: list[dict] = [];
    has users_visited: set[str] = set();
    has errors: list[str] = [];
}

walker get_recommendations(visit_profile) {
    has limit: int = 5;
    has algorithm: str = "hybrid";
    has recommendations: list[dict] = [];
}

def calculate_recommendation_score(
    current_user: Profile,
    candidate: Profile,
    followed_users: list[Profile]
) -> float {
    // ...
}

def get_recommendation_reason(
    current_user: Profile,
    candidate: Profile,
    followed_users: list[Profile]
) -> str {
    // ...
}
```

# Collections and Data Structures

## Type Annotations
Jac enforces type annotations for all collections, ensuring type safety and clarity.

## Lists
Lists are ordered collections of items that can be of mixed types. Declared with the `list` type.

```jac
with entry {
    # Create an empty list for storing integer grades
    alice_grades: list[int] = [];

    # Append grades to the list
    alice_grades.append(88);
    alice_grades.append(92);
    alice_grades.append(85);

    # Access grades by index
    first_grade: int = alice_grades[0];
    print(f"Alice's first grade: {first_grade}");

    # print the entire list of grades
    print(f"Alice's grades: {alice_grades}");
}
```

## Dictionaries
Dictionaries store data as key-value pairs. Declared with the `dict` type, specifying key and value types.

```jac
with entry {
    # Class gradebook
    math_grades: dict[str, int] = {
        "Alice": 92,
        "Bob": 85,
        "Charlie": 78
    };

    # Access grades by student name
    print(f"Alice's Math grade: {math_grades['Alice']}");
    print(f"Bob's Math grade: {math_grades['Bob']}");
    print(f"Charlie's Math grade: {math_grades['Charlie']}");
}
```

## Sets
Sets are unordered collections that do not allow duplicate items. Declared with the `set` type.

```jac
with entry {
    # Track unique courses
    alice_courses: set[str] = {"Math", "Science", "English"};
    bob_courses: set[str] = {"Math", "History", "Art"};

    # Find common courses
    common_courses = alice_courses.intersection(bob_courses);
    print(f"Common courses: {common_courses}");

    # All unique courses
    all_courses = alice_courses.union(bob_courses);
    print(f"All courses: {all_courses}");
}
```

## Collection Comprehensions
Jac supports list and dictionary comprehensions for concise collection creation.

### List Comprehension
Syntax: `[expression for item in iterable if condition]`

```jac
with entry {
    # Raw test scores
    test_scores: list[int] = [78, 85, 92, 69, 88, 95, 72];

    # Get passing grades (70 and above)
    passing_scores: list[int] = [score for score in test_scores if score >= 70];
    print(f"Passing scores: {passing_scores}");

    # Create a new list where each score is 5 points higher.
    curved_scores: list[int] = [score + 5 for score in test_scores];
    print(f"Curved scores: {curved_scores}");
}
```

### Dictionary Comprehension Example
```jac
def get_history() -> list[dict] {
    history_nodes = [self --> HistoryEntry];
    return [
        {
            "timestamp": h.timestamp,
            "old_value": h.old_value,
            "new_value": h.new_value
        }
        for h in history_nodes
    ];
}
```

```jac
def list_counters() -> list[dict] {
    counters = [self --> Counter];
    return [
        {"name": c.name, "value": c.value}
        for c in counters
    ];
}
```

## Functions as First-Class Data

### Global Dictionary of Operations
Functions can be stored and accessed via dictionaries.

```jac
# A global dictionary to map operation names to their corresponding functions.
glob operations: dict[str, callable] = {
    "add": add,
    "subtract": subtract,
    "multiply": multiply,
    "divide": divide
};
```

```jac
# Main entry point for the program
with entry {
    a: float = 10.0;
    b: float = 5.0;

    # To test other operations, simply change this string.
    operation_name: str = "add";

    # Check if the requested operation exists in our dictionary.
    if operation_name in operations {
        # Look up the function in the dictionary and pass it to the calculator.
        selected_operation_func = operations[operation_name];
        result: float = calculator(a, b, selected_operation_func);
        print(f"Result of {operation_name}({a}, {b}) = {result}");
    } else {
        print(f"Operation '{operation_name}' is not supported.");
    }
}
```

### Lambda Functions
Concise, single-line, anonymous functions.
Syntax: `lambda parameters: return_type: expression`

```jac
# This lambda takes two `float` parameters, `a` and `b`, and returns their sum as a `float`. It can be called just like a regular function.
add = lambda x: float, y: float: x + y;
```

```jac
with entry {
    add = lambda x: float, y: float: x + y;

    a: float = 10.0;
    b: float = 5.0;

    # Using the lambda function
    result: float = add(a, b);
    print(f"Result of add({a}, {b}) = {result}");
}
```

### Higher-Order Functions
Functions that take other functions as arguments, return functions, or both. The `callable` type hint is used.

```jac
# Higher-order function that applies operation to list
def apply_operation(numbers: list[float], operation: callable) -> list[float] {
    return [operation(num) for num in numbers];
}

# Function that creates specialized functions
def create_multiplier(factor: float) -> callable[[float], float] {
    return lambda x: float: x * factor;
}

# Function composition
def compose(f: callable, g: callable) -> callable {
    return lambda x: any: f(g(x));
}

with entry {
    print("=== Higher-Order Functions Demo ===");

    numbers = [1.0, 2.0, 3.0, 4.0, 5.0];

    # Create specialized multiplier functions
    triple = create_multiplier(3.0);
    quadruple = create_multiplier(4.0);

    # Apply operations
    tripled = apply_operation(numbers, triple);
    quadrupled = apply_operation(numbers, quadruple);

    print(f"Original: {numbers}");
    print(f"Tripled: {tripled}");
    print(f"Quadrupled: {quadrupled}");
}
```

### Built-in Higher-Order Functions

#### `filter`
Constructs a new iterable from elements for which a given function returns `True`.
Signature: `filter(function, iterable)`

```jac
with entry {
    test_scores: list[int] = [78, 85, 92, 69, 88, 95, 72];

    # The lambda `lambda score: bool: score >= 70` returns True for passing scores.
    # 'filter' applies this lambda to each item in 'test_scores'.
    passing_scores_iterator = filter(lambda score: float: score >= 70, test_scores);

    # The result of 'filter' is an iterator, so we convert it to a list to see the results.
    passing_scores: list[int] = list(passing_scores_iterator);
    print(f"Passing scores: {passing_scores}");
}
```

#### `map`
Applies a given function to every item of an iterable and returns an iterator of the results.
Signature: `map(function, iterable)`

```jac
def classify_grade(score: int) -> str {
    if score >= 90 {
        return "A";
    } elif score >= 80 {
        return "B";
    } elif score >= 70 {
        return "C";
    } elif score >= 60 {
        return "D";
    } else {
        return "F";
    }
}

with entry {
    # Raw test scores
    test_scores = [78, 85, 92, 69, 88, 95, 72];
    # Example usage of map would go here, e.g.,
    # classified_grades = list(map(classify_grade, test_scores));
    # print(f"Classified grades: {classified_grades}");
}
```

## Object Definitions with Collections

### `obj Response`
```jac
obj Response {
    has follow_up_questions: str;    # Next question to ask
    has summary: str;                # Concise memory summary
    has when: str;                   # Date in YYYY-MM-DD format
    has who: List[str];              # Names of people involved
    has what: str;                   # What the memory is about
    has where: List[str];            # Relevant locations
    has terminate_conversation: bool; # Completion flag
    has show_summary: bool;          # Display summary flag
}
```

### `obj InventoryItem`
```jac
obj InventoryItem {
    has name: str;
    has price: float;
}
```

### `obj Person`
```jac
obj Person {
    has name: str;
    has age: int;
    has hobby: str;
    has description: str;
    has money: float;
    has inventory: list[InventoryItem];
}
```

### `obj Chat`
```jac
obj Chat {
    has person: str;
    has message: str;
}
```

### `obj Map`
```jac
obj Map {
    has level: Level, walls: list[Wall];    # embeds Level + walls
    has small_obstacles: list[Position];    # extra blocks
    has enemies: list[Position];    # enemy positions
    has player_pos: Position;       # player start
}
```

### `obj LevelManager`
```jac
obj LevelManager {
    has current_level: int = 0, current_difficulty: int = 1,
        prev_levels: list[Level] = [], prev_level_maps: list[Map] = [];

    def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
    -> Level by llm();

    def create_next_map(level: Level) -> Map by llm();
}
```

### `def create_next_level` (Agent Pattern)
```jac
def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
-> Level by llm();
```

### `has shared_with: list[str]`
```jac
            has shared_with: list[str] = [];
```