# Functions and Callables

# Functions and Callables

## Definition and Structure

Functions and methods are defined using the `def` keyword. Type annotations are mandatory for parameters and return values.

-   **`def`**: Defines a standard function with mandatory type annotations.
-   **`can`**: Defines an "ability" (a method) for an archetype.
-   **`impl`**: Separates the implementation of a construct from its declaration. Method bodies for archetypes are provided in `impl Class.method` blocks.
-   **`yield`**: Pauses a function, returns a value, and creates a generator.

Methods that take no parameters omit parentheses in their signature.

```jac
# Function definition with type annotations and default parameters
def learnMultiple(x: int, y: int = 5) -> (int, int) {
	return (x + y, x * y); # Return two values.
}

# Function with no parameters
def nextFunction {
	x = 3;
	y = 4;
	(add, mult) = learnMultiple(x, y);
	print(f"sum: {add} prod:{mult}");
}

# Recursive function example
def factorial(n: int) -> int {
    if n == 0 { return 1; }
    else { return n * factorial(n-1); }
}
```

### Lambda Functions

Anonymous functions can be created using `lambda`.

```jac
def learnSpecial(){
    add = lambda a: int, b: int -> int : a + b;
    print(add(5, 3));
}
```

### Method Implementation for Archetypes

Archetype methods are declared in the archetype definition and implemented separately.

```jac
obj Tweet {
    has content: str, author: str, timestamp: str, likes: int = 0;

    def like() -> None;
    def unlike() -> None;
    def get_preview(max_length: int) -> str;
    def get_like_count() -> int;
}

impl Tweet.like() -> None {
    self.likes += 1;
}

impl Tweet.unlike() -> None {
    if self.likes > 0 {
            self.likes -= 1;
    }
}

impl Tweet.get_preview(max_length: int) -> str {
    return self.content[:max_length] + "..." if len(self.content) > max_length else self.content;
}

impl Tweet.get_like_count() -> int {
    return self.likes;
}
```

## Special Functionalities

### LLM Integration

Functions can delegate their execution to an LLM using `by llm()`. This removes the need for explicit prompt engineering.

```jac
def get_personality(name: str) -> Personality by llm();
```

### Testing

-   `jac_test(func)`: Marks a function as a test.
-   `run_test(filepath, ...)`: Runs a test suite.

## Built-in Functions and Utilities

### Graph Traversal and Manipulation

-   `connect(left, right, edge, undir, conn_assign, edges_only)`: Connect nodes with an edge.
    -   `left`: source node(s)
    -   `right`: target node(s)
    -   `edge`: edge class (optional)
    -   `undir`: undirected flag
    -   `conn_assign`: attribute assignments
    -   `edges_only`: return edges instead of nodes
-   `disconnect(left, right, dir, filter)`: Remove edges between nodes.
    -   `left`: source node(s)
    -   `right`: target node(s)
    -   `dir`: edge direction
    -   `filter`: edge filter function
-   `build_edge(is_undirected, conn_type, conn_assign)`: Create an edge builder function.
    -   `is_undirected`: bidirectional flag
    -   `conn_type`: edge class
    -   `conn_assign`: initial attributes
-   `spawn(walker, node)`: Start a walker at a node.
    -   `walker`: Walker instance
    -   `node`: Starting node
-   `spawn_call(walker, node)`: Internal synchronous spawn execution.
    -   `walker`: Walker anchor
    -   `node`: Node/edge anchor
-   `async_spawn_call(walker, node)`: Internal asynchronous spawn execution.
    -   `walker`: Walker anchor
    -   `node`: Node/edge anchor
-   `visit(walker, nodes)`: Visit specified nodes.
    -   `walker`: Walker instance
    -   `nodes`: Node/edge references
-   `disengage(walker)`: Stop walker traversal.
    -   `walker`: Walker to stop
-   `refs(path)`: Convert path to node/edge references.
    -   `path`: ObjectSpatialPath
-   `arefs(path)`: Async path references (placeholder).
    -   `path`: ObjectSpatialPath
-   `get_edges(origin, destination)`: Get edges connected to nodes.
    -   `origin`: list of nodes
    -   `destination`: ObjectSpatialDestination
-   `get_edges_with_node(origin, destination, from_visit)`: Get edges and connected nodes.
    -   `origin`: list of nodes
    -   `destination`: destination spec
    -   `from_visit`: include nodes flag
-   `edges_to_nodes(origin, destination)`: Get nodes connected via edges.
    -   `origin`: list of nodes
    -   `destination`: destination spec
-   `remove_edge(node, edge)`: Remove edge reference from node.
    -   `node`: NodeAnchor
    -   `edge`: EdgeAnchor
-   `detach(edge)`: Detach edge from both nodes.
    -   `edge`: EdgeAnchor
-   `root()`: Get the current root node.
-   `get_all_root()`: Get all root nodes.
-   `reset_graph(root)`: Purge graph from memory.

### Object and Attribute Management

-   `assign_all(target, attr_val)`: Assign attributes to a list of objects.
    -   `target`: list of objects
    -   `attr_val`: tuple of (attrs, values)
-   `filter_on(items, func)`: Filter archetype list by predicate.
    -   `items`: list of archetypes
    -   `func`: filter function
-   `get_object(id)`: Get archetype by ID string.
    -   `id`: ID string
-   `object_ref(obj)`: Get hex ID string of an archetype.
    -   `obj`: Archetype instance
-   `save(obj)`: Persist archetype to database.
    -   `obj`: Archetype instance
-   `destroy(objs)`: Delete archetype(s) from memory.
    -   `objs`: Archetype(s) to delete
-   `commit(anchor)`: Commit data to datasource.
    -   `anchor`: Anchor object
-   `field(factory, init)`: Define a dataclass field.
    -   `factory`: Default factory
    -   `init`: Include in init

### Module and Archetype Loading

-   `jac_import(target, base_path, ...)`: Import Jac/Python module.
    -   `target`: Module name
    -   `base_path`: Search path
    -   `absorb`, `mdl_alias`, `override_name`, `items`, `reload_module`, `lng`: import options
-   `load_module(module_name, module, force)`: Load module into machine.
    -   `module_name`: Name
    -   `module`: Module object
    -   `force`: reload flag
-   `attach_program(program)`: Attach JacProgram to runtime.
    -   `program`: JacProgram instance
-   `list_modules()`: List all loaded modules.
-   `list_nodes(module_name)`: List nodes in a module.
    -   `module_name`: Module to inspect
-   `list_walkers(module_name)`: List walkers in a module.
    -   `module_name`: Module to inspect
-   `list_edges(module_name)`: List edges in a module.
    -   `module_name`: Module to inspect
-   `get_archetype(module_name, archetype_name)`: Get archetype class from a module.
    -   `module_name`: Module
    -   `archetype_name`: Class name
-   `make_archetype(cls)`: Convert a class to an archetype.
    -   `cls`: Class to convert
-   `spawn_node(node_name, attributes, module_name)`: Create a node instance by name.
    -   `node_name`: Node class name
    -   `attributes`: Init dict
    -   `module_name`: Source module
-   `spawn_walker(walker_name, attributes, module_name)`: Create a walker instance by name.
    -   `walker_name`: Walker class
    -   `attributes`: Init dict
    -   `module_name`: Source module
-   `update_walker(module_name, items)`: Reload walker from module.
    -   `module_name`: Module
    -   `items`: Items to update
-   `create_archetype_from_source(source_code, ...)`: Create archetype from Jac source.
    -   `source_code`: Jac code string
    -   `module_name`, `base_path`, `cachable`, `keep_temporary_files`: options

### Access Control

-   `perm_grant(archetype, level)`: Grant public access to an archetype.
    -   `archetype`: Target archetype
    -   `level`: AccessLevel (READ/CONNECT/WRITE)
-   `perm_revoke(archetype)`: Revoke public access.
    -   `archetype`: Target archetype
-   `allow_root(archetype, root_id, level)`: Allow specific root access.
    -   `archetype`: Target
    -   `root_id`: Root UUID
    -   `level`: Access level
-   `disallow_root(archetype, root_id, level)`: Disallow specific root access.
    -   `archetype`: Target
    -   `root_id`: Root UUID
    -   `level`: Access level
-   `elevate_root()`: Elevate context to system root.
-   `check_read_access(anchor)`: Check read permission.
    -   `anchor`: Target anchor
-   `check_write_access(anchor)`: Check write permission.
    -   `anchor`: Target anchor
-   `check_connect_access(anchor)`: Check connect permission.
    -   `anchor`: Target anchor
-   `check_access_level(anchor, no_custom)`: Get access level for an anchor.
    -   `anchor`: Target
    -   `no_custom`: skip custom check

### Reporting and Debugging

-   `report(expr, custom)`: Report a value from a walker.
    -   `expr`: Value to report
    -   `custom`: custom report flag
-   `printgraph(node, depth, traverse, edge_type, bfs, edge_limit, node_limit, file, format)`: Generate graph visualization.
    -   `node`: Start node
    -   `depth`: Max depth
    -   `traverse`: traversal flag
    -   `edge_type`: filter edges
    -   `bfs`: breadth-first flag
    -   `edge_limit`, `node_limit`: limits
    -   `file`: output path
    -   `format`: 'dot' or 'mermaid'
-   `impl_patch_filename(file_loc)`: Patch function file location for stack traces.
    -   `file_loc`: File path

### LLM Internal Functions

-   `call_llm(model, mtir)`: Direct LLM invocation.
-   `get_mtir(caller, args, call_params)`: Get method IR for LLM.

### Concurrency

-   `thread_run(func, *args)`: Run a function in a new thread.
    -   `func`: Function
    -   `args`: Arguments
-   `thread_wait(future)`: Wait for thread completion.
    -   `future`: Future object

### Miscellaneous

-   `setup()`: Initialize class references.
-   `get_context()`: Get current execution context.
-   `create_cmd()`: Create CLI commands (placeholder).

## Python Interoperability

Jac functions can be called from Python, and Python functions can be imported into Jac.

### Importing Python Modules

```jac
import:py from json {dumps};
```

### Inline Python Code

Python code can be embedded directly within Jac files using `::py::` blocks.

```jac
::py::
# Legacy Python validation - kept as-is
def validate_title(title):
    """Complex validation logic from old codebase."""
    return len(title) > 3 and title.strip() != ""
::py::
```

### Calling Jac from Python

Jac modules can be imported and used in Python after enabling `jaclang`.

```python
import jaclang  # Enable Jac imports
from jaclang.lib import spawn, root, Node, Walker, on_entry, connect

# Define Jac-like structures in Python
class Task(Node):
    title: str
    done: bool

    def __init__(self, title: str):
        super().__init__()
        self.title = title
        self.done = False

class TaskCreator(Walker):
    def __init__(self, title: str):
        super().__init__()
        self.title = title

    @on_entry
    def create(self, here) -> None:
        """Entry point - creates task."""
        # Assuming validate_title is a Python function
        if validate_title(self.title):
            task = Task(title=self.title)
            connect(here, task)
            print(f"âœ“ Created: {task.title}")
        else:
            print("âœ— Title too short!")

if __name__ == "__main__":
    # Example Python function using Jac features
    def create_task(title: str):
        if not validate_title(title):
            print("âœ— Title too short!")
            return

        creator = TaskCreator(title=title)
        spawn(creator, root())

    # Assuming validate_title is defined elsewhere in Python
    def validate_title(title: str) -> bool:
        return len(title) > 3

    create_task("Build API")
```

## Functions

### Definition and Calling
Functions are defined using the `def` keyword, specifying parameters with optional type hints and a return type.

```jac
def add_numbers(a: int, b: int) -> int {
    result: int = a + b;  # Local variable
    return result;
}
with entry {
    sum = add_numbers(5, 10);
    print(f"Sum: {sum}");
}
```

### Global Variables
Global variables are declared with `glob` and can be accessed within functions using `:g:`.

```jac
glob school_name: str = "Jac High School";
glob passing_grade: int = 60;
glob honor_threshold: float = 3.5;

def get_school_info() -> str {
    :g: school_name; # Accessing global variable
    return f"Welcome to {school_name}";
}

with entry {
    print(get_school_info());
    print(f"Honor threshold is {honor_threshold}");
}
```

### Object Methods
Functions defined within an `obj` block are methods. They can access object properties using `self`.

```jac
obj Calculator {
    has precision: int = 2;

    def add(a: float, b: float) -> float;
    def subtract(a: float, b: float) -> float;
    def multiply(a: float, b: float) -> float;
    def divide(a: float, b: float) -> float;
}
```

Methods are implemented using `impl ObjectName.method_name`.

```jac
impl Calculator.add {
    result = a + b;
    return round(result, self.precision);
}

impl Calculator.subtract {
    result = a - b;
    return round(result, self.precision);
}

impl Calculator.multiply {
    result = a * b;
    return round(result, self.precision);
}

impl Calculator.divide {
    if b == 0.0 {
        raise ValueError("Division by zero");
    }
    result = a / b;
    return round(result, self.precision);
}
```

Example method usage:

```jac
            def get_status() -> str {
                return f"Delivered {self.delivery_count} messages to {len(self.visited_locations)} locations";
            }
```

```jac
            def report_final() -> None {
                print(f" Attendance Report:");
                print(f"   Present: {self.present_students}");
                print(f"   Absent: {self.absent_students}");
                print(f"   Total checked: {self.checks_done}");
            }
```

### LLM Function Overriding
Functions can be overridden at runtime with an LLM-powered implementation using `function_call() by llm()`.

## Standard Library

### File I/O
Module: `file`

```jac
# Read text file safely
def read_file(filepath: str) -> str | None {
    try {
        with open(filepath, 'r') as file {
            return file.read();
        }
    } except FileNotFoundError {
        print(f"File not found: {filepath}");
        return None;
    } except Exception as e {
        print(f"Error reading file: {e}");
        return None;
    }
}

# Write text file safely
def write_file(filepath: str, content: str) -> bool {
    try {
        with open(filepath, 'w') as file {
            file.write(content);
        }
        return True;
    } except Exception as e {
        print(f"Error writing file: {e}");
        return False;
    }
}
```

### JSON
Module: `json`

```jac
import:py from json {dumps};

# Read JSON file
def read_json(filepath: str) -> dict | None {
    try {
        with open(filepath, 'r') as file {
            return json.load(file);
        }
    } except FileNotFoundError {
        print(f"JSON file not found: {filepath}");
        return None;
    } except json.JSONDecodeError {
        print(f"Invalid JSON in file: {filepath}");
        return None;
    }
}
```

### OS Path Operations
Module: `os.path`

```jac
impl ConfigReader.load_config {
    if not os.path.exists(self.config_file) {
        print(f"Config file {self.config_file} not found, creating default");
        self.create_default_config();
        return True;
    }
    // ...
}
```

### Logging
Module: `logging`

```jac
impl Application.setup_logging {
    log_config = self.config.get_value("logging", {});
    log_level = log_config.get("level", "INFO");
    log_file = log_config.get("file", "app.log");

    logging.basicConfig(
        level=getattr(logging, log_level),
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    );

    self.logger = logging.getLogger("app");
    self.logger.info("Logging configured");
}
```

## Client-Side (cl) Functions and Components

Client-side code is denoted by the `cl` keyword.

### JSX-like Syntax
Client-side functions can return JSX-like structures for UI rendering.

```jac
cl def homepage() -> dict {
    return <div>
        <h1>Welcome</h1>
        <button onclick={load_feed()}>Load Feed</button>
    </div>;
}
```

Elements can have attributes, expressions, spread attributes, and fragments.

```jac
cl def render_example() {
    // Basic elements
    let basic = <div>Hello World</div>;

    // Elements with attributes
    let with_attrs = <button id="submit" class="btn">Click</button>;

    // Expression attributes and children
    let name = "Alice";
    let greeting = <h1 data-user={name}>Welcome, {name}!</h1>;

    // Spread attributes
    let props = {"class": "card", "id": "main"};
    let with_spread = <div {...props}>Content</div>;

    // Fragment syntax
    let fragment = <>
        <div>First</div>
        <div>Second</div>
    </>;

    // Component usage (capitalized names)
    let component = <Button label="Click Me" />;

    return <div>{greeting}{component}</div>;
}
```

### Client Runtime Imports
Client-side functionality often relies on imports from `jac:client_runtime`.

```jac
cl import from jac:client_runtime {
    jacLogin,
    jacLogout,
    jacIsLoggedIn,
    createSignal,
    createState,
    createRouter,
    Route,
    Link,
    navigate,
    createEffect
}
```

### Reactive State Management

#### `createSignal`
For simple, primitive reactive values. `count()` reads the value, `setCount()` updates it.

```jac
cl def Counter() {
    [count, setCount] = createSignal(0);

    def increment() {
        setCount(count() + 1);  // Read with (), set by calling setter
    }

    return <div>
        <p>Count: {count()}</p>
        <button onclick={increment}>Increment</button>
    </div>;
}
```

#### `createState`
For more complex, object-based reactive state. `state()` reads the current state object, `setState()` performs a shallow merge.

```jac
cl def TodoList() {
    [state, setState] = createState({
        "todos": [],
        "filter": "all"
    });

    def addTodo(text: str) {
        todos = state().todos;
        todos.push({"text": text, "done": False});
        setState({"todos": todos});  // Shallow merge with existing state
    }

    return <div>
        <ul>
            {[<li>{todo.text}</li> for todo in state().todos]}
        </ul>
    </div>;
}
```

#### `createEffect`
Runs a side effect function when its dependencies (signals/states read within it) change.

```jac
cl def DataFetcher() {
    [userId, setUserId] = createSignal(1);
    [userData, setUserData] = createSignal(None);

    createEffect(lambda -> None {
        id = userId();  // Track dependency!
        console.log("Fetching user", id);
        # In real app, would fetch from API
        setUserData({"id": id, "name": "User " + str(id)});
    });

    return <div>
        <button onclick={lambda: setUserId(userId() + 1)}>Next User</button>
        <p>Current: {userData() and userData().name or "Loading..."}</p>
    </div>;
}
```

### Routing

#### `createRouter` and `Route`
Defines client-side routes and renders the corresponding component.

```jac
cl def App() {
    routes = [
        Route("/", HomePage),
        Route("/about", AboutPage),
        Route("/profile", ProfilePage, guard=jacIsLoggedIn)
    ];

    router = createRouter(routes, defaultRoute="/");

    return <div>
        <nav>
            <Link href="/">Home</Link>
            <Link href="/about">About</Link>
            <Link href="/profile">Profile</Link>
        </nav>
        <main>{router.render()}</main>
    </div>;
}
```

#### `navigate`
Programmatically navigates to a different route.

```jac
cl def LoginForm() {
    def handleSubmit() {
        # After successful login
        navigate("/dashboard");
    }

    return <form onsubmit={handleSubmit}>...</form>;
}
```

#### Route Guards
`guard` parameter in `Route` can protect routes based on a condition (e.g., `jacIsLoggedIn`).

```jac
cl def AccessDenied() {
    return <div>
        <h1>Access Denied</h1>
        <button onclick={lambda: navigate("/login")}>Login</button>
    </div>;
}

Route("/admin", AdminPanel, guard=jacIsLoggedIn)
```

### Authentication
`jacLogin`, `jacLogout`, `jacIsLoggedIn` are provided for client-side authentication.

```jac
cl def LoginForm() {
    async def handleLogin(event: any) {
        event.preventDefault();
        let username = document.getElementById("username").value;
        let password = document.getElementById("password").value;

        success = await jacLogin(username, password);
        if success {
            console.log("Login successful!");
            // Redirect or update UI
        } else {
            console.log("Login failed");
        }
    }

    return <form onsubmit={handleLogin}>
        <input id="username" type="text" placeholder="Username" />
        <input id="password" type="password" placeholder="Password" />
        <button type="submit">Login</button>
    </form>;
}
```

## Functions and Callables

### Function Definition
Functions are defined using the `def` keyword for traditional Python-like functions and methods. The `can` keyword is reserved for object-spatial abilities (e.g., `can entry`, `can exit`, `can with`).

```jac
def add(x: int, y: int) -> int {
    return x + y;
}

node Person {
    has name: str;
    has age: int;

    def get_name() -> str {
        return self.name;
    }

    can greet with speak_to entry {
        return "Hello " + visitor.name + ", my name is " + self.name;
    }

    def calculate_birth_year() -> int {
        return 2025 - self.age;
    }
}
```

### AI-Powered Functions (`by llm()`)
Jac functions can integrate directly with Large Language Models (LLMs) using the `by` keyword. This allows the function signature itself to act as a prompt, with the LLM handling the implementation.

#### Configuration
```jac
import from byllm.lib { Model, Image }

glob npc_model = Model(model_name="gpt-4.1-mini");
glob llm = Model(model_name="gpt-4o-mini");
```

#### Basic Usage
```jac
""" Write a poem about topic """
def write_poetry(topic: str) -> str by llm();

with entry {
    poem = write_poetry("A serene landscape with mountains.");
    print(poem);
}
```

#### State-Aware Functions
Functions can take a dictionary representing the walker's state, allowing the LLM to interpret context.
```jac
"""Adjusts the tone or personality of the shop keeper npc depending on weather/time."""
def get_ambient_mood(state: dict) -> str by npc_model();

walker StateAgent{
    has state: dict = {};
    can start with `root entry {
        visit [-->(`?Service)];
    }
}

node Weather(Service) {
    has temp: int = 80;
    can get with StateAgent entry {
        visitor.state["temperature"] = self.temp;
    }
}

node NPC {
    can get with StateAgent entry {
        visitor.state["npc_mood"] = get_ambient_mood(visitor.state);
    }
}

with entry {
    root ++> Weather();
    root ++> Time();
    root ++> NPC();

    agent = NPCWalker() spawn root;
    print(agent.state['npc_mood']);
}
```

#### Image Input
The `Image` type from `byllm.lib` allows passing image files directly to LLM-powered functions.
```jac
import from byllm.lib { Model, Image }

glob llm = Model(model_name="gpt-4o-mini");

"""Generate a detailed caption for the given image."""
def caption_image(image: Image) -> str by llm();

with entry {
    caption = caption_image(Image("photo.jpg"));
    print(caption);
}
```

### Node Methods
Nodes can define methods using `def` for internal logic and `can` for abilities that interact with the graph or walkers.

```jac
node Counter {
    has name: str;
    has value: int = 0;
    has created_at: str;

    def increment(amount: int = 1) -> int {
        old_value = self.value;
        self.value += amount;

        # Create history entry
        history = HistoryEntry(
            timestamp=str(datetime.now()),
            old_value=old_value,
            new_value=self.value
        );
        self ++> history; // Node connection
        return self.value;
    }

    def get_value() -> int {
        return self.value;
    }

    def reset() -> int {
        self.value = 0;
        return self.value;
    }

    def get_history() -> list[dict] {
        history_nodes = [self --> HistoryEntry]; // Graph traversal
        return [
            {
                "timestamp": h.timestamp,
                "old_value": h.old_value,
                "new_value": h.new_value
            }
            for h in history_nodes
        ];
    }
}

node CounterManager {
    has created_at: str;

    def create_counter(name: str) -> dict {
        // Check if counter already exists
        existing = [self --> Counter](?name == name);
        if existing {
            return {"status": "exists", "counter": existing[0].name};
        }

        new_counter = Counter(name=name, value=0);
        self ++> new_counter;
        return {"status": "created", "counter": name};
    }

    def list_counters() -> list[dict] {
        counters = [self --> Counter];
        return [
            {"name": c.name, "value": c.value}
            for c in counters
        ];
    }

    def get_total() -> int {
        counters = [self --> Counter];
        return sum([c.value for c in counters]);
    }
}
```

### Standard Library Functions

#### `printgraph`
Outputs graph data, similar to `dotgen` but with a clearer name and potential for other formats.
```jac
node N {has val: int;}
edge E {has val: int = 0;}

with entry {
    end = root;
    for i in range(0, 2) {
        end +>: E : val=i :+> (end := [ N(val=i) for i in range(0, 2) ]);
    }
    data = printgraph(node=root);
    print(data);
}
```

#### `allroots()`
Returns a list of all root nodes currently in memory or the database.
```jac
with entry {
    all_root_nodes = allroots();
    print(all_root_nodes);
}
```

#### Permission Management
Functions for granting and revoking permissions on nodes.
- `grant(node, permission_enum)`: Grants a specified permission to a node.
- `revoke(node, permission_enum)`: Revokes a specified permission from a node.

Permission Enums:
- `NoPerm`
- `ReadPerm`
- `ConnectPerm`
- `WritePerm`

```jac
node MyNode {}
with entry {
    n = MyNode();
    grant(n, ConnectPerm);
    revoke(n, ReadPerm);
}
```

### Python Interoperability
Jac supports importing and using Python modules and functions.

```jac
import:py from json {dumps};
import:py from openai { OpenAI };

glob client = OpenAI();

def write_poetry_python(topic: str) -> str {
    response = client.responses.create(
        model="gpt-4.1-mini",
        input=f"Write a poem about {topic}."
    );
    return response.output_text;
}
```

## Functions and Callables

### Function Definition

-   **`def` keyword**: Used for traditional Python-like functions and methods.
-   **`can` keyword**: Reserved for object-spatial abilities.

```jac
def get_personality(name: str) -> Personality {
    # Traditional approach: manual algorithm, prompt-engineered LLM call, etc.
}
```

### Lambda Functions

-   **Syntax**: `lambda <parameters>: <return_type>: <expression>;`
-   **Example**:
    ```jac
    lambda x: int: x * x;
    ```
-   **Note**: `self` parameter is not injected into lambdas declared inside abilities/methods. Type annotations are stripped from lambda parameters during `jac2py` conversion but retained in Jac AST for type checking.

### Python Function Parameter Syntax Support

Jaclang supports advanced Python function parameter patterns:
-   Positional-only parameters (`/` separator)
-   Keyword-only parameters (`*` separator without type hints)
-   Complex parameter combinations (e.g., `def foo(a, b, /, *, c, d=1, **kwargs): ...`)

### LLM-Powered Functions (`by llm()`)

The `by` keyword abstraction enables functions to process inputs of any type and generate contextually appropriate outputs of the specified type using an LLM.

```jac
enum Personality {
    INTROVERT,
    EXTROVERT,
    AMBIVERT
}

def get_personality(name: str) -> Personality by llm();

with entry {
    name = "Albert Einstein";
    result = get_personality(name);
    print(f"{result} personality detected for {name}");
}
```

### Python Integration with LLM Tools

Python functions can be used as tools callable by an LLM.

```python
import jaclang
from byllm.lib import Model
llm = Model(model_name="gpt-4o")

def get_weather(city: str) -> str:
    return f"The weather in {city} is sunny."

@by(llm(tools=[get_weather]))
def answer_question(question: str) -> str: ...
```

### Custom LLM Model Implementation

You can define custom LLM models by inheriting from `byllm.llm.BaseLLM`.

```jac
import from byllm.llm { BaseLLM }
import from openai { OpenAI }

obj MyOpenAIModel(BaseLLM){
    has model_name: str;
    has config: dict = {};

    def post_init() {
        super().__init__(model_name=self.model_name, **kwargs);
    }

    def model_call_no_stream(params: dict) {
        client = OpenAI(api_key=self.api_key);
        response = client.chat.completions.create(**params);
        return response;
    }

    def model_call_with_stream(params: dict) {
        client = OpenAI(api_key=self.api_key);
        response = client.chat.completions.create(stream=True, **params);
        return response;
    }
}
```

### Jaclang CLI `enter` Command

Executes a specified entrypoint function in a `.jac` file.

```bash
jac enter <file_path> <entrypoint> <args>
```
-   `file_path`: Path to the `.jac` file.
-   `entrypoint`: Name of the entrypoint function.
-   `args`: Arguments to pass to the entrypoint function.

Example:
```bash
jac enter <file_path>
```

### Node Access Control Functions

These functions are used within walkers to manage access permissions on nodes.

-   `_.allow_root(here, NodeAnchor.ref(target_root_id), access_level)`: Grants a specified `access_level` (e.g., `ReadPerm`, `ConnectPerm`, `WritePerm`) to a `target_root_id` for the `here` node.
    ```jac
    walker grant_access {
        has target_root_id: str;
        has access_level: str;

        can grant_access with post entry {
            _.allow_root(here, NodeAnchor.ref(self.target_root_id), self.access_level);
            report "Access granted!";
        }
    }
    ```
-   `_.disallow_root(here, NodeAnchor.ref(target_root_id))`: Revokes all access permissions for a `target_root_id` from the `here` node.
    ```jac
    walker revoke_access {
        has target_root_id: str;

        can revoke_access with post entry {
            _.disallow_root(here, NodeAnchor.ref(self.target_root_id));
            report "Access revoked!";
        }
    }
    ```
-   `grant(here, ReadPerm)`: Grants `ReadPerm` access to all other root nodes for the `here` node.
    ```jac
    walker make_public {
        can make_public with post entry {
            grant(here, ReadPerm);
            report "Post is now public!";
        }
    }
    ```
-   `revoke(here)`: Removes all previously granted access permissions from all other root nodes to the `here` node's data.
    ```jac
    walker make_private {
        can make_private with post entry {
            revoke(here);
            report "Post is now private!";
        }
    }
    ```

### Custom Access Validation (`__jac_access__`)

Nodes can define a `__jac_access__` ability to implement custom access validation logic.

```jac
node A {
    def __jac_access__ {
        # Allowed string return: NoPerm, ReadPerm, ConnectPerm, or WritePerm
        return NoPerm;

        # Allowed enum return: AccessLevel.NO_ACCESS, AccessLevel.READ, AccessLevel.ConnectPerm, AccessLevel.WRITE
        # return AccessLevel.NO_ACCESS;
    }
}
```
To avoid infinite loops during custom access validation, use `_Jac.check_access_level(here, True)`.
```jac
node A {
    def __jac_access__ {
        level = _Jac.check_access_level(here, True); # True means skip custom access validation trigger to avoid infinite loop
        return "NO_ACCESS";
    }
}
```

### Compiler Pass Methods

Compiler passes in Jaclang use `enter_` and `exit_` methods to process nodes during traversal.

```python
# In UniPass
def enter_node(self, node: uni.UniNode) -> None:
    method_name = f"enter_{pascal_to_snake(type(node).__name__)}"
    if hasattr(self, method_name):
        getattr(self, method_name)(node)

# In your pass
def enter_func_call(self, node: uni.FuncCall) -> None:
    # Handle function call nodes
    pass

def exit_if_stmt(self, node: uni.IfStmt) -> None:
    # Handle if statement nodes
    pass
```

### `printgraph` Function

The `dotgen` built-in function has been renamed to `printgraph`. It outputs graph data, supporting DOT format and JSON output via `as_json=True`.

### JavaScript Export Semantics

Declarations annotated with `:pub` (e.g., `obj :pub`, `def :pub`, `enum :pub`, `glob :pub`) generate JavaScript `export` statements for ES module compatibility.

# Functions and Callables

## LLM-Integrated Functions (`by llm()`)

Functions can be integrated with LLM capabilities using the `by llm()` declaration, eliminating manual API calls and prompt engineering.

```jac
import from byllm.lib { Model }

glob llm = Model(model_name="gpt-4o");

def translate(text: str, target_language: str) -> str by llm();

def analyze_sentiment(text: str) -> str by llm();

def summarize(content: str, max_words: int) -> str by llm();
```

### Functions with Reasoning

The `method='Reason'` parameter enables step-by-step reasoning for complex tasks.

```jac
import from byllm.lib { Model }

glob llm = Model(model_name="gpt-4o");

def analyze_sentiment(text: str) -> str by llm(method='Reason');

def generate_response(original_text: str, sentiment: str) -> str by llm();

with entry {
    customer_feedback = "I'm really disappointed with the product quality. The delivery was late and the item doesn't match the description at all.";

    sentiment = analyze_sentiment(customer_feedback);
    response = generate_response(customer_feedback, sentiment);

    print(f"Customer sentiment: {sentiment}");
    print(f"Suggested response: {response}");
}
```

### Structured Output Functions

LLM-integrated functions can return complex structured types.

```jac
obj Person {
    has name: str;
    has age: int;
    has description: str | None;
}

def generate_random_person() -> Person by llm();

with entry {
    person = generate_random_person();
    assert isinstance(person, Person);
    print(f"Generated Person: {person.name}, Age: {person.age}, Description: {person.description}");
}
```

### Tool-Calling Agents with ReAct

Functions can be made agentic by adding the `by llm(tools=[...])` declaration, allowing them to reason and use external tools.

```jac
import from byllm.lib { Model }
import from datetime { datetime }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has dob: str;
}

"""Calculate the age of the person where current date can be retrieved by the get_date tool."""
def calculate_age(person: Person) -> int by llm(tools=[get_date]);

"""Get the current date in DD-MM-YYYY format."""
def get_date() -> str {
    return datetime.now().strftime("%d-%m-%Y");
}

with entry {
    mars = Person("Mars", "27-05-1983");
    print("Age of Mars =", calculate_age(mars));
}
```

### Streaming Outputs

Set `stream=True` to enable real-time token reception from LLM functions. Only `str` output type is supported for streaming.

```jac
import from byllm.lib { Model }

glob llm = Model(model_name="gpt-4o-mini");

""" Generate short essay (less than 300 words) about the given topic """
def generate_essay(topic: str) -> str by llm(stream=True);


with entry {
    topic = "The orca whale and it's hunting techniques";
    for tok in generate_essay(topic) {
        print(tok, end='', flush=True);
    }
    print(end='\n');
}
```

## Adding Context to Functions and Objects

### Docstrings

Docstrings provide context for LLM-integrated functions, helping the LLM understand their purpose and expected behavior.

```jac
import from byllm.lib { Model }

glob llm = Model(model_name="gpt-4o");

"""Translate text to the target language."""
def translate(text: str, target_language: str) -> str by llm();

"""Generate a professional email response based on the input message tone."""
def generate_email_response(message: str, recipient_type: str) -> str by llm();
```

### Semantic Strings (Semstrings)

The `sem` keyword provides semantic strings for describing object attributes and function parameters, enriching their meaning.

```jac
obj Person {
    has name: str;
    has dob: str;
    has ssn: str;
}

sem Person = "Represents the personal record of a person";
sem Person.name = "Full name of the person";
sem Person.dob = "Date of Birth";
sem Person.ssn = "Last four digits of the Social Security Number of a person";

"""Calculate eligibility for various services based on person's data."""
def check_eligibility(person: Person, service_type: str) -> bool by llm();
```

### Additional Context with `incl_info`

The `incl_info` parameter provides additional context to LLM methods for context-aware processing.

```jac
import from byllm.lib { Model }
import from datetime { datetime }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has date_of_birth: str;

    def calculate_age() -> str by llm(
        incl_info={
            "today": datetime.now().strftime("%d-%m-%Y"),
        }
    );
}
```

## General Functions

### `printgraph()`

Generates a DOT graph starting from a specified node.

```jac
print(printgraph());  # Generates a DOT graph starting from the root node
print(printgraph(node_1, bfs=True, traverse=True, edge_type=["Edge1"], node_limit=100, edge_limit=900, depth=300, dot_file='graph.dot'));
print(printgraph(node_1, edge_type=["CustomEdge"]));
```

### `update_memory_details()`

AI-powered memory extraction and refinement.

### `make_api_call()`

Makes an API call to a specified endpoint with a token and payload.

```jac
def make_api_call(token: str, endpoint: str, payload: dict) -> dict {
    response = requests.post(
        "http://localhost:8000/" + endpoint,
        json=payload,
        headers={"Authorization": "Bearer " + token}
    );
    return response.json() if response.status_code == 200 else {};
}
```

### Streamlit UI Functions

Example functions for building Streamlit applications.

#### `simple_calculator()`

A basic calculator UI.

```jac
def simple_calculator() {
    st.title("ðŸ§® Simple Calculator");
    st.write("A basic calculator built with Jac and Streamlit");

    columns = st.columns(2);
    col1 = columns[0];
    col2 = columns[1];

    with col1 {
        num1 = st.number_input("First number:", value=0.0);
    }

    with col2 {
        num2 = st.number_input("Second number:", value=0.0);
    }

    operation = st.selectbox(
        "Choose operation:",
        ["Add", "Subtract", "Multiply", "Divide"]
    );

    if st.button("Calculate") {
        if operation == "Add" {
            result = num1 + num2;
        } elif operation == "Subtract" {
            result = num1 - num2;
        } elif operation == "Multiply" {
            result = num1 * num2;
        } elif operation == "Divide" {
            if num2 != 0 {
                result = num1 / num2;
            } else {
                st.error("Cannot divide by zero!");
                return;
            }
        }

        st.success("Result: " + str(result));

        if "history" not in st.session_state {
            st.session_state.history = [];
        }

        st.session_state.history.append(
            str(num1) + " " + operation.lower() + " " + str(num2) + " = " + str(result)
        );
    }

    if "history" in st.session_state and st.session_state.history {
        st.subheader("ðŸ“ History");
        for calc in st.session_state.history {
            st.write("â€¢ " + calc);
        }

        if st.button("Clear History") {
            st.session_state.history = [];
            st.rerun();
        }
    }
}
```

#### `todo_app()`

A simple todo list application UI.

```jac
def todo_app() {
    st.title("ðŸ“‹ Todo App");
    st.write("A simple todo application built with Jac and Streamlit");

    if "todos" not in st.session_state {
        st.session_state.todos = [];
    }

    with st.form("add_todo") {
        new_todo = st.text_input("Add a new todo:");

        if st.form_submit_button("Add Todo") and new_todo {
            st.session_state.todos.append(new_todo);
            st.success("Todo added!");
        }
    }

    if st.session_state.todos {
        st.subheader("ðŸ“ Your Todos");

        todos_to_remove = [];

        for todo in st.session_state.todos {
            columns = st.columns([4, 1]);

            with columns[0] {
                st.write("â€¢ " + todo);
            }

            with columns[1] {
                if st.button("Remove", key=todo) {
                    todos_to_remove.append(todo);
                }
            }
        }

        for todo in todos_to_remove {
            st.session_state.todos.remove(todo);
        }

        if todos_to_remove {
            st.rerun();
        }

        if st.button("Clear All") {
            st.session_state.todos = [];
            st.rerun();
        }
    } else {
        st.info("No todos yet! Add one above.");
    }

    if st.session_state.todos {
        st.write("Total todos: " + str(len(st.session_state.todos)));
    }
}
```

## Functions

Functions in Jac are defined using the `def` keyword, similar to Python. They can have type annotations for parameters and return values.

```jac
def function_name(param1: Type1, param2: Type2) -> ReturnType {
    // Function body
}
```

### AI Functions (by llm)

Functions can be backed by Large Language Models (LLMs) using the `by llm()` modifier. These functions leverage LLMs for their implementation, handling prompt generation and output formatting automatically.

```jac
import from byllm.lib { Model }

glob llm = Model(model_name="openai/gpt-5", verbose=True);

def make_player() -> Person by llm();

def make_random_npc() -> Person by llm();

"""
Summarize relevant part of each option to the initial query not in current conversation history
"""
def summarize(presented_option: list[str], convo_history: list[dict]) -> str by llm();
```

**Key characteristics of `by llm()` functions:**
-   **Docstrings:** Provide a concise description of the function's purpose. Jac uses variable names, type signatures, and `sem` strings as context, reducing the need for lengthy docstrings.
-   **Type Signatures:** Crucial for guiding the LLM and ensuring structured output.
-   **Stateless:** By default, `by llm()` functions are stateless utilities; they don't retain memory unless explicitly managed through parameters (e.g., `conversation_history`).

**Example with structured output:**

```jac
obj Response{
    has option: str;
    has selection: str;
    has explanation: str;
}

sem Response = "Structured response used by an agentic traversal logic.";
sem Response.option = "A control token defining action: @selected@, @query@, or @end@.";
sem Response.selection = "The chosen node, search query, or final response.";
sem Response.explanation = "A short justification for why this decision was made.";

"""Decide which option is best. Choose one of the emails our current person has sent/received, semantic search for a new email to explore, or answer the initial query"""
def choose_next_email_node(person: str, sent: list[str], received: list[str], conversation_history: list[dict]) -> Response by llm();
```

**Calling `by llm()` functions:**

```jac
response = choose_next_email_node(person_formatted, sent_formatted, received_formatted, conversation_history);
```

### Instance Methods

Functions can be defined as methods within objects. These methods can access the object's properties using `self`.

```jac
obj LevelManager {
    has current_level: int = 0, current_difficulty: int = 1,
        prev_levels: list[Level] = [], prev_level_maps: list[Map] = [];

    def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
    -> Level by llm();

    def create_next_map(level: Level) -> Map by llm();

    def get_next_level -> tuple(Level, Map) {
        self.current_level += 1;

        # Keeping Only the Last 3 Levels
        if len(self.prev_levels) > 3 {
            self.prev_levels.pop(0);
            self.prev_level_maps.pop(0);
        }

        # Generating the New Level
        new_level = self.create_next_level(
            self.prev_levels,
            self.current_difficulty,
            20, 20
        );

        self.prev_levels.append(new_level);

        # Generating the Map of the New Level
        new_level_map = self.create_next_map(new_level);
        self.prev_level_maps.append(new_level_map);

        # Increasing the Difficulty for end of every 2 Levels
        if self.current_level % 2 == 0 {
            self.current_difficulty += 1;
        }

        return (new_level, new_level_map);
    }
}
```

### Example: Transaction Function

```jac
def make_transaction(buyer_name: str, seller_name: str, item_name: str, price: int| None = None) -> bool {
    buyer = person_record[buyer_name];
    seller = person_record[seller_name];

    # Find item in seller's inventory
    item_to_buy = None;
    item_index = -1;
    for i in range(len(seller.inventory)) {
        if seller.inventory[i].name.lower() == item_name.lower() {
            item_to_buy = seller.inventory[i];
            item_index = i;
            break;
        }
    }

    price = price or item_to_buy.price;

    # Validate transaction
    if not item_to_buy or buyer.money < price {
        return False;
    }

    # Execute transfer
    buyer.money -= price;
    seller.money += price;
    buyer.inventory.append(item_to_buy);
    seller.inventory.pop(item_index);
    return True;
}
```

### Example: Map Generation Function

```jac
def get_map(map: Map) -> str {
    map_tiles = [['.' for _ in range(map.level.width)] for _ in range(map.level.height)];

    # Place walls
    for wall in map.walls {
        for x in range(wall.start_pos.x, wall.end_pos.x + 1) {
            for y in range(wall.start_pos.y, wall.end_pos.y + 1) {
                map_tiles[y-1][x-1] = 'B';
            }
        }
    }

    # Place obstacles, enemies, and player
    for obs in map.small_obstacles {
        map_tiles[obs.y-1][obs.x-1] = 'B';
    }
    for enemy in map.enemies {
        map_tiles[enemy.y-1][enemy.x-1] = 'E';
    }
    map_tiles[map.player_pos.y-1][map.player_pos.x-1] = 'P';

    # Add border walls
    map_tiles = [['B'] + row + ['B'] for row in map_tiles];
    map_tiles = [['B' for _ in range(map.level.width + 2)]] + map_tiles + [['B' for _ in range(map.level.width + 2)]];
    return [''.join(row) for row in map_tiles];
}
```

## `jac serve` and Function APIs

When `jac serve` is run, all defined functions and walkers in the target Jac module are automatically converted into REST API endpoints.

### API Endpoints

-   **`GET /functions`**: Lists all available functions in the module.
    ```bash
    curl http://localhost:8000/functions \
      -H "Authorization: Bearer YOUR_TOKEN"
    ```
    **Response:**
    ```json
    {
      "functions": ["add_numbers", "greet", "calculate_stats"]
    }
    ```

-   **`GET /function/<name>`**: Retrieves the signature and parameter information for a specific function.
    ```bash
    curl http://localhost:8000/function/add_numbers \
      -H "Authorization: Bearer YOUR_TOKEN"
    ```
    **Response:**
    ```json
    {
      "name": "add_numbers",
      "signature": {
        "parameters": {
          "a": {
            "type": "int",
            "required": true,
            "default": null
          },
          "b": {
            "type": "int",
            "required": true,
            "default": null
          }
        },
        "return_type": "int"
      }
    }
    ```

-   **`POST /function/<name>`**: Calls a function with the provided arguments in the request body.
    ```bash
    curl -X POST http://localhost:8000/function/add_numbers \
      -H "Authorization: Bearer YOUR_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{"args": {"a": 5, "b": 10}}'
    ```
    **Request Body:**
    ```json
    {
      "args": {
        "a": 5,
        "b": 10
      }
    }
    ```
    **Response:**
    ```json
    {
      "result": 15,
      "reports": []
    }
    ```