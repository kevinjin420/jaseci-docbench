# AI Agents

# AI Agents

## Tutorials & Examples

### Tool-calling examples
Examples demonstrating orchestration of external tools (APIs, search, internal tool servers) from Jac/byLLM and coordination of multi-agent workflows.

- `wikipedia_react.jac`
- `marketing_agency.jac`
- `fantasy_trading_game.jac`
- `debate_agent.jac`

### Agentic AI examples
Small agentic patterns and lightweight multi-step reasoning examples (multi-turn planning, simple agents).

- `friendzone_lite.jac`
- `genius_lite.jac`

## AI Agent Characteristics

### AI Functions vs. AI Agents

-   **AI Functions (Stateless):** Perform specific tasks without retaining memory of past interactions.
-   **AI Agents (Stateful):** Maintain persistent state across interactions, building understanding over multiple turns.

### Agent Patterns

#### Agent Loop Example

```jac
with entry {
    // ... character generation and setup ...

    history = [];

    while True {
        // AI agent generates response with state
        chat = chat_with_player(player, npc, history);
        history.append(chat);

        // ... display game state ...

        // Show NPC response and get player input
        print("\n[[npc]] >> ", chat.message);
        inp = input("\n[[Player input]] >> ");
        history.append(Chat(person=player.name, message=inp));
    }
}
```

#### Conversational AI Agent with State and Tools

```jac
def chat_with_player(player: Person, npc: Person, chat_history: list[Chat]) -> Chat
    by llm(method="ReAct", tools=[make_transaction]);
```
-   **Maintains State**: Uses `chat_history` to remember previous interactions.
-   **Reasons**: Processes conversation context using the `ReAct` method.
-   **Acts**: Can use tools like `make_transaction` when appropriate.
-   **Persists Context**: Builds understanding across multiple conversation turns.
-   **Tool Integration**: Accesses application functions (e.g., `make_transaction`) through the `tools` parameter. The AI extracts parameters from natural language, and tool results are incorporated into responses.
-   **State Management**: Achieved through structured data objects (`Person`, `InventoryItem`), conversation history (`Chat` objects), and global registries (`person_record`).

## Specialized Agent Systems

### Aider Genius Lite
A Jac-based Streamlit application for AI-powered code generation with task planning and validation. Demonstrates agentic AI for code generation, understanding, planning, and executing programming tasks autonomously.

### Task Manager Lite
A lightweight AI-powered task management system featuring intelligent routing to specialized handlers.

#### Intelligent Routing
-   Automatically determines the best handler for user requests.
-   Routes to specialized nodes: `TaskHandling`, `EmailHandling`, or `GeneralChat`.
-   Uses AI-powered classification for accurate routing.

#### Nodes
-   **TaskHandling**: Manages task creation, scheduling, and summarization.
-   **EmailHandling**: Handles email content generation.
-   **GeneralChat**: Provides general AI conversation capabilities.

#### Walker
-   **task_manager**: Main walker that routes requests and coordinates responses.

## Development Aids

### Jac Language Context for LLMs
-   **Jac-GPT**: An agentic chatbot for querying Jac documentation.
-   **Include for `.jac` files**:
    ```
    # Jac Language Context
    Include @llmdocs-jaseci-mini_v3.txt when working with .jac files
    ```
-   **Cursor Rules**:
    ```
    When writing Jac code, reference llmdocs-jaseci-mini_v3.txt for syntax
    ```