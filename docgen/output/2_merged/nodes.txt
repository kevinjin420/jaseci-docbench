# Nodes

# Nodes

Nodes represent a vertex or location in a graph, capable of storing data. They are a core archetype in Jac, extending object classes with connectivity capabilities and data-bound computation. Nodes encapsulate data, compute, and the potential for connections, serving as anchoring points in the object-spatial topology of the program.

## Definition

Nodes are defined using the `node` keyword. They can have properties (attributes) and abilities (methods).

```jac
node Person {
    has name: str;
    has age: int;
}
```

### Inheritance

Nodes can inherit from other nodes, gaining their properties and abilities.

```jac
node FriendlyPerson(Person) {
    has name:str; # Can override or add properties
    can greet with Visitor entry {
        print(f"Welcome, visitor");
    }
}
```

## Properties

Node properties are defined using the `has` keyword, followed by the property name and its type. Default values can be assigned.

```jac
node Task {
    has title: str;
    has done: bool = False;
}
```

## Abilities

Nodes can have abilities, which are functions that can be executed when a walker visits the node.

-   An `entry` ability triggers when a walker arrives at a node.
-   An `exit` ability triggers when a walker leaves a node.

```jac
node FriendlyPerson(Person) {
    can greet with Visitor entry {
        print(f"Welcome, visitor");
    }
}
```

Specialized entry abilities can be created to trigger only for specific node or edge types. Abilities have access to the current node (`here`) and walker state.

## Instantiation

Nodes are instantiated like standard objects.

```jac
jonah = Person(16);
```

## Graph Structure

Nodes form the vertices of a graph. They can be connected using edges.

```jac
root ++> jonah;
jonah ++> jonah_mom;
```

The `root` is a special named node in all graphs, serving as the entry point for persistent user state and data.

## Python Interoperability

In Python, Jac nodes are implemented by inheriting from the `jaclang.lib.Node` base class. Data fields are defined using standard Python class attributes with type annotations.

```python
from jaclang.lib import Node

class Person(Node):
    name: str
```

## Visualization and Debugging

Jac includes tools for visualizing nodes and their relationships:

-   **Graph Visualizer**: Makes Jac's spatial programming concepts tangible, showing how objects, walkers, and edges interact.
-   **Jac Lens (PWA)**: Provides an intuitive visual interface for exploring and managing Jac graph data.
    -   Click on nodes to view their properties.
    -   Navigate connections between nodes.
    -   Zoom and pan to explore large graphs.
    -   Search for specific nodes.
    -   Edit node attributes directly in the interface.
    -   View node relationships and connections.
    -   Delete nodes.

Example graph program:

```jac
node Person{
    has age: int;
}

with entry {
    # Create people nodes
    jonah = Person(16);
    sally = Person(17);
    teacher = Person(42);
    jonah_mom = Person(45);

    # Connect Jonah to root
    root ++> jonah;

    # Create Jonah's relationships
    jonah ++> jonah_mom;
    jonah ++> teacher;
    jonah ++> sally;
}
```

```markdown
## Nodes

Nodes are stateful entities that hold data and can react to visitors. They form the fundamental building blocks of a Jac graph.

### Node Definition
Nodes are defined using the `node` keyword, similar to class definitions in OOP. Properties are declared using the `has` keyword.

```jac
node Node {
    has name: str;
}

node EndNode {} # A node without properties
```

### Creating Nodes
Nodes are instantiated like objects.

```jac
with entry {
    node_a = Node(name="A");
}
```

### Graph Entry Point
The `with entry` block marks the program's entry point and creates a root node in the Jac graph, accessible via the `root` variable.

### Connecting Nodes with Edges
Nodes are connected using edges. The `++>` operator creates a directional edge.

```jac
node Node {
    has name: str;
}

with entry {
    node_a = Node(name="A");
    root ++> node_a;  # Connect node_a to the root
}
```

Nodes can be connected in a chain:

```jac
node Node {
    has name: str;
}

node EndNode {}
glob END = EndNode(); # Global end node

with entry {
    node_a = Node(name="A");
    node_b = Node(name="B");

    root ++> node_a;
    node_a ++> node_b;
    node_b ++> END;
}
```

A more concise way to create and connect nodes:

```jac
node Node {
    has name: str;
}

node EndNode {}

with entry {
    node_a = root ++> Node(name="A");
    node_b = node_a ++> Node(name="B");
    node_c = node_b ++> Node(name="C");
    end_node = node_c ++> EndNode();
}
```

### Node Properties
Nodes can have properties, which are defined using `has`. These properties can have default values.

```jac
node Book {
    has title: str;
    has author: str;
    has isbn: str;
    has is_borrowed: bool = False;
    has borrowed_date: str = "";
}
```

### Node Methods
Nodes can define methods using the `def` keyword. `self` refers to the current node instance.

```jac
import:py from datetime { datetime }

node Book {
    has is_borrowed: bool = False;
    has borrowed_date: str = "";

    def borrow(member_id: str) -> bool {
        if not self.is_borrowed {
            self.is_borrowed = True;
            self.borrowed_date = datetime.now().isoformat();
            return True;
        }
        return False;
    }

    def return_book() -> bool {
        if self.is_borrowed {
            self.is_borrowed = False;
            self.borrowed_date = "";
            return True;
        }
        return False;
    }
}
```

### Spawning Walkers on Nodes
Walkers can be spawned on nodes to traverse the graph.

```jac
node Node {
    has name: str;
}

node EndNode {}
glob END = EndNode();

walker PathWalker {
    has input: str;

    can start with `root entry {
        visit [-->];
    }

    can visit_node with Node entry {
        self.input += ", visiting " + here.name;
        visit [here-->];
    }

    can visit_end with EndNode entry {
        self.input += ", reached the end";
        return;
    }
}

with entry {
    root ++> Node(name="A")
         ++> Node(name="B")
         ++> END;

    my_walker = PathWalker(input="Start walking") spawn root;

    print(my_walker.input);
}
```

### Node Traversal and Filtering
Nodes can be traversed and filtered using graph traversal syntax.

```jac
node Library {
    has name: str;

    def find_available_books() -> list[Book] {
        all_books = [self --Contains--> Book];
        borrowed_books = [self --Contains--> Book --BorrowedBy--> Member];
        return [book for book in all_books if book not in borrowed_books];
    }

    def find_member_books(member_id: str) -> list[Book] {
        target_member = [self --Contains--> Member](?member_id == member_id);
        if target_member {
            return [target_member[0] <--BorrowedBy-- Book];
        }
        return [];
    }
}
```
```


# Nodes

Nodes are fundamental building blocks in Jac, representing entities or data locations within a graph. They can store properties, define behaviors (abilities), and participate in relationships via edges.

## Node Definition

Nodes are defined using the `node` keyword, optionally inheriting from other nodes. They can declare properties using `has` and define methods or abilities using `can` or `def`.

```jac
node NodeName {
    // Properties
    has property_name: type = default_value;

    // Abilities (triggered by walkers)
    can ability_name with WalkerType entry {
        // Code to execute when WalkerType visits this node
    }

    // Methods
    def method_name(param: type) -> return_type {
        // Method implementation
    }
}
```

### Node Properties

Nodes can store data using `has` declarations. These properties are type-safe and can have default values.

```jac
node Teacher {
    has name: str;
    has subject: str;
    has years_experience: int;
    has email: str;
}

node Classroom {
    has room_number: str;
    has capacity: int;
    has has_projector: bool = True;
}
```

### Node Abilities

Nodes can define `can` abilities that are triggered when a specific type of walker (`WalkerType`) visits them. The `visitor` keyword refers to the walker currently on the node.

```jac
node Weather {
    has temp: int = 80;

    can get with StateAgent entry {
        visitor.state["temperature"] = self.temp;
    }
}

node NPC {
    can get with StateAgent entry {
        visitor.state["npc_mood"] = get_ambient_mood(visitor.state);
    }
}
```

### Node Methods

Nodes can define `def` methods for encapsulating behavior.

```jac
node Person {
    has name: str;
    has age: int;
    has friend_count: int = 0;

    def add_friend(friend: Person) -> bool {
        existing = [self --> Friend --> Person](?name == friend.name);
        if existing {
            return false;
        }
        friendship = Friend(since="2024-01-15");
        self ++> friendship ++> friend;
        self.friend_count += 1;
        friend.friend_count += 1;
        return true;
    }
}
```

## Node Inheritance

Nodes can inherit properties and abilities from other nodes, promoting code reuse and defining common interfaces.

```jac
node Service {}

node Weather(Service) {
    has temp: int = 80;
    can get with StateAgent entry {
        visitor.state["temperature"] = self.temp;
    }
}

node Time(Service) {
    has hour: int = 12;
    can get with StateAgent entry {
        visitor.state["time"] = f"{self.hour}:00 PM";
    }
}
```

## Node Types and Examples

### Core Nodes

*   **`root`**: The base node of the graph. Nodes connected to `root` automatically persist.
*   **`Node`**: The base type for all custom nodes.

### Common Node Patterns

*   **Data Storage**: Nodes for storing specific data.
    ```jac
    node ChatRoom {
        has name: str;
        has users: list[str] = [];
        has message_count: int = 0;
    }

    node ChatMessage {
        has content: str;
        has sender: str;
        has timestamp: str;
        has room_name: str;
        has id: str = "msg_" + str(uuid4());
    }

    node WebhookLog {
        has source: str;
        has event_type: str;
        has data: dict;
        has received_at: str;
    }

    node LogEntry {
        has level: str;
        has message: str;
        has timestamp: str;
        has context: dict = {};
    }

    node TaskCounter {
        has val: int = 0;
    }

    node Note {
        has title: str;
        has content: str;
        has owner: str;
        has shared_with: list[str] = [];
        has is_public: bool = False;
        has permissions: dict = {"read": True, "write": False};
        has id: str = "note_" + str(uuid.uuid4());
    }

    node UserProfile {
        has email: str;
        has role: Role = Role.VIEWER;
        has created_at: str = "2024-01-15";
    }
    ```

*   **Cached Data**: Nodes can cache computed values for quick access.
    ```jac
    node Person {
        has name: str;
        has age: int;
        has friend_count: int = 0; // Cached for quick access
    }

    node CacheEntry {
        has depth: int;
        has friend_names: list[str];
        has computed_at: str;
    }
    ```

*   **Memory Optimized**: Nodes can be designed to be lightweight by calculating data on-demand rather than caching.
    ```jac
    node LightPerson {
        has name: str;
        has age: int;

        def get_friend_count() -> int {
            return len([self --> (`?Friend) --> (`?LightPerson)]);
        }

        def get_connections_summary() -> dict {
            friends = [self --> (`?Friend) --> (`?LightPerson)];
            return {
                "friend_count": len(friends),
                "avg_age": sum(f.age for f in friends) / len(friends) if friends else 0,
                "friend_names": [f.name for f in friends[:5]]
            };
        }
    }
    ```

## Node Operations

### Node Creation and Connection

Nodes are created by calling their constructor and can be connected to other nodes using graph operators.

```jac
with entry {
    science_lab = root ++> Classroom(
        room_number="Lab-A",
        capacity=24,
        has_projector=True
    );

    dr_smith = science_lab +>:Teaches(
        start_date="2024-08-01",
        schedule="TR 10:00-11:30"
    ):+> Teacher(
        name="Dr. Smith",
        subject="Chemistry",
        years_experience=12,
        email="smith@school.edu"
    );
}
```

### Accessing Node Properties

Node properties are accessed using dot notation.

```jac
print(dr_smith.name);
```

### Node Edges

The `.edges` property of a node provides access to its connected edges.

### Spawning Walkers on Nodes

Walkers can be spawned on individual nodes or lists of nodes/edges.

```jac
agent = StateAgent() spawn root;
agent = StateAgent() spawn [node1, node2, edge1]; // Spawning on a list
```

### Node Access Validation

Nodes can override the `__jac_access__` reserved function to implement custom access validation logic.

### Node Permissions

Built-in methods `grant` and `revoke` are used to manage permissions on nodes.
Permissions include `NoPerm`, `ReadPerm`, `ConnectPerm`, `WritePerm`.

```jac
grant(node_1, ConnectPerm);
revoke(node_1);
```

## Webhook Node Restrictions

Webhooks can be configured to restrict access to specific nodes.

```python
{
  "name": "webhook1",
  "walkers": ["webhook"],
  "nodes": ["root"], # Only 'root' node is accessible
  "expiration": {
    "count": 60,
    "interval": "days"
  }
}
```

# Nodes

Nodes are archetypes forming part of a graph, holding properties. They can be compared to custom classes in object-oriented programming (OOP). Each node can have `attributes` (like fields in a class) and `abilities` (similar to methods in OOP).

## Node Definition

```jac
node node_name {
    has node_property: int;
}
node node_name {
    has node_property: int = 10;
}
```

## Node Properties

-   `id`: The database identifier.
-   `name`: The name of the associated archetype.
-   `root`: The owning root anchor.
-   `access`: Permissions defining which nodes or roots can access this anchor.
-   `archetype`: The JSON representation of the actual archetype.
-   `.edges`: Property to access connected edges.

## Node Abilities

Abilities are similar to methods in OOP.

### Callable Abilities

Standard methods in OOP. `self` refers to the node itself.

```jac
node Node {
    def callable {
        print(f"===== Callable on {self}");
    }
}
```

### Visit-Dependent Abilities

Triggered when a specific type of walker interacts with the node.
-   `self`: References the node itself.
-   `visitor`: References the walker context within nodes/edges.
-   `here`: In walker abilities, `here` refers to the current node/edge.

```jac
node Node {
    has val: str;

    can entry1 with entry {
        print(f"{self.val}-2");
    }

    can entry2 with Walker entry {
        print(f"{self.val}-3");
    }

    can exit1 with Walker exit {
        print(f"{self.val}-4");
    }

    can exit2 with exit {
        print(f"{self.val}-5");
    }
}
```

Example with `visitor` and `here`:

```jac
node test_node {
    has value: int;

    can log_entry with entry {
        print(f">>> Some Walker entered the node: ", self);
    }
    can log_test_walker_entry with test_walker entry {
        print(f">>> {visitor} entered the node {self}"); // visitor refers to the walker
        visitor.callable();
    }
    can log_test_walker_exit with test_walker exit {
        print(f"<<< {visitor} exited the node {self}");
    }
    can log_exit with exit {
        print(f"<<< Some Walker exited the node {self}");
    }
    def callable {
        print(f"===== Callable on {self}");
    }
}
```

## Node Access Control (`__jac_access__`)

Defines permissions for accessing a node.

```jac
node A {
    def __jac_access__ {
        // Allowed string return: NoPerm, ReadPerm, ConnectPerm, or WritePerm
        return NoPerm;

        // Allowed enum return: AccessLevel.NO_ACCESS, AccessLevel.READ, AccessLevel.ConnectPerm, AccessLevel.WRITE
        // return AccessLevel.NO_ACCESS;

        // Not recommended: Allowed int return -1 (NoPerm), 0 (ReadPerm), 1 (ConnectPerm), 2 (WritePerm)
        // return -1;
    }
}
```

To check access level without triggering custom validation (to avoid infinite loops):

```jac
node A {
    def __jac_access__ {
        level = _Jac.check_access_level(here, True); // True means skip custom access validation trigger
        return "NO_ACCESS";
    }
}
```

## Connecting Nodes

Nodes can establish connections in various ways:

### One-to-One

```jac
node MyNode{}

with entry{
    first_node = MyNode();
    second_node = MyNode();

    root ++> first_node;
    first_node ++> second_node;
}
```

### One-to-Many

```jac
node MyNode{}

with entry{
    first_node = MyNode();
    second_tier = [MyNode() for i in range(2)];

    root ++> first_node;
    first_node ++> second_tier; // one to many
}
```

### Many-to-One

```jac
node MyNode{}

with entry{
    first_tier = [MyNode() for i in range(2)];
    second_node = MyNode();
    root ++> first_tier;
    first_tier ++> second_node; // many to one
}
```

### Many-to-Many

```jac
node MyNode{}

with entry{
    first_tier =[MyNode() for i in range(2)];
    second_tier =[MyNode() for i in range(2)];

    root ++> first_tier;
    first_tier ++> second_tier;

    end_tier = MyNode();
    second_tier ++> end_tier;
}
```

## Node Deletion

```jac
del node_name;
```

## Node Filtering

JacLang provides flexible filtering mechanisms for nodes and edges.

### Filtering by Type and Attributes

```jac
print([root --> -:edge_type:-> (`?NodeType)]);
print([root --> -:edge_type:-> (`?NodeType)](?attribute > value));
```

Example:
```jac
node a{
    has val:int;
}
with entry{
    end=root;
    for i in range(0,4){
        end++>(end:=[a(val=i) for i in range(0,3)]);
    }
    print(printgraph());
}
```

### Filtering by Edge Attributes

```jac
// Example of filtering nodes based on specific edge attributes
// (Conceptual, specific syntax depends on traversal context)
// For instance, a walker might filter its path based on edge properties.
```

## Node Serialization

Jac Cloud automatically serializes walker, edge, and node archetypes into JSON.

```json
{
    "id": "unique_anchor_reference_id",
    "context": {
        "attribute1": "value1",
        "attribute2": "value2"
    }
}
```

## Node Data Structure in JSON Output

```json
{
  "nodes": [
    {
      "id": "n::68875f383d1e672f517094ff",
      "edges": ["e::68875f483d1e672f517096a5"]
    },
    {
      "id": "n:A:68875f483d1e672f517096a0",
      "edges": ["e::68875f483d1e672f517096a2", "e::68875f483d1e672f517096a5"]
    },
    {
      "id": "n:B:68875f483d1e672f517096a1",
      "edges": ["e::68875f483d1e672f517096a2", "e::68875f483d1e672f517096a4"]
    },
    {
      "id": "n:C:68875f483d1e672f517096a3",
      "edges": ["e::68875f483d1e672f517096a4"]
    }
  ]
}
```

## Walker Execution on Nodes

-   **Node Entry Endpoint**: `/walker/{walker_name}/{node_id}` executes a walker on a specific node.
-   `node_id`: ID of the node where the walker was executed.
-   `root_id`: ID of the root node of the user who triggered the walker.

## Standard Library

### `file` Module

-   `open(path: str) -> File`

### `json` Module

-   `dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False) -> str`
-   `loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None) -> Any`

### `os` Module

(No specific functions mentioned for nodes, but generally available for file system operations.)

### `logging` Module

(No specific functions mentioned for nodes, but generally available for logging.)

## Syntax Variants

-   `import:py from json {dumps};` (Python imports)
-   `spawn` (including spawning on lists/groups of nodes/edges)
-   `has x: type` (Explicit type annotations)
-   `&` (Reference operator)
-   `.edges` (Node property)
-   `str "..."` (Semantic String)
-   `async`, `await`
-   `assert` (Testing/Validation)
-   `save`, `load` (Persistence)

## Agent Patterns

```jac
// Example of an Agent Loop (conceptual, specific implementation varies)
walker AgentWalker {
    can init {
        // Initialize agent state
    }
    can live {
        while (by llm()) { // Loop driven by LLM
            // Agent logic here
            // Interact with nodes, make decisions, etc.
        }
    }
}
```

# Nodes

Nodes represent locations where compute and logic execute. They hold data (attributes) and can have special abilities that trigger on preset events. In an agentic system, nodes can act as agents, maintaining local state and responding to visitor events.

## Node Definition

Nodes are defined using the `node` keyword, followed by the node name and a block containing its attributes and abilities.

```jac
node NodeName {
  has attribute_name: type = default_value;
  // ... abilities
}
```

### Node Attributes

Node attributes store data. They can have type annotations and default values.

```jac
node User {
    has username: str;
}

node Tweet {
    has content: str;
    has embedding: list;
    has created_at: str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S");
}
```

### Node Abilities

Abilities define behavior that can be triggered on a node.

-   `can <attributeName> with <nodeType> entry`: Assigns walker behavior when it is on the node type. The `root` node must have `` `root ``.

```jac
node Profile {
    has username: str = "";

    can update with update_profile entry;
    can get with get_profile entry;
    can follow with follow_request entry;
    can un_follow with un_follow_request entry;
}
```

## Special Node Types

### Root Node

The `root` node is a fundamental global pointer on the graph, always accessible in every request context. All other nodes should be directly or indirectly connected to the root node to ensure accessibility.

-   Each user in a multi-user system can have their own persistent root node, isolating their graph spaces.
-   Requests execute in the context of the authenticated user's root node.

### Agent Nodes

Agent nodes are specialized nodes that can leverage LLMs and tools to perform complex tasks. They often follow a pattern of defining methods as tools and using an `entry` ability to orchestrate their behavior when visited by a walker.

#### `node Task`

A simple data structure for storing individual tasks.

```jac
node Task {
  has task:str = "";
  has date:str = "";
  has time:str = "";
}
```

#### `node TaskHandling`

Manages task creation, scheduling, and summarization. It demonstrates a specialized agent with tools and LLM reasoning.

```jac
node TaskHandling {
  def get_current_time() -> str {
    return time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime());
  }

  def add_task(task: str, date: str, time: str) -> str {
    task_created = Task(task=task, date=date, time=time);
    self ++> task_created;
    return "Task added successfully";
  }

  def summarize_tasks -> str {
    scheduled_tasks = [self-->(`?Task)];
    return str(scheduled_tasks);
  }

  def route_and_run(utterance: str) -> str by llm(
    method="ReAct",
    tools=([self.add_task, self.get_current_time, self.summarize_tasks])
  );

  can execute with task_manager entry {
    print("[TaskHandling Node Activated]");
    response = self.route_and_run(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### `node EmailHandling`

Handles email content generation.

```jac
node EmailHandling {
  def write_email_content(utterance: str) -> str by llm();
  def route_and_run(utterance: str) -> str by llm(
    method="ReAct",
    tools=([self.write_email_content])
  );
  can execute with task_manager entry {
    print("[EmailHandling Node Activated]");
    response = self.route_and_run(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

#### `node GeneralChat`

Provides general AI conversation capabilities.

```jac
node GeneralChat {
  def chat(utterance: str) -> str by llm();
  can execute with task_manager entry {
    print("[GeneralChat Node Activated]");
    response = self.chat(visitor.cur_task.task);
    print("→", response);
    report {
      "utterance": visitor.cur_task.task,
      "response": response,
      "node_type": self.__class__.__name__
    };
  }
}
```

## Node Relationships and Edges

Nodes are connected via edges, forming a graph structure.

-   **Parent-child relationships:** Established through edges, allowing nodes to maintain local knowledge of related nodes.
    ```jac
    self ++> task_created;
    ```
-   **Directed Edges:** Edges can be directed, indicating a flow or relationship from one node to another.
    ```jac
    senderNode ++> emailNode;
    for node in recipientNodes{
        emailNode ++> node;
    }
    ```
-   `.edges`: A node property that provides access to its connected edges.

## Node Persistence

-   `save`: Persists the current state of the graph or specific nodes.
-   `load`: Loads a previously saved graph state.

## Common Pitfalls

-   **Forgot to connect nodes to root:** Walker cannot find anything.
    *   **Fix:** `root ++> newNode`
-   **Walker doesn't do anything after spawn:** Attribute undefined for node type.
    *   **Fix:** `can <attrName> with <nodeType> entry`