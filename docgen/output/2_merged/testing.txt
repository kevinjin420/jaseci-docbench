# Testing

## Testing

Jac provides a powerful testing framework that automatically discovers and runs tests. When you run `jac test myfile.jac`, it automatically looks for `myfile.test.jac` and executes all test blocks within it.

-   **Automatic Discovery**: `.test.jac` files are automatically found and executed
-   **Graph-Aware Testing**: Native support for testing spatial relationships
-   **Walker Testing**: Test mobile computation patterns naturally
-   **Type-Safe Assertions**: Leverage Jac's type system in test validation
-   **Zero Configuration**: No external testing frameworks required

### Keywords

-   `test`: Defines test cases for code validation and unit testing.

### Library Functions

-   `jac_test(func)`: Marks a function as a test.
    -   `func`: The test function.
-   `run_test(filepath, ...)`: Runs a test suite.
    -   `filepath`: Path to the test file.
    -   `func_name`, `filter`, `xit`, `maxfail`, `directory`, `verbose`: Test options.
-   `report(expr, custom)`: Reports a value from a walker.
    -   `expr`: Value to report.
    -   `custom`: Custom report flag.
-   `printgraph(node, depth, traverse, edge_type, bfs, edge_limit, node_limit, file, format)`: Generates a graph visualization.
    -   `node`: Start node.
    -   `depth`: Maximum depth.
    -   `traverse`: Traversal flag.
    -   `edge_type`: Filter edges.
    -   `bfs`: Breadth-first flag.
    -   `edge_limit`, `node_limit`: Limits.
    -   `file`: Output path.
    -   `format`: 'dot' or 'mermaid'.

### Test Execution

```bash
# Run tests locally
--8<-- "scripts/tests.sh"
```

### Example Test Suite Locations

| Test Suite | Location | Coverage |
| :--------- | :------- | :------- |
| **Client codegen tests** | `jaclang/compiler/tests/test_client_codegen.py` | `cl` keyword detection, manifest generation |
| **ESTree generation tests** | `jaclang/compiler/passes/ecmascript/tests/test_esast_gen_pass.py` | JavaScript AST generation |
| **JavaScript generation tests** | `jaclang/compiler/passes/ecmascript/tests/test_js_generation.py` | JS code output from ESTree |
| **Client bundle tests** | `jaclang/runtimelib/tests/test_client_bundle.py` | Bundle building, caching, import resolution |
| **Server endpoint tests** | `jaclang/runtimelib/tests/test_serve.py` | HTTP endpoints, page rendering |
| **JSX rendering tests** | `jaclang/runtimelib/tests/test_jsx_render.py` | JSX parsing and rendering |
| **Reactive signals tests** | `jaclang/runtimelib/tests/test_reactive_signals.py` | Signal creation, effects, dependency tracking |
| **Router tests** | `jaclang/runtimelib/tests/test_router.py` | Routing, navigation, route guards |
| **Closures tests** | `jaclang/runtimelib/tests/test_closures.py` | Nested functions, closure semantics in JavaScript |

### Testing AI Integrations

```jac
# robust_ai.jac
import from byllm.lib { Model, Image }

glob reliable_llm = Model(model_name="gpt-4o", max_tries=3);

obj RobustCaptioner {
    has fallback_enabled: bool = True;

    """Generate caption with error handling."""
    def safe_caption(image_path: str) -> dict {
        try {
            caption = self.generate_caption_ai(image_path);
            return {
                "success": True,
                "caption": caption,
                "source": "ai"
            };
        } except Exception as e {
            if self.fallback_enabled {
                fallback_caption = f"Image analysis unavailable for {image_path}";
                return {
                    "success": False,
                    "caption": fallback_caption,
                    "source": "fallback",
                    "error": str(e)
                };
            } else {
                raise e;
            }
        }
    }

    """AI-powered caption generation."""
    def generate_caption_ai(image_path: str) -> str by reliable_llm();

    """Validate generated content."""
    def validate_caption(caption: str) -> bool {
        # Basic validation rules
        if len(caption) < 10 {
            return False;
        }
        if "error" in caption.lower() {
            return False;
        }
        return True;
    }
}

with entry {
    captioner = RobustCaptioner(fallback_enabled=True);

    # Test with different scenarios
    test_images = [
        Image("valid_photo.jpg"),
        Image("corrupted.jpg"),
        Image("missing.jpg")
    ];

    for image in test_images {
        result = captioner.safe_caption(image);

        if result["success"] {
            is_valid = captioner.validate_caption(result["caption"]);
            print(f"{image}: {result['caption']} (Valid: {is_valid})");
        } else {
            print(f"{image}: Failed - {result['error']}");
        }
    }
}
```

### Creating Test Data

```jac
# test_data_generator.jac
import from random { randint, choice }

walker generate_test_network {
    has person_count: int = 100;
    has avg_friends: int = 5;

    can create_test_network with `root entry {
        # Clear existing test data
        existing_persons = [-->](`?LightPerson);
        existing_friends = [-->](`?Friend);

        for person in existing_persons {
            del person;
        }
        for friendship in existing_friends {
            del friendship;
        }

        # Create people
        people = [];
        for i in range(self.person_count) {
            person = LightPerson(
                name=f"Person{i}",
                age=randint(18, 65)
            );
            here ++> person;
            people.append(person);
        }

        # Create friendships
        total_friendships = 0;
        for person in people {
            friends_to_add = randint(1, self.avg_friends * 2);

            for _ in range(friends_to_add) {
                potential_friend = choice(people);
                if potential_friend != person {
                    # Check if friendship already exists
                    existing = [person --> Friend --> LightPerson](?name == potential_friend.name);
                    if not existing {
                        friendship = Friend(since="2024-01-15");
                        person ++> friendship ++> potential_friend;
                        total_friendships += 1;
                    }
                }
            }
        }

        report {
            "people_created": len(people),
            "friendships_created": total_friendships,
            "avg_friends_per_person": round(total_friendships * 2 / len(people), 2)
        };
    }
}
```

### Testing Performance

```bash
# Deploy the optimized version
jac serve distributed_friends.jac

# Generate test data
curl -X POST http://localhost:8000/walker/generate_test_network \
  -H "Content-Type: application/json" \
  -d '{"person_count": 1000, "avg_friends": 10}'

# Run performance benchmarks
curl -X POST http://localhost:8000/walker/run_performance_suite \
  -H "Content-Type: application/json" \
  -d '{"test_count": 5, "test_persons": ["Person1", "Person50", "Person100"]}'

# Check system health
curl -X POST http://localhost:8000/walker/performance_health_check \
  -H "Content-Type: application/json" \
  -d '{}'
```

### Testing Service Endpoints

```bash
# Test as service locally
jac serve weather_api.jac --port 8000

# Test the endpoints
curl -X POST http://localhost:8000/walker/get_weather \
  -H "Content-Type: application/json" \
  -d '{"city": "New York"}'
```

```bash
# Test with docker-compose
echo "WEATHER_API_KEY=your-key" > .env
docker-compose up -d

# Test the containerized API
curl -X POST http://localhost:8000/walker/get_weather \
  -H "Content-Type: application/json" \
  -d '{"city": "London"}'

# Check health
curl -X POST http://localhost:8000/walker/health_check \
  -H "Content-Type: application/json" \
  -d '{}'
```

```bash
# Test the service
kubectl port-forward service/weather-api-service 8080:80 -n weather-app

# Test from another terminal
curl -X POST http://localhost:8080/walker/get_weather \
  -H "Content-Type: application/json" \
  -d '{"city": "Tokyo"}'
```

```bash
# Load testing (using hey or similar)
hey -n 1000 -c 10 -m POST \
  -H "Content-Type: application/json" \
  -d '{"city":"London"}' \
  http://your-service-url/walker/get_weather
```

```bash
# Join a room first
curl -X POST http://localhost:8000/walker/join_room \
  -H "Content-Type: application/json" \
  -d '{"room_name": "general", "username": "alice"}'

# Send a message
curl -X POST http://localhost:8000/walker/send_message \
  -H "Content-Type: application/json" \
  -d '{"room_name": "general", "username": "alice", "message": "Hello everyone!"}'

# Get chat history
curl -X POST http://localhost:8000/walker/get_chat_history \
  -H "Content-Type: application/json" \
  -d '{"room_name": "general", "limit": 10}'
```

```bash
curl -X POST http://localhost:8000/walker/receive_webhook \
  -H "Content-Type: application/json" \
  -d '{
    "source": "github",
    "event_type": "push",
    "data": {
      "repository": {"name": "my-repo"},
      "commits": [{"message": "Fix critical bug"}]
    }
  }'
```

```bash
# Run cleanup manually
curl -X POST http://localhost:8000/walker/cleanup_inactive_rooms \
  -H "Content-Type: application/json" \
  -d '{"max_age_hours": 48}'

# Generate daily stats
curl -X POST http://localhost:8000/walker/generate_daily_stats \
  -H "Content-Type: application/json" \
  -d '{}'
```

### Testing Migrations

```python
# test_book.py
book = Book("The Great Gatsby", "F. Scott Fitzgerald", "123456789")
print(book.get_info())  # The Great Gatsby by F. Scott Fitzgerald - Available

success = book.borrow()
print(f"Borrowed: {success}")  # Borrowed: True
print(book.get_info())  # The Great Gatsby by F. Scott Fitzgerald - Borrowed
```

```jac
# test_book.jac
with entry {
    book = Book(title="The Great Gatsby", author="F. Scott Fitzgerald", isbn="123456789");
    print(book.get_info());  # The Great Gatsby by F. Scott Fitzgerald - Available

    success = book.borrow();
    print(f"Borrowed: {success}");  # Borrowed: True
    print(book.get_info());  # The Great Gatsby by F. Scott Fitzgerald - Borrowed
}
```

### Testing Environment Variables

```bash
# Configuration for testing
export DATABASE_NAME="test_db"
export LOGGER_LEVEL="debug"
export TOKEN_TIMEOUT="1"  # Short-lived tokens for testing
export REQUIRE_AUTH_BY_DEFAULT="false"  # Disable auth for easier testing
```

# Testing

## `assert` Keyword

The `check` keyword has been removed. All testing functionality is now unified under `assert` statements.

-   In regular code, `assert` raises `AssertionError` exceptions.
-   Within `test` blocks, `assert` reports test failures to the testing framework.

**Example (Before `check` removal):**
```jac
glob a: int = 5;
glob b: int = 2;

test test_equality {
    check a == 5;
}
```

**Example (Using `assert` in a test block):**
```jac
# Test functionality
test create_tweet {
    root spawn create_tweet(content = "Hello World");
    tweet = [root --> (?Profile) --> (?Tweet)][0];
    assert tweet.content == "Hello World";
}
```

## Running Tests

### `jac test` command

The `jac test` command is used to run the test suite in a specified `.jac` file.

```bash
jac test <file_path>
```

**Parameters:**
-   `file_path`: The path to the `.jac` file containing tests.

**Example:**
```bash
jac test littleX.jac
```

### `jac run` command

The `jac run` command executes a Jaclang file. This can be used for scripts that perform testing or validation logic.

**Example:**
```bash
jac run test_generator.jac
```

```jac
import from level_manager { LevelManager }

with entry {
    level_manager = LevelManager();

    print("Generating 3 AI-powered levels...\n");

    for i in range(3) {
        level, map_obj = level_manager.get_next_level();
        visual_map = level_manager.get_map(map_obj);

        print(f"=== LEVEL {i+1} ===");
        print(f"Difficulty: {level.difficulty}");
        print(f"Enemies: {level.num_enemies}");
        print(f"Walls: {level.num_wall}");
        print("Map:");
        for row in visual_map {
            print(row);
        }
        print("\n");
    }
}
```

## Testing `by llm()` Plugins

### Jaclang Test File for Plugins

```jaclang
import:py from byllm, Model;

glob llm = Model(model_name="gpt-3.5-turbo");

can test_plugin {
    result = get_answer("What is 2+2?") by llm();
    print(result);
}

can get_answer(question: str) -> str by llm();

with entry {
    test_plugin();
}
```

### Python `pytest` for Plugins

```python
import pytest
from byllm.llm import Model
from my_byllm_plugin.plugin import MybyllmRuntime

def test_plugin():
    runtime = MybyllmRuntime()
    model = Model("mockllm", outputs=["test response"])

    def test_function(x: str) -> str:
        """Test function."""
        pass

    result = runtime.call_llm(model, test_function, {"x": "test input"})
    assert result == "test response"
```

## API Testing with `curl`

### Counter Persistence Example

```bash
# First request - Create counter
curl -X POST http://localhost:8000/walker/get_counter \
  -H "Content-Type: application/json" \
  -d '{}'
# Response: {"returns": [{"value": 0, "status": "created"}]}

# Increment the counter
curl -X POST http://localhost:8000/walker/increment_counter \
  -H "Content-Type: application/json" \
  -d '{}'
# Response: {"returns": [{"value": 1, "previous": 0}]}

# Increment again
curl -X POST http://localhost:8000/walker/increment_counter \
  -H "Content-Type: application/json" \
  -d '{}'
# Response: {"returns": [{"value": 2, "previous": 1}]}

# Check counter value
curl -X POST http://localhost:8000/walker/get_counter \
  -H "Content-Type: application/json" \
  -d '{}'
# Response: {"returns": [{"value": 2, "status": "existing"}]}

# Restart the service (Ctrl+C, then jac serve main.jac again)

# Counter value persists after restart
curl -X POST http://localhost:8000/walker/get_counter \
  -H "Content-Type: application/json" \
  -d '{}'
# Response: {"returns": [{"value": 2, "status": "existing"}]}
```

### User Authentication Example

```bash
# Create a note for Alice
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Alice Private Note",
    "content": "Secret content",
    "owner": "alice@example.com"
  }'

# Create a note for Bob
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Bob Note",
    "content": "Bob content",
    "owner": "bob@example.com"
  }'

# Get Alice's notes only
curl -X POST http://localhost:8000/walker/list_my_notes \
  -H "Content-Type: application/json" \
  -d '{"user_id": "alice@example.com"}'
```

### Note Sharing Example

```bash
# Alice creates a note
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Team Project",
    "content": "Project details",
    "owner": "alice@example.com"
  }'

# Alice shares note with Bob
curl -X POST http://localhost:8000/walker/share_note \
  -H "Content-Type: application/json" \
  -d '{
    "note_id": "note_123",
    "current_user": "alice@example.com",
    "target_user": "bob@example.com"
  }'

# Bob views accessible notes
curl -X POST http://localhost:8000/walker/get_accessible_notes \
  -H "Content-Type: application/json" \
  -d '{"user_id": "bob@example.com"}'
```

### Role-Based Access Example

```bash
# Check user role
curl -X POST http://localhost:8000/walker/check_user_role \
  -H "Content-Type: application/json" \
  -d '{"user_id": "alice@example.com"}'

# Create a note requiring editor role
curl -X POST http://localhost:8000/walker/create_role_based_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Editor Note",
    "content": "Only editors can see this",
    "owner": "alice@example.com",
    "required_role": "editor",
    "is_sensitive": true
  }'

# Get notes filtered by role
curl -X POST http://localhost:8000/walker/get_role_filtered_notes \
  -H "Content-Type: application/json" \
  -d '{"user_id": "alice@example.com"}'
```