# Graph Structure

# Graph Structure

Jac introduces Object-Spatial Programming (OSP), a programming model that allows developers to articulate relationships between objects in a graph-like structure. Computation is expressed as "walkers" that traverse this graph. This model is particularly effective for applications involving connected data, such as social networks, knowledge graphs, or file systems, and can greatly reduce code complexity. OSP also provides the foundation for agentic workflows and enables Jaseci’s scale-native execution.

Jac is designed as a superset of Python, extending the language with additional features for graph-based and AI-first programming while maintaining full compatibility with the Python ecosystem.

## Core Concepts

### Nodes and Edges

Instances of node and edge classes form a graph structure that expresses semantic relationships between objects. `root` is a special named node in all graphs.

```jac
node Person{
    has age: int;
}

with entry {
    # Create people nodes
    jonah = Person(16);
    sally = Person(17);
    teacher = Person(42);
    jonah_mom = Person(45);

    # Connect Jonah to root
    root ++> jonah;

    # Create Jonah's relationships
    jonah ++> jonah_mom;
    jonah ++> teacher;
    jonah ++> sally;
}
```

Edges can be created using various syntax:

```jac
root ++> alice ++> bob ++> charlie;
root ++> f ++> a;
```

### Walkers

Walkers are special objects that can move through your graph, carrying state and executing abilities when they encounter different types of nodes and edges. They are mobile computational entities that traverse graphs.

-   **Traversal control**: Fine-grained control over movement patterns.
-   **Spawning mechanism**: Activate walkers at specific graph locations.
-   **Graph analysis**: Analyze relationships and connections.
-   **State propagation**: Update related nodes based on changes.

Walkers move through graphs using `spawn` (to start) and `visit` (to continue to connected nodes). They can control their movement through the graph using statements like `visit` and `disengage`.

```jac
# Example of a walker traversing a chain of nodes
# The walker moves with `visit [-->]` and stops via `disengage` when the guess is correct.
# The game is launched by `spawn`ing the walker at `root`.
```

### Graph Traversal and Filtering

Complex graph operations become intuitive when you move computation to data. Walkers intelligently navigate only the relevant portions of your graph, making sophisticated queries both efficient and expressive. Advanced filtering combines relationship traversal, node properties, and complex conditions.

```jac
with entry {
    # Create a social network
    alice = root ++> Person(name="Alice", age=25, city="NYC");
    bob = root ++> Person(name="Bob", age=30, city="SF");
    charlie = root ++> Person(name="Charlie", age=22, city="NYC");
    diana = root ++> Person(name="Diana", age=28, city="LA");

    # Create friendships
    alice +>:FriendsWith(since="2020", closeness=8):+> bob;
    alice +>:FriendsWith(since="2021", closeness=9):+> charlie;
    bob +>:FriendsWith(since="2019", closeness=6):+> diana;

    # Find all young people in NYC (age < 25)
    nyc = [root-->(`?Person)](?city == "NYC");
    print("People in NYC:");
    for person in nyc {
        print(f"  {person.name}, age {person.age}");
    }
    young_nyc = nyc(?age < 25);
    print("Young people in NYC:");
    for person in young_nyc {
        print(f"  {person.name}, age {person.age}");
    }

    # Find Alice's close friends (closeness >= 8)
    close_friends = [alice->:FriendsWith:closeness >= 8:->(`?Person)];
    print(f"Alice's close friends:");
    for friend in close_friends {
        print(f"  {friend.name}");
    }

    # Find all friendships that started before 2021
    old_friendships = [root->:FriendsWith:since < "2021":->];
    print(f"Old friendships: {len(old_friendships)} found");
}
```

```jac
with entry {
    # Create extended family network
    john = root ++> Person(name="John", age=45, city="NYC");
    emma = root ++> Person(name="Emma", age=43, city="NYC");
    alice = root ++> Person(name="Alice", age=20, city="SF");
    bob = root ++> Person(name="Bob", age=18, city="NYC");

    # Family relationships
    john +>:FriendsWith(since="1995", closeness=10):+> emma;  # Married
    [john[0], emma[0]] +>:FriendsWith(since="2004", closeness=10):+> alice;  # Parents
    [john[0], emma[0]] +>:FriendsWith(since="2006", closeness=10):+> bob;    # Parents

    # Find John's family members under 25
    young_family = [john[0]->:FriendsWith:closeness == 10:->(`?Person)](?age < 25);
    print("John's young family members:");
    for person in young_family {
        print(f"  {person.name}, age {person.age}");
    }

    # Find all people in NYC connected to John
    nyc_connections = [john[0]->:FriendsWith:->(`?Person)](?city == "NYC");
    print(f"John's NYC connections:");
    for person in nyc_connections {
        print(f"  {person.name}");
    }

    # Find friends of friends (2-hop connections)
    friends_of_friends = [john[0]->:FriendsWith:->->:FriendsWith:->(`?Person)];
    print(f"Friend of friends: {len(friends_of_friends)} found");
    for person in friends_of_friends {
        print(f"  {person.name}");
    }
}
```

Visit patterns control how walkers traverse your graph. Indexed visiting using `:0:`, `:1:`, etc., controls the order of traversal.

```jac
with entry {
    # Create family tree
    grandpa = root ++> Person(name="Grandpa");
    dad = root ++> Person(name="Dad");
    mom = root ++> Person(name="Mom");
    child1 = root ++> Person(name="Alice");
    child2 = root ++> Person(name="Bob");
    grandchild = root ++> Person(name="Charlie");

    # Create relationships
    grandpa +>:ParentOf:+> dad;
    grandpa +>:ParentOf:+> mom;
    dad +>:ParentOf:+> child1;
    mom +>:ParentOf:+> child2;
    child1 +>:ParentOf:+> grandchild;

    print("=== Breadth-First Search ===");
    grandpa[0] spawn BFSWalker();

    # Reset levels
    all_people = [root-->(`?Person)];
    for person in all_people {
        person.level = 0;
    }

    print("\n=== Depth-First Search ===");
    grandpa[0] spawn DFSWalker();
}
```

## Graph Visualization Tools

Jac provides several tools for visualizing graphs, which are crucial for understanding the spatial programming concepts and debugging.

### Jac VS Code Extension Debugger & Graph Visualizer

The Jac VS Code Extension includes a debugger with a visual graph tool to show nodes and edges in real-time. This tool supports local Jac programs.

**Using Debug Mode Effectively:**

1.  **Set breakpoints** by clicking on line numbers in the editor.
2.  **Start debugging** by clicking the Debug button instead of Run.
3.  **Navigate execution** using the arrow keys or debug controls.
4.  **Observe the graph** to understand how your nodes and edges are connected.
5.  **Step through slowly** to see how data flows through your spatial program structure.

**Opening the Visualization Panel:**

1.  Open the VS Code Command Palette (`ctrl+shift+p` or `⌘+⇧+p`).
2.  Type `jacvis`.
3.  Select `jacvis: Visualize Jaclang Graph`.

To watch the graph build in real-time:
1.  Set a breakpoint in your code.
2.  Open the `jacvis` panel before starting the debugger.
3.  Click "Run and Debug".
4.  Step through the program; each created node/edge appears in real-time. Nodes will show their values and can be dragged.

### Jac Playground

The [Jac Playground](https://www.jac-lang.org/playground/) provides an interactive graph visualizer and online debugger.

### Jac Lens

Jac Lens is a Progressive Web App (PWA) for visualizing Jac object-spatial graphs, specifically designed for Scale Native applications. It allows connecting to a Jac server, navigating node relationships, and modifying node properties in real-time.

**Features:**

-   **Explore Graph**: Navigate node relationships.
-   **Update Graph**: Modify node properties.
-   **Interactive View**: Zoom, pan, and node selection.
-   **Search**: Find specific nodes.

**Troubleshooting Graph Loading:**

-   Confirm required walkers are installed.
-   Check server logs for errors.
-   Verify the graph has data to display.

# Graph Structure

Jac programs operate within a persistent, spatial graph environment. The entry point `with entry` initializes this environment with a single `root` node, which serves as the anchor for all subsequent graph operations.

## Nodes

Nodes are archetypes forming part of a graph, holding properties. They can be compared to custom classes in object-oriented programming (OOP).

### Defining Nodes

Nodes are defined using the `node` keyword, similar to defining a class. They can have properties declared with `has` and abilities (methods).

```jac
node Node {
    has name: str;
    has age: int;
    has friend_count: int = 0;
}
```

### Creating Nodes

Nodes are instantiated like objects.

```jac
with entry {
    node_a = Node(name="A");
}
```

## Edges

Edges connect nodes, forming the structure of the graph.

### Connecting Nodes with Edges

The `++>` operator creates a directional edge between two nodes.

```jac
node Node{
    has name: str;
}

with entry {
    node_a = Node(name="A");
    root ++> node_a;  # Connects node_a to the root node
}
```

Edges can also be defined as archetypes with their own properties:

```jac
edge Friend {
    has since: str;
    has strength: int = 1;
}

node Person {
    has name: str;
    def add_friend(friend: Person) -> bool {
        existing = [self --> Friend --> Person](?name == friend.name);
        if existing {
            return false;
        }
        friendship = Friend(since="2024-01-15");
        self ++> friendship ++> friend;
        return true;
    }
}
```

### Connection Types

Nodes can establish connections in various ways:
-   **One-to-One:** A single node connects to another single node.
-   **One-to-Many:** A single node connects to multiple nodes.
-   **Many-to-One:** Multiple nodes connect to a single node.
-   **Many-to-Many:** A group of nodes connects to another group of nodes.

## Walkers

Walkers are entities that traverse the graph.

### Defining Walkers

Walkers are defined using the `walker` keyword. They can have properties and abilities.

```jac
walker PathWalker {
    has input: str;
}
```

### Walker Entry Points

Walkers begin their traversal from a specified entry point, often the `root` node.

```jac
walker PathWalker {
    has input: str;

    can start with `root entry {
        visit [-->]; // Start visiting nodes connected to the root
    }
}
```

### Walker Abilities

Walkers can define `can visit_node` abilities that trigger when they land on a node of a specific type. `here` refers to the current node.

```jac
walker PathWalker {
    has input: str;

    can visit_node with Node entry {
        self.input += ", visiting " + here.name;
        visit [-->]; // Continue traversal
    }

    can visit_end with EndNode entry {
        self.input += ", reached the end";
        return; // Stop visiting
    }
}
```

### `visit` Statement and Edge Selectors

The `visit` statement instructs a walker to continue traversal. Edge selectors within square brackets control the direction and depth of movement.

-   `visit [-->];`: Move along all forward edges from the current node.
-   `visit [<--];`: Move backward along incoming edges.
-   `visit [-->-->];`: Move along two forward edges in succession.

### Spawning Walkers

Walkers can be spawned on individual nodes/edges or lists of nodes/edges.
-   **Async Walker Support:** Walkers support `async`/`await` for non-blocking spawns during graph traversal, enabling concurrent execution and efficient handling of I/O-bound operations.

## Graph Traversal API

Jac Clouds provide a Traverse API for querying and traversing graphs.
-   `source`: Starting node/edge. Defaults to `root`.
-   `detailed`: If response includes archetype context. Defaults to `False`.
-   `depth`: How deep the traversal from source. Count includes edges. Defaults to `1`.
-   `node_types`: Node filter by name. Defaults to no filter.
-   `edge_types`: Edge filter by name. Defaults to no filter.

## Graph Visualization

Jac provides tools for visualizing graph structures:
-   `jac dot_view`: Visualize Jac graph structures in interactive Streamlit applications.
-   `printgraph`: Built-in function to output graph data.
    -   Outputs in DOT format by default.
    -   Supports JSON output via `as_json=True`.
-   CLI commands for generating dot graph representations:
    -   `jac tool ir sym. <file_path>`: Symbol table.
    -   `jac tool ir ast. <file_path>`: Abstract Syntax Tree (AST).
    -   `jac tool ir cfg. <file_path>`: Control Flow Graph (CFG).

## Graph Structure Optimization

Efficient graph design is crucial for performance. Jac's graph-native design allows for optimized traversals and reduced memory usage compared to traditional approaches.

### Example: Optimized Friend Graph

```jac
node Person {
    has name: str;
    has age: int;
    has friend_count: int = 0;

    def add_friend(friend: Person) -> bool {
        existing = [self --> Friend --> Person](?name == friend.name);
        if existing {
            return false;
        }
        friendship = Friend(since="2024-01-15");
        self ++> friendship ++> friend;
        self.friend_count += 1;
        friend.friend_count += 1;
        return true;
    }
}

edge Friend {
    has since: str;
    has strength: int = 1;
}

walker find_mutual_friends {
    has person1_name: str;
    has person2_name: str;

    can find_efficiently with `root entry {
        person1 = [-->(`?Person)](?name == self.person1_name);
        person2 = [-->(`?Person)](?name == self.person2_name);

        if not person1 or not person2 {
            report {"error": "Person not found"};
            return;
        }

        person1_friends = [person1[0] --> Friend --> Person];
        person2_friends = [person2[0] --> Friend --> Person];

        mutual_names = {f.name for f in person1_friends} & {f.name for f in person2_friends};

        report {
            "mutual_friends": list(mutual_names),
            "count": len(mutual_names)
        };
    }
}
```

# Graph Structure

JacLang represents applications as graphs or networks.

-   **Nodes**: Represent agents, data entities, or specific capabilities. They can have attributes (data) and behaviors (abilities).
-   **Edges**: Represent relationships or connections between nodes.

This structure is particularly useful for:
-   Storing data in connected graph structures.
-   Creating dependency graphs for complex multi-step tasks.
-   Visualizing agentic applications where agents collaborate.

## Graph Traversal

Graph traversal involves navigating through the nodes and edges of a graph.

### Walkers

Walkers are "worker bots" that move along the graph, performing tasks on the nodes they visit. They are crucial for executing visit-dependent abilities and facilitating interactions between graph nodes.

#### Spawning a Walker

A walker can be spawned at any point on the graph using the `spawn` keyword.

```jac
--8<-- "jac/examples/data_spatial/define_walker.jac"
```

#### Navigating with `visit`

Walkers navigate the graph using the `visit` keyword.

-   **Visiting a specific node:**
    ```jac
    visit [node_name]; # Visits a particular node
    ```
-   **Visiting successor nodes:**
    ```jac
    visit [node_name-->]; # Visits successive nodes of a node
    ```
-   **Visiting predecessor nodes:**
    ```jac
    visit [<--node_name]; # Visits predecessor nodes of a node
    ```

#### Removing Walkers

Use `disengage` to remove a walker from the graph.

### Filtering Traversal

Traversal can be restricted based on conditions applied to nodes or edges.

#### Node-Based Filtering

Restricts traversal to specific nodes that satisfy predefined conditions. This is useful for limiting traversal to nodes with certain attributes or filtering nodes dynamically.

```jac
--8<-- "jac/examples/data_spatial/filtering.jac"
```

#### Edge-Based Filtering

Controls traversal by selecting edges based on specific attributes or conditions. This is useful in scenarios like weighted graphs or context-sensitive connections.

```jac
--8<-- "jac/examples/data_spatial/edge_filtering.jac"
```

## Graph Visualization

JacLang provides tools to visualize graph structures.

### `printgraph` Function

The `printgraph` function generates a DOT graph representation of your graph, which can be used with external visualization tools like Graphviz.

```jac
node a{
    has val:int;
}
with entry{
    end=root;
    for i in range(0,4){
        end++>(end:=[a(val=i) for i in range(0,3)]);
    }
    print(printgraph());  # Generates a DOT graph starting from the root node
}
```

#### `printgraph` Parameters

-   **`starting_node`**: The node from where graph traversal or visualization begins.
    -   **Default**: Root.
-   **`depth`**: Limits how deep the traversal should go in the graph.
    -   **Default**: Infinity.
-   **`edge_limit`**: Sets a cap on the number of edges to include in the visualization.
    -   **Default**: 512.
-   **`node_limit`**: Specifies the maximum number of nodes to include.
    -   **Default**: 512.
-   **`bfs`**: Enables Breadth-First Search (BFS) for node traversal.
    -   **Default**: `True`.
-   **`edge_type`**: Option to exclude specific edge types from the visualization.
    -   **Default**: An empty list (i.e., no exclusion).
-   **`dot_file`**: Optional parameter to specify a file name for saving the DOT graph output. If provided, the visualization will be saved in this file.

**Example with parameters:**
```jac
print(printgraph(node_1, bfs=True, traverse=True, edge_type=["Edge1"], node_limit=100, edge_limit=900, depth=300, dot_file='graph.dot'));
```

### `jac dot` Command

The `jac dot` command generates a graph visualization from a `.jac` file.

```bash
jac dot filename.jac
```

#### `jac dot` Parameters

-   **`filename`**: The `.jac` file containing the graph definition.
-   **`--initial`**: The initial node for traversal.
    -   **Default**: `root`.
-   **`--depth`**: The maximum depth for traversal.
    -   **Default**: `-1` (unlimited).
-   **`--traverse`**: Flag to traverse the graph.
    -   **Default**: `False`.
-   **`--connection`**: List of edge types to include.
-   **`--bfs`**: Use Breadth-First Search for traversal.
    -   **Default**: `False`.
-   **`--edge_limit`**: Maximum number of edges.
    -   **Default**: `512`.
-   **`--node_limit`**: Maximum number of nodes.
    -   **Default**: `512`.
-   **`--saveto`**: Specify a file path to save the generated DOT file.

**Example with parameters:**
```bash
jac dot filename.jac --initial "StartNode" --depth 3 --traverse --connection "EdgeType1" --bfs --edge_limit 1000 --node_limit 1000 --saveto "output.dot"
```

## Graph Structure

Jac represents data as nodes and edges in a graph. This allows for modeling relationships between entities.

### Node Definition

Nodes are defined using the `node` keyword, similar to classes in object-oriented programming. They can have properties with type annotations.

```jac
node Person{
    has name: str;
    has email: str;
}

node EmailNode{
    has sender: str;
    has recipients: str;
    has date: str;
    has subject: str;
    has body: str;
    has email_uuid: str;
}
```

### Edges

Edges represent directed relationships between nodes. They are created using the `++>` operator.

```jac
recipientNodes: list[People];
senderNode: People;
emailNode: Email;

senderNode ++> emailNode; // Creates a directed edge from senderNode to emailNode
for node in recipientNodes{
    emailNode ++> node; // Creates directed edges from emailNode to each recipientNode
}
```

### Root Node

The root node is a special, globally accessible node in Jac. All other nodes should be connected to the root node, directly or indirectly, to ensure they are discoverable and traversable by walkers.

-   **Accessibility:** Always accessible in every request context, especially in server mode (`jac serve`).
-   **Persistence:** Ensures nodes are not "lost" and facilitates data traversal and manipulation.
-   **User Isolation:** Each user in a server environment has their own persistent root and isolated graph space.

### Graph Persistence

-   The graph structure can be saved and loaded, allowing reuse across server restarts.
-   Different users have isolated graph spaces, preventing access to each other's nodes.

## Agentic Graph Traversal

Agents (walkers) can traverse the graph to explore nodes, evaluate relevance, and decide which related entities to visit next. This allows for dynamic and adaptive search based on partial results.

## JSON Data Ingestion

Jac can parse JSON data to create nodes and establish relationships.

Example JSON format for email data:

```json
[
  {
    "date": "2025-10-09T06:20:18+00:00",
    "from": "Lily Carter <lcarter@protonmail.com>",
    "to": "Evan Brooks <evan.brooks@gmail.com>",
    "subject": "Hows it going",
    "body": "Hey Evan! We haven't spoken in a while, let's catch up soon."
  }
]
```

When processing such data:
-   Sender and recipient addresses are extracted.
-   `Person` nodes are created if they don't already exist.
-   `EmailNode` nodes are created or skipped based on UUID matching.
-   All `Person` and `EmailNode` nodes are connected to the root.
-   Directed edges are created: `person ++> email` (sender) and `email ++> person` (recipients).