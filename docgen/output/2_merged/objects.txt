# Objects and Classes

# Objects and Classes

Jac supports traditional Object-Oriented Programming (OOP) and introduces Object-Spatial Programming (OSP) for graph-like data structures and agentic workflows.

## Archetypes

Jac provides two core archetypes for defining objects: `obj` and `class`. Both support object hierarchy and behavior.

### `obj`

Defines a standard object, similar to a Python dataclass. Members are per-instance. `obj` is the base archetype for all other Jac archetypes and is designed for Object-Spatial Programming.

```jac
obj Tweet {
    has content: str, author: str, timestamp: str, likes: int = 0;

    def like() -> None;
    def unlike() -> None;
    def get_preview(max_length: int) -> str;
    def get_like_count() -> int;
}
```

### `class`

Defines a standard Python-compatible class. Members are static (shared across instances).

```jac
class Cat {
    has name: str = "Unnamed";
    def meow {
        print(f"{self.name} says meow!");
    }
}
```

## Object-Spatial Programming (OSP)

OSP allows developers to articulate relationships between objects in a graph-like structure and express computation as walkers that traverse this graph. This model is effective for connected data (e.g., social networks, knowledge graphs) and forms the foundation for agentic workflows.

Jac Lens and the Graph Visualizer are tools for visualizing Jac object-spatial graphs and understanding how objects, walkers, and edges interact.

## Object Definition

Objects are declared using the `obj` keyword.

### Attributes

Attributes are defined within the class body using the `has` keyword. They can specify types and default values.

```jac
obj Pet {
    has name: str;
    has species: str;
    has age: int;
    has is_adopted: bool = False; # Automatic default
}
```

### Methods

Methods are defined using the `def` keyword. They use `self` to access the object's own attributes.

```jac
obj Pet {
    # ... attributes ...
    def adopt() -> None {
        self.is_adopted = True;
        print(f"{self.name} has been adopted!");
    }

    def get_info() -> str {
        status = "adopted" if self.is_adopted else "available";
        return f"{self.name} is a {self.age}-year-old {self.species} ({status})";
    }
}
```

### Implementation Separation

For larger codebases, object declarations can be separated from their implementations using `impl` blocks. The object lists method signatures, and the actual bodies are provided later.

```jac
obj MyObject {
    def my_method() -> None;
}

impl MyObject {
    def my_method() -> None {
        print("Hello from MyObject!");
    }
}
```

## Object Instantiation

Jac automatically generates a constructor for `obj` based on the attributes declared with `has`.

```jac
with entry {
    pet = Pet(name="Buddy", species="dog", age=3);
    print(pet.get_info());
    pet.adopt();
}
```

### `postinit` Method

The `postinit` method runs automatically after an object's initial attributes have been set. It is useful for calculated properties or validation. An attribute can be marked with `by postinit` to indicate its value will be assigned within this method.

```jac
obj PetShop {
    has name: str;
    has pets: list[Pet] = [];
    has capacity: int = 10;
    has is_open: bool by postinit; # Value calculated after initialization

    def postinit() -> None {
        self.is_open = len(self.pets) < self.capacity;
        print(f"{self.name} shop initialized with {len(self.pets)} pets");
    }
}
```

## Inheritance

Inheritance allows creating specialized objects (subclasses) based on existing ones (parent objects). Subclasses inherit attributes and methods and can add new features or override existing ones.

```jac
obj Animal {
    has name: str;
    has species: str;
    has age: int;

    def make_sound() -> None {
        print(f"{self.name} makes a sound.");
    }
}

obj Dog(Animal) { # Dog inherits from Animal
    has breed: str;

    def make_sound() -> None { # Overrides make_sound
        print(f"{self.name} barks.");
    }
}

obj Cat(Animal) { # Cat inherits from Animal
    has color: str;

    def make_sound() -> None { # Overrides make_sound
        print(f"{self.name} meows.");
    }
}
```

## Base Class

`Obj` is the base class for all Jac archetypes.

```python
class Person(Obj):
    name: str
    age: int

    def greet(self) -> None:
        print(f"Hello, my name is {self.name} and I'm {self.age} years old.")
```

## Objects and Classes

### Object Definition
Objects are defined using the `obj` keyword. They can have attributes (`has`) and methods (`def`).

```jac
obj MyObject {
    has my_attribute: str;

    def my_method() -> None {
        print("Hello from MyObject");
    }
}
```

### Access Control
Jac provides explicit keywords for access control, enforced by the runtime.

#### Public Access (`:pub`)
Public members are accessible from anywhere. `:pub` is optional as it's the default.

```jac
obj PublicExample {
    has :pub public_property: str; # Public by default
    def :pub public_method() -> str {
        return "This is a public method";
    }
}
with entry {
    example = PublicExample(public_property="Hello");
    print(example.public_method());
    print(example.public_property);
}
```

#### Private Access (`:priv`)
Private members are only accessible from within the object itself.

```jac
obj PrivateExample {
    has :priv private_property: str;
    def :priv private_method() -> str {
        return "This is a private method";
    }
    def :pub public_method() -> str {
        return self.private_method();
    }
}
with entry {
    example = PrivateExample(private_property="Secret");
    print(example.public_method());
    # print(example.private_property); # This would raise an error
}
```

#### Protected Access (`:protect`)
Protected members are accessible within the object that defines them and within any of its subclasses.

```jac
obj ProtectedExample {
    has :protect protected_property: str = "Protected";
    def :protect protected_method() -> str {
        return "This is a protected method";
    }
}
obj SubProtectedExample(ProtectedExample) {
    def :pub public_method() -> str {
        return self.protected_method(); # Accessible in subclass
    }
}
with entry {
    example = SubProtectedExample();
    print(example.public_method());
    print(example.protected_property);
}
```

### Interface and Implementation Separation
Jac allows separating an object's interface (definition) from its implementation. The interface is defined in a `.jac` file, and the implementation in a corresponding `.impl.jac` file.

#### Interface Definition (`.jac` file)
```jac
obj Calculator {
    has precision: int = 2;

    def add(a: float, b: float) -> float;
    def subtract(a: float, b: float) -> float;
    def multiply(a: float, b: float) -> float;
    def divide(a: float, b: float) -> float;
}
```

#### Implementation (`.impl.jac` file)
```jac
impl Calculator.add {
    result = a + b;
    return round(result, self.precision);
}

impl Calculator.subtract {
    result = a - b;
    return round(result, self.precision);
}

impl Calculator.multiply {
    result = a * b;
    return round(result, self.precision);
}

impl Calculator.divide {
    if b == 0.0 {
        raise ValueError("Division by zero");
    }
    result = a / b;
    return round(result, self.precision);
}
```

### Special Object Types

#### Walkers
Walkers are defined with the `walker` archetype. They are objects that can traverse graphs.

```jac
walker MyWalker {
    has data: str;
    def walk_method() -> None {
        # ...
    }
}
```

#### Nodes
Nodes are objects that can exist in a graph, giving them a spatial context.

```jac
node WeatherData {
    has city: str;
    has temperature: float;
    has description: str;
    has last_updated: str;
}
```

#### Client-Side Objects (`cl obj`)
Objects prefixed with `cl obj` are available on both client and server, typically used for UI components.

```jac
cl obj ButtonProps {
    has label: str = "Hello";
    has count: int = 0;
}

cl obj CardProps {
    has title: str = "Untitled";
    has content: str = "";
}
```

#### `__specs__` Object
A special object `__specs__` can be defined within other objects to hold static configuration, such as authentication requirements or allowed methods.

```jac
obj MyAPIEndpoint {
    obj __specs__ {
        static has auth: bool = False;
        static has methods: list = ["get", "post"];
    }
    # ...
}
```

### Key Differences from Python OOP
-   **Automatic Constructors**: No need to write `__init__` methods.
-   **Enforced Access Control**: `:pub`, `:priv`, `:protect` are enforced by the runtime.
-   **Clean Inheritance**: Automatic constructor chaining in inheritance.
-   **Type Safety**: All method parameters and returns must be typed.
-   **Implementation Separation**: Interface can be separated from implementation.

## Standard Library

### `json` Module
-   `dumps(obj: any) -> str`: Serialize `obj` to a JSON formatted `str`.
-   `loads(s: str) -> any`: Deserialize `s` (a `str` containing a JSON document) to a Jac object.

### `file` Module
-   `open(path: str) -> File`: Opens a file at the given `path` and returns a `File` object.
    -   `read(size: int = -1) -> str`: Reads `size` bytes from the file. If `size` is -1, reads until EOF.
    -   `write(content: str) -> int`: Writes `content` to the file. Returns the number of characters written.

### `os` Module
-   `os.getenv(key: str, default: str = "") -> str`: Get the value of an environment variable.

### `logging` Module
-   `logging.info(message: str) -> None`: Logs an informational message.
-   `logging.warning(message: str) -> None`: Logs a warning message.
-   `logging.error(message: str) -> None`: Logs an error message.

## Core Language Features

### Imports
-   `import:py from <module> {<name1>, <name2>}`: Imports specific names from a Python module for interoperability.

### Spawning
-   `spawn <walker_instance> on <node_instance>`: Initiates a walker's traversal from a specific node.
-   `spawn <walker_instance> on <list_of_nodes>`: Initiates a walker's traversal on multiple nodes.
-   `spawn <walker_instance> on <group_of_nodes>`: Initiates a walker's traversal on a group of nodes.

### Type Annotations
-   `has x: type`: Explicitly declares the type of an attribute.

### Reference Operator
-   `&`: Used to get a reference to an object or value.

### Node Properties
-   `.edges`: A property of a node that provides access to its connected edges.

### Semantic String
-   `str "..."`: Denotes a semantic string, often used for specific data types or contexts.

### Asynchronous Programming
-   `async def my_async_func() -> None`: Defines an asynchronous function.
-   `await my_async_func()`: Pauses execution until the `awaitable` completes.

### Testing and Validation
-   `assert <condition>, <message: str>`: Checks if a condition is true. If false, raises an `AssertionError` with an optional message.

### Persistence
-   `save <object> to <path: str>`: Serializes and saves an object to a specified path.
-   `load <type> from <path: str>`: Loads and deserializes an object of a specified type from a path.

### Agent Loops
-   `while (by llm()) { ... }`: Represents an agent loop where actions are determined by an LLM.

```jac
walker Agent {
    has state: str = "initial";

    can think(query: str) -> str;
    can act(action: str) -> None;

    with entry {
        while (by llm()) {
            thought = self.think("What should I do next?");
            if (thought == "exit") {
                break;
            }
            self.act(thought);
        }
    }
}
```

## Objects and Classes

### Object Definition
Objects are fundamental building blocks in Jac, similar to classes in object-oriented programming. They can maintain state and execute logic.

```jac
obj Book {
    has title: str;
    has author: str;
    has isbn: str;
    has is_borrowed: bool = False;

    def get_info() -> str {
        status = "Available" if not self.is_borrowed else "Borrowed";
        return f"{self.title} by {self.author} - {status}";
    }

    def borrow() -> bool {
        if not self.is_borrowed {
            self.is_borrowed = True;
            return True;
        }
        return False;
    }
}
```
-   `obj`: Keyword to define an object.
-   `has`: Declares attributes (fields) for the object. This also serves as an automatic constructor, initializing attributes with provided values or defaults.
-   `def`: Defines methods (abilities) for the object.
-   `self`: Refers to the current object instance within its methods.

### Object Usage
```jac
with entry {
    book = Book(title="The Great Gatsby", author="F. Scott Fitzgerald", isbn="123456789");
    print(book.get_info());
    success = book.borrow();
    print(f"Borrowed: {success}");
    print(book.get_info());
}
```

### Nodes and Edges
Nodes and edges are specialized types of objects that form the basis of Jac's graph-based spatial programming.

#### Node Definition
Nodes represent entities in a graph.
```jac
node Person {
    has name: str;
    has age: int;
    has city: str;
    has level: int = 0;
    has priority: int;
}
```
-   `node`: Keyword to define a node.
-   Nodes can have attributes (`has`) and methods (`def`) just like general objects.

#### Edge Definition
Edges represent relationships between nodes.
```jac
edge FriendsWith {
    has since: str;
    has closeness: int; # 1-10 scale
}

edge ParentOf {}

edge ConnectedTo {
    has strength: int;
}
```
-   `edge`: Keyword to define an edge.
-   Edges can also have attributes (`has`).

#### Creating Nodes and Edges
Nodes are created and connected using the `++>` operator for initial placement and `+>:<EdgeName>:+>` for creating edges.
```jac
with entry {
    // Create nodes
    alice = root ++> Person(name="Alice", age=25, city="NYC");
    bob = root ++> Person(name="Bob", age=30, city="SF");
    charlie = root ++> Person(name="Charlie", age=22, city="NYC");
    diana = root ++> Person(name="Diana", age=28, city="LA");

    // Create edges
    alice +>:FriendsWith(since="2020", closeness=8):+> bob;
    alice +>:FriendsWith(since="2021", closeness=9):+> charlie;
    bob +>:FriendsWith(since="2019", closeness=6):+> diana;

    // Creating multiple edges from a list of nodes
    john = root ++> Person(name="John", age=45, city="NYC");
    emma = root ++> Person(name="Emma", age=43, city="NYC");
    [john[0], emma[0]] +>:FriendsWith(since="2004", closeness=10):+> alice;
}
```

#### Graph Traversal and Filtering
Jac provides powerful syntax for traversing and filtering graph structures.

-   **Direct Traversal:**
    -   `[source_node --> target_node]` : Finds direct connections.
    -   `[source_node --> EdgeName --> target_node]` : Finds connections via a specific edge type.
    -   `[source_node --> EdgeName:attribute_filter --> target_node]` : Filters edges by attribute.
    -   `[source_node --> EdgeName --> target_node](?node_attribute_filter)` : Filters target nodes by attribute.
    -   `[source_node --> EdgeName --> target_node](?node_attribute == "value")` : Example of node attribute filtering.
    -   `[source_node ->:EdgeName:attribute_filter:->(target_node_type)]` : General form for filtering.

-   **Multi-hop Traversal:**
    -   `[source_node ->:EdgeName:-> ->:AnotherEdge:->(target_node_type)]` : Finds connections across multiple hops.

-   **Examples:**
```jac
with entry {
    // Find all people in NYC (age < 25)
    nyc = [root-->(`?Person)](?city == "NYC");
    young_nyc = nyc(?age < 25);

    // Find Alice's close friends (closeness >= 8)
    close_friends = [alice->:FriendsWith:closeness >= 8:->(`?Person)];

    // Find all friendships that started before 2021
    old_friendships = [root->:FriendsWith:since < "2021":->];

    // Find John's family members under 25
    john = root ++> Person(name="John", age=45, city="NYC");
    young_family = [john[0]->:FriendsWith:closeness == 10:->(`?Person)](?age < 25);

    // Find all people in NYC connected to John
    nyc_connections = [john[0]->:FriendsWith:->(`?Person)](?city == "NYC");

    // Find friends of friends (2-hop connections)
    friends_of_friends = [john[0]->:FriendsWith:->->:FriendsWith:->(`?Person)];
}
```

### Walkers
Walkers are specialized objects designed for graph traversal. They maintain state, execute logic, and make decisions during their journey across nodes and edges.

#### Walker Definition
```jac
walker BFSWalker {
    can traverse with Person entry {
        print(f"BFS visiting: {here.name} (level {here.level})");

        // Visit children - default queue behavior (breadth-first)
        children = [->:ParentOf:->(`?Person)];
        for child in children {
            child.level = here.level + 1;
        }
        visit children;
    }
}

walker DFSWalker {
    can traverse with Person entry {
        print(f"DFS visiting: {here.name} (level {here.level})");

        // Visit children with :0: (stack behavior for depth-first)
        children = [->:ParentOf:->(`?Person)];
        for child in children {
            child.level = here.level + 1;
        }
        visit :0: children;
    }
}

walker PriorityWalker {
    can visit_by_priority with Person entry {
        print(f"Visiting: {here.name} (priority: {here.priority})");

        // Get all connections
        connections = [->:ConnectedTo:->(`?Person)];

        if connections {
            print(f"  Found {len(connections)} connections");
            for conn in connections {
                print(f"    {conn.name} (priority: {conn.priority})");
            }

            // Visit highest priority first using :0:
            visit :0: connections;
        }
    }
}
```
-   `walker`: Keyword to define a walker.
-   `can <ability_name> with <node_type> entry`: Defines an ability that is automatically triggered when the walker "lands on" a node of the specified type.
-   `here`: Refers to the current node the walker is on.
-   `visit <nodes>`: Instructs the walker to move to the specified nodes.
    -   `visit nodes`: Default behavior (breadth-first traversal, uses a queue).
    -   `visit :0: nodes`: Depth-first traversal (uses a stack).

#### Spawning Walkers
Walkers are "spawned" from a starting node to begin their traversal.
```jac
with entry {
    grandpa = root ++> Person(name="Grandpa");
    // ... create other nodes and edges ...

    print("=== Breadth-First Search ===");
    grandpa[0] spawn BFSWalker();

    print("\n=== Depth-First Search ===");
    grandpa[0] spawn DFSWalker();

    center = root ++> Person(name="Center", priority=5);
    // ... create other nodes and edges ...

    print("=== Priority-Based Traversal ===");
    center[0] spawn PriorityWalker();
}
```
-   `node_instance spawn WalkerName()`: Initiates a walker's traversal from `node_instance`.

#### Async Walkers
Jac supports asynchronous walkers, allowing non-blocking spawns and concurrent execution, particularly useful for I/O-bound operations.
-   `async`, `await`: Keywords for asynchronous operations within walkers.
-   Async walkers enable concurrent execution of multiple walkers.

## Standard Library

### File I/O
Module: `file`
-   `open(path: str) -> File`: Opens a file at the given path.
-   `read(file: File) -> str`: Reads the entire content of the file.
-   `write(file: File, content: str) -> None`: Writes content to the file.

### JSON Serialization
Module: `json`
-   `dumps(obj: Any) -> str`: Serializes a Python object into a JSON formatted string.
-   `loads(s: str) -> Any`: Deserializes a JSON formatted string into a Python object.

### Operating System Interaction
Module: `os`
-   Provides functions for interacting with the operating system, such as file system operations, environment variables, etc. (Specific functions not detailed in source, but module is preserved).

### Logging
Module: `logging`
-   Provides a flexible framework for emitting log messages from applications. (Specific functions not detailed in source, but module is preserved).

## Imports

-   `import:py from <module> {<item1>, <item2>}`: Imports specific items from a Python module for interoperability.
    ```jac
    import:py from json {dumps};
    ```

## Persistence

-   `save(obj: Any, path: str) -> None`: Saves an object to a specified path.
-   `load(path: str) -> Any`: Loads an object from a specified path.

## Testing and Validation

-   `assert <condition>`: Used to assert that a condition is true. If false, it raises an AssertionError, typically used for testing or validating assumptions.

## Semantic Strings

-   `str "..."`: Denotes a semantic string, which can carry additional meaning or context beyond a regular string literal.

## Node Properties

-   `.edges`: A property available on nodes that provides access to the edges connected to that node.

## Reference Operator

-   `&`: The reference operator, used to obtain a reference to a variable or object.

# Objects and Classes

## Object and Node Definition
Objects (`obj`) and Nodes (`node`) are fundamental building blocks for data structures. Nodes are specialized objects that can form graphs.

### Object Declaration
```jac
obj Person {
    has full_name: str,
        yod: int,
        personality: Personality;
}
```

### Node Declaration
Nodes can have properties and methods, similar to objects. They can also participate in graph structures.

```jac
node ChatRoom {
    has name: str;
    has users: list[str] = [];
    has messages: list[dict] = [];
    has created_at: str;
}

node ChatMessage {
    has content: str;
    has sender: str;
    has timestamp: str;
    has room_name: str;
    has id: str = "msg_" + str(uuid4());
}

node WebhookLog {
    has source: str;
    has event_type: str;
    has data: dict;
    has received_at: str;
}

node LogEntry {
    has level: str;
    has message: str;
    has timestamp: str;
    has context: dict = {};
}
```

### Inheritance
Inheritance allows objects and nodes to inherit properties and methods from a base type.

```jac
obj Vehicle {
    has wheels: int;
}

obj Car(Vehicle) {
    has doors: int = 4;
}

node BaseUser {
    has username: str;
}

node AdminUser(BaseUser) {
    has is_admin: bool = true;
}
```

## Methods and Abilities

### Defining Methods within Objects/Nodes
Methods (`def`) define behavior for objects and nodes.

```jac
node ChatRoom {
    has name: str;
    has users: list[str] = [];
    has message_count: int = 0;

    can add_user(username: str) -> bool {
        if len(self.users) >= chat_config["max_users"] {
            return False;
        }
        if username not in self.users {
            self.users.append(username);
        }
        return True;
    }

    def add_message(sender: str, content: str) -> ChatMessage {
        new_message = ChatMessage(
            content=content,
            sender=sender,
            timestamp=datetime.now().isoformat(),
            room_name=self.name
        );
        self ++> new_message;
        self.message_count += 1;
        return new_message;
    }

    def get_recent_messages(limit: int = 20) -> list[dict] {
        messages = [self --> (`?ChatMessage)];
        recent = messages[-limit:] if len(messages) > limit else messages;
        return [
            {
                "content": msg.content,
                "sender": msg.sender,
                "timestamp": msg.timestamp
            }
            for msg in recent
        ];
    }
}
```

### Implementing Methods with `impl`
The `impl` keyword provides a clear way to define methods for existing types.

```jac
impl Circle.area -> float {
    return math.pi * self.radius * self.radius;
}

impl Person.greet with Room entry {
    return "Hello, I am " + self.name;
}

impl calculate_distance(x: float, y: float) -> float {
    return math.sqrt(x*x + y*y);
}
```

### AI-Powered Methods (`by llm()`)
Methods can leverage Language Models (LLMs) for their implementation, using the `by llm()` syntax.

```jac
import from byllm.lib { Model, Image }

glob vision_llm = Model(model_name="gpt-4o-mini");

obj ImageCaptioner {
    has name: str;

    """Generate a brief, descriptive caption for the image."""
    def generate_caption(image: Image) -> str by vision_llm();

    """Extract specific objects visible in the image."""
    def identify_objects(image: Image) -> list[str] by vision_llm();

    """Determine the mood or atmosphere of the image."""
    def analyze_mood(image: Image) by vision_llm();
}
```

### Semantic Strings (`sem`)
Semantic strings provide additional context to LLMs for better understanding of objects and their properties.

```jac
sem PhotoAnalyzer = "Professional photo analysis tool for photographers";
sem PhotoAnalyzer.photographer_name = "Name of the photographer for personalized analysis";
sem PhotoAnalyzer.style_preference = "Preferred photography style (artistic, documentary, commercial)";
```

### Robust AI Methods with Error Handling
Methods can include `try-except` blocks for robust error handling, especially when interacting with external services like LLMs.

```jac
obj RobustCaptioner {
    has fallback_enabled: bool = True;

    """Generate caption with error handling."""
    def safe_caption(image_path: str) -> dict {
        try {
            caption = self.generate_caption_ai(image_path);
            return {
                "success": True,
                "caption": caption,
                "source": "ai"
            };
        } except Exception as e {
            if self.fallback_enabled {
                fallback_caption = f"Image analysis unavailable for {image_path}";
                return {
                    "success": False,
                    "caption": fallback_caption,
                    "source": "fallback",
                    "error": str(e)
                };
            } else {
                raise e;
            }
        }
    }

    """AI-powered caption generation."""
    def generate_caption_ai(image_path: str) -> str by reliable_llm();

    """Validate generated content."""
    def validate_caption(caption: str) -> bool {
        # Basic validation rules
        if len(caption) < 10 {
            return False;
        }
        if "error" in caption.lower() {
            return False;
        }
        return True;
    }
}
```

## Walkers

Walkers (`walker`) are special types of objects that traverse graphs and perform actions.

### Walker Definition
```jac
walker get_counter {
    obj __specs__ {
        static has auth: bool = False;
    }

    can get_counter_endpoint with `root entry {
        counter_nodes = [root --> Counter];

        if not counter_nodes {
            counter = Counter();
            root ++> counter;
        } else {
            counter = counter_nodes[0];
        }

        report {"value": counter.get_value()};
    }
}
```

### Walker Context Keywords
- `self`: Refers to the current object (node or edge) within its own method.
- `here`: In a walker's `can visit` ability, `here` refers to the current node or edge being visited.
- `visitor`: In a node/edge method called by a walker, `visitor` refers to the walker instance.

```jac
node Person {
    has name;

    can greet {
        self.name = self.name.upper();
        return "Hello, I am " + self.name;
    }

    can update_walker_info {
        visitor.age = 25;  # 'visitor' refers to the walker
    }
}

walker PersonVisitor {
    has age;

    can visit: Person {
        here.name = "Visitor";  # 'here' refers to the current node
        report here.greet();
    }
}
```

### Walker Examples
```jac
walker increment_counter {
    obj __specs__ {
        static has auth: bool = False;
    }

    can increment_counter_endpoint with `root entry {
        counter_nodes = [root --> Counter];
        if not counter_nodes {
            counter = Counter();
            root ++> counter;
        } else {
            counter = counter_nodes[0];
        }
        new_value = counter.increment();
        report {"value": new_value};
    }
}

walker get_counter_with_history {
    obj __specs__ {
        static has auth: bool = False;
    }

    can get_counter_with_history_endpoint with `root entry {
        counter_nodes = [root --> Counter];
        if not counter_nodes {
            counter = Counter(created_at=str(datetime.now()));
            root ++> counter;
            report {
                "value": 0,
                "status": "created",
                "history": []
            };
        } else {
            counter = counter_nodes[0];
            report {
                "value": counter.value,
                "status": "existing",
                "history": counter.get_history()
            };
        }
    }
}

walker create_counter {
    has name: str;

    obj __specs__ {
        static has auth: bool = False;
    }

    can create_counter_endpoint with `root entry {
        manager_nodes = [root --> CounterManager];
        if not manager_nodes {
            manager = CounterManager(created_at=str(datetime.now()));
            root ++> manager;
        } else {
            manager = manager_nodes[0];
        }

        result = manager.create_counter(self.name);
        report result;
    }
}

walker increment_named_counter {
    has name: str;
    has amount: int = 1;

    obj __specs__ {
        static has auth: bool = False;
    }

    can increment_named_counter_endpoint with `root entry {
        manager_nodes = [root --> CounterManager];
        if not manager_nodes {
            report {"error": "No counter manager found"};
            return;
        }

        manager = manager_nodes[0];
        counters = [manager --> Counter](?name == self.name);

        if not counters {
            report {"error": f"Counter {self.name} not found"};
            return;
        }

        counter = counters[0];
        new_value = counter.increment(self.amount);
        report {"name": self.name, "value": new_value};
    }
}

walker get_all_counters {
    obj __specs__ {
        static has auth: bool = False;
    }

    can get_all_counters_endpoint with `root entry {
        manager_nodes = [root --> CounterManager];
        if not manager_nodes {
            report {"counters": [], "total": 0};
            return;
        }

        manager = manager_nodes[0];
        report {
            "counters": manager.list_counters(),
            "total": manager.get_total()
        };
    }
}
```

## Objects and Classes

### Object-Oriented Programming Concepts
- **Nodes**: Represent different parts of a system (e.g., Router, Chat types, Sessions). Each node has specific responsibilities and capabilities.
- **Walkers**: Move through a node network, carrying information and executing logic. They represent actions a system can perform.
- **Objects**: General-purpose data structures.
- **Edges**: Connect nodes, representing relationships.

### Class Definition
- **`node`**: Defines a node class.
- **`obj`**: Defines a general object class.
- **`enum`**: Defines an enumeration.

```jac
node Note {
    has title: str;
    has content: str;
    has owner: str;
    has shared_with: list[str] = [];
    has is_public: bool = False;
    has permissions: dict = {"read": True, "write": False};
    has id: str = "note_" + str(uuid.uuid4());
}

enum Role {
    VIEWER = "viewer",
    EDITOR = "editor",
    ADMIN = "admin"
}

obj UserProfile {
    has email: str;
    has role: Role = Role.VIEWER;
    has created_at: str = "2024-01-15";
}
```

### Class Properties (`has`)
- Declares attributes for objects, nodes, and edges.
- Supports type annotations (`has x: type`) and default values.

```jac
obj Response {
    has follow_up_questions: str;    # Next question to ask
    has summary: str;                # Concise memory summary
    has when: str;                   # Date in YYYY-MM-DD format
    has who: List[str];              # Names of people involved
    has what: str;                   # What the memory is about
    has where: List[str];            # Relevant locations
    has terminate_conversation: bool; # Completion flag
    has show_summary: bool;          # Display summary flag
}

obj TaskPartition {
  has task: str;
  has agent_type: RoutingNodes;
}

obj Task {
    has title: str;
    has description: str;
    has due_date: str;
    has priority: str;
    has status: str;
    has assignee: str;
}

obj EmailTemplate {
    has subject: str;
    has greeting: str;
    has body: str;
    has closing: str;
    has tone: str; # formal, casual, urgent
}

obj InventoryItem {
    has name: str;
    has price: float;
}

obj Person {
    has name: str;
    has age: int;
    has hobby: str;
    has description: str;
    has money: float;
    has inventory: list[InventoryItem];
}

obj Chat {
    has person: str;
    has message: str;
}
```

### Inheritance
- Syntax for inheritance uses parentheses: `obj Car(Vehicle)`.

```jac
obj MyOpenAIModel(BaseLLM){
    has model_name: str;
    has config: dict = {};

    def post_init() {
        super().__init__(model_name=self.model_name, **kwargs);
    }

    def model_call_no_stream(params: dict) {
        client = OpenAI(api_key=self.api_key);
        response = client.chat.completions.create(**params);
        return response;
    }

    def model_call_with_stream(params: dict) {
        client = OpenAI(api_key=self.api_key);
        response = client.chat.completions.create(stream=True, **params);
    }
}
```

### Implementation (`impl`)
- The `impl` keyword provides a simpler, more explicit way to implement abilities and methods for objects, nodes, edges, and other types.

### Object-Spatial Arrow Notation
- Typed arrow notations `-:MyEdge:->` and `+:MyEdge:+>` are now `->:MyEdge:->` and `+>:MyEdge:+>`.

### Typed Context Blocks (OSP)
- Fully implemented typed context blocks for Object-Spatial Programming:
    - `-> NodeType { }`
    - `-> WalkerType { }`
- Enables conditional code execution based on runtime types.

### Walker `__specs__` for Endpoint Configuration
- Walkers can define an `obj __specs__` block to configure endpoint behavior.

```jac
walker my_walker {
    has data: str;

    obj __specs__ {
        static has methods: list = ["get", "post"];   # Supports both GET and POST
        static has auth: bool = False;                # No authentication required
        static has as_query: list = ["data"];         # "data" will be a query parameter
        static has private: bool = True;              # Skip auto endpoint generation from walker
    }
}

walker public_info {
    obj __specs__ {
        static has methods: list = ["get"];
        static has auth: bool = False;
    }

    can get_current_time with `root entry{
        report {
            "timestamp": datetime.now().isoformat()
        };
    }
}

walker search_users {
    has query: str;
    static has users: list = [
        {"username": "alice", "email": "alice@example.com"},
        {"username": "bob", "email": "bob@example.com"}
    ];

    obj __specs__ {
        static has methods: list = ["get"];
        static has as_query: list = ["query"];
        static has auth: bool = False;
    }

    can search_by_name with `root entry{
        for user in self.users {
            if user['username'] == self.query {
                report user;
                return;
            }
        }

        report {
            "error": f"User with username {self.query} not found"
        };
    }
}

walker single_file_upload {
    has file: UploadFile;

    obj __specs__ {
        static has methods: list = ["post"];
        static has auth: bool = False;
    }

    can enter with `root entry {
        report {
            "output": f"Received file: {self.file.filename}"
        };
    }
}
```

### Persistence
- `save(instance)`: Saves a walker or object instance to memory, queued for later database commit.
- `load(instance)`: Loads an instance.

```jac
# Save a walker instance
save(my_walker_instance)

# Save an object instance
save(my_object_instance)
```

### Semantic Strings (`sem`)
- Provides an elegant way to enrich the meaning of class attributes and function arguments.
- Used for describing object attributes with domain-specific meaning, adding context to parameters, and providing semantic information.

```jac
obj Person {
    has name: str;
    has dob: str;
    has ssn: str;
}

sem Person = "Represents the personal record of a person";
sem Person.name = "Full name of the person";
sem Person.dob = "Date of Birth";
sem Person.ssn = "Last four digits of the Social Security Number of a person";

"""Calculate eligibility for various services based on person's data."""
def check_eligibility(person: Person, service_type: str) -> bool by llm();
```

### LLM Integration (`by llm()`)
- Methods can be integrated with LLM capabilities to process object state and context.
- `by llm()` automatically adds attributes of the initialized object into the prompt of the LLM.

```jac
import from byllm.lib { Model }

glob llm = Model(model_name="gemini/gemini-2.0-flash");

"""Represents the personal record of a person"""
obj Person {
    has name: str;
    has dob: str;
    has ssn: str;
}

sem Person.name = "Full name of the person";
sem Person.dob = "Date of Birth";
sem Person.ssn = "Last four digits of the Social Security Number of a person";

"""Calculate eligibility for various services based on person's data."""
def check_eligibility(person: Person, service_type: str) -> bool by llm();
```

#### Context-Aware Methods
- **Docstrings**: Use for function-level context and behavior description.
- **Semstrings**: Use for attribute-level descriptions and domain-specific terminology.
- **`incl_info`**: Use to selectively include relevant object state in method calls.

```jac
import from byllm.llm { Model }
import from datetime { datetime }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has age: int;

    def introduce() -> str by llm();
    def suggest_hobby() -> str by llm();
}

with entry {
    alice = Person("Alice", 25);
    print(alice.introduce());
    print(alice.suggest_hobby());
}

obj Person {
    has name: str;
    has date_of_birth: str;

    # Uses the date_of_birth attribute and "today" information
    # from incl_info to calculate the person's age
    def calculate_age() -> str by llm(
        incl_info={
            "today": datetime.now().strftime("%d-%m-%Y"),
        }
    );
}
```

### `glob :pub`
- Declarations explicitly annotated with `:pub` now generate JavaScript `export` statements for classes (`obj :pub`), functions (`def :pub`), enums (`enum :pub`), and global variables (`glob :pub`).

### OPath
- OPath designates object spatial paths, avoiding conflicts with Python's `pathlib.Path`.

## Standard Library

### `byllm.llm` Module
- `Model` class for interacting with LLMs.

#### `Model` Arguments
| Argument | Description |
|---|---|
| `model_name` | (Required) The model name to use (e.g., "gpt-4o", "claude-3-5-sonnet-20240620") |
| `api_key` | (Optional) API key for the model provider |
| `base_url` | (Optional) Base URL for the API endpoint (same as `host`, `api_base`)|
| `proxy_url` | (Optional) Proxy URL, automatically sets `base_url` |
| `verbose` | (Optional) Boolean to enable verbose logging for debugging |
| `method` | (Optional) Specifies the LLM method ('Reason' enables step-by-step reasoning, default is standard generation) |
| `tools` | (Optional) List of tool functions to enable agentic behavior with ReAct tool-calling |
| `hyperparams` | (Optional) Additional model-specific parameters supported by LiteLLM (e.g., `temperature`, `max_tokens`, `top_p`, etc.) |

### `datetime` Module
- `datetime.now().isoformat()`: Returns the current local date and time in ISO format.

### `fastapi` Module
- `UploadFile`: Used for handling file uploads in web endpoints.

### `openai` Module
- `OpenAI`: Client for interacting with OpenAI API.
- `client.chat.completions.create(**params)`: Creates a chat completion.
- `client.chat.completions.create(stream=True, **params)`: Creates a streaming chat completion.

### `uuid` Module
- `uuid.uuid4()`: Generates a random UUID.

## Imports

- `import:py`: Used for importing Python modules and functions.

```jac
import:py from json {dumps};
import from datetime {datetime}
import from fastapi { UploadFile }
import from byllm.llm { BaseLLM }
import from openai { OpenAI }
import from byllm.lib { Model }
```

## Objects and Classes

### Object Definition (`obj`)
Objects are data structures that can hold properties. They are similar to classes in traditional OOP but are primarily used for data encapsulation.

```jac
obj Position {
    has x: int, y: int;     # 2D coordinate
}

obj Wall {
    has start_pos: Position, end_pos: Position;       # wall starts and ends here
}

obj Response{
    has option: str;
    has selection: str;
    has explanation: str;
}

obj Level {
    has name: str, difficulty: int;
    has width: int, height: int, num_wall: int;
    has num_enemies: int; time_countdown: int;
    n_retries_allowed: int;
}

obj Map {
    has level: Level, walls: list[Wall];
    has small_obstacles: list[Position];
    has enemies: list[Position];
    has player_pos: Position;
}

obj LevelManager {
    has current_level: int = 0, current_difficulty: int = 1,
        prev_levels: list[Level] = [], prev_level_maps: list[Map] = [];

    def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
    -> Level by llm();

    def create_next_map(level: Level) -> Map by llm();
}
```

### Node Definition (`node`)
Nodes are similar to objects but are specifically designed for graph-like structures, allowing for connections (edges) between them.

```jac
node Person{
    has name: str;
    has email: str;
}

node EmailNode{
    has sender: str;
    has recipients: str;
    has date: str;
    has subject: str;
    has body: str;
    has email_uuid: str;
}
```