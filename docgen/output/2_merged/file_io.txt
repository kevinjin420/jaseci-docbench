# File I/O

## File I/O

### `file` Module
The `file` module provides functionalities for file operations.

-   `file.open(path: str, mode: str = "r") -> File`: Opens a file at the given `path` with the specified `mode`.
    -   `path`: The path to the file.
    -   `mode`: The mode in which to open the file. Common modes include:
        -   `"r"`: Read (default).
        -   `"w"`: Write (truncates the file if it exists, creates a new one otherwise).
        -   `"a"`: Append (creates a new file if it doesn't exist).
        -   `"x"`: Exclusive creation (fails if the file already exists).
        -   `"b"`: Binary mode (e.g., `"rb"`, `"wb"`).
        -   `"t"`: Text mode (default, e.g., `"rt"`, `"wt"`).
    -   Returns a `File` object.

-   `file.read(file_obj: File, length: int = -1) -> str`: Reads data from the `file_obj`.
    -   `file_obj`: The `File` object to read from.
    -   `length`: The number of characters/bytes to read. If `-1` (default), reads the entire file.
    -   Returns the read content as a string.

-   `file.write(file_obj: File, data: str) -> int`: Writes `data` to the `file_obj`.
    -   `file_obj`: The `File` object to write to.
    -   `data`: The string data to write.
    -   Returns the number of characters/bytes written.

-   `file.close(file_obj: File)`: Closes the `file_obj`. It's good practice to close files after use to free up resources.

-   `file.exists(path: str) -> bool`: Checks if a file or directory exists at the given `path`.
    -   Returns `True` if the path exists, `False` otherwise.

-   `file.remove(path: str)`: Deletes the file at the given `path`.

-   `file.load_json(path: str) -> Any`: Reads a JSON file and parses its content into a JACL value.
    -   `path`: The path to the JSON file.
    -   Returns the parsed JACL value.

-   `file.save_json(path: str, data: Any)`: Writes a JACL value to a file in JSON format.
    -   `path`: The path to the output JSON file.
    -   `data`: The JACL value to serialize and save.

### `os` Module
The `os` module provides functions for interacting with the operating system.

-   `os.system(command: str) -> int`: Executes a shell command.
    -   `command`: The shell command to execute.
    -   Returns the exit status of the command.

-   `os.getenv(key: str) -> str | None`: Retrieves the value of an environment variable.
    -   `key`: The name of the environment variable.
    -   Returns the value as a string, or `None` if the variable is not set.

-   `os.setenv(key: str, value: str)`: Sets the value of an environment variable.
    -   `key`: The name of the environment variable.
    -   `value`: The value to set.

-   `os.mkdir(path: str)`: Creates a directory.

-   `os.rmdir(path: str)`: Removes an empty directory.

-   `os.listdir(path: str) -> list[str]`: Returns a list of entries in the directory given by `path`.

### `json` Module
The `json` module provides functions for working with JSON data.

-   `import:py from json {dumps, loads}`: Imports `dumps` and `loads` from Python's `json` module.

-   `dumps(obj: Any, indent: int | None = None) -> str`: Serializes a Python object (or JACL value) to a JSON formatted string.
    -   `obj`: The object to serialize.
    -   `indent`: If provided, specifies the indentation level for pretty-printing.
    -   Returns the JSON string.

-   `loads(s: str) -> Any`: Deserializes a JSON formatted string to a Python object (or JACL value).
    -   `s`: The JSON string to deserialize.
    -   Returns the deserialized object.

### `logging` Module
The `logging` module provides a flexible framework for emitting log messages.

-   `import:py from logging {getLogger, INFO, WARNING, ERROR, DEBUG}`: Imports logging functions and levels.

-   `getLogger(name: str | None = None) -> Logger`: Returns a logger instance.
    -   `name`: The name of the logger. If `None`, returns the root logger.

-   `Logger.info(msg: str)`: Logs a message with level `INFO`.
-   `Logger.warning(msg: str)`: Logs a message with level `WARNING`.
-   `Logger.error(msg: str)`: Logs a message with level `ERROR`.
-   `Logger.debug(msg: str)`: Logs a message with level `DEBUG`.

### Persistence
-   `save(item: Any, path: str)`: Saves a JACL item to a file.
    -   `item`: The JACL item to save.
    -   `path`: The file path where the item will be saved.

-   `load(path: str) -> Any`: Loads a JACL item from a file.
    -   `path`: The file path from which to load the item.
    -   Returns the loaded JACL item.

### Examples

#### Basic File Operations
```jac
with file.open("my_file.txt", "w") as f:
    file.write(f, "Hello, JACL!\n")
    file.write(f, "This is a test.")

with file.open("my_file.txt", "r") as f:
    content = file.read(f)
    print(content)

if file.exists("my_file.txt"):
    file.remove("my_file.txt")
```

#### JSON File Operations
```jac
obj = {"name": "Alice", "age": 30, "isStudent": false}
file.save_json("data.json", obj)

loaded_obj = file.load_json("data.json")
print(loaded_obj.name) # Output: Alice
```

#### Using `os.system`
```jac
exit_code = os.system("echo Hello from shell!")
print(f"Command exited with code: {exit_code}")
```

#### Using `logging`
```jac
import:py from logging {getLogger, INFO};

logger = getLogger("my_app")
logger.setLevel(INFO) # Set the logging level
logger.info("This is an informational message.")
```

#### Agent Persistence
```jac
node Agent {
    has name: str;
    has count: int = 0;
}

walker init_agent {
    spawn Agent(name="PersistentAgent");
}

walker update_and_save {
    can save, load;
    root {
        a = spawn Agent(name="PersistentAgent");
        a.count += 1;
        save(a, "agent_state.jac");
        print(f"Agent {a.name} saved with count: {a.count}");
    }
}

walker load_and_continue {
    can save, load;
    root {
        a = load("agent_state.jac");
        print(f"Agent {a.name} loaded with count: {a.count}");
        a.count += 1;
        save(a, "agent_state.jac");
        print(f"Agent {a.name} updated and saved with count: {a.count}");
    }
}
```