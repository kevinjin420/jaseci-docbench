# Strings and Text

## Strings and Text

### String Literals
Strings are sequences of characters enclosed in single (`'...'`) or double (`"..."`) quotes.

```jac
with entry {
    greeting = "Hello";
    name = "Bob";
    message = 'Welcome to Jac!';
    print(greeting); # Shows: Hello
}
```

### Formatted String Literals (f-strings)
F-strings allow embedding expressions inside string literals by prefixing the string with `f` or `F` and placing expressions inside curly braces `{}`.

```jac
print(f"sum: {add} prod:{mult}");
```

**Features:**
-   Full feature parity with Python-style f-strings.
-   Support for multi-line formatted strings using triple quotes: `f"""Hello {name}"""`.
-   Unicode characters are properly preserved.

**Examples:**
```jac
with entry {
    name: str = "Alice";
    age: int = 25;
    height: float = 5.6;
    is_student: bool = True;

    print(f"{name} is {age} years old");
    message = f"Hello, {name}! You are {age} years old.";
    print(message);
}
```

### Semantic Strings (`sem`)
Semantic strings (semstrings) provide natural language descriptions or additional context to code elements (objects, enums, functions, parameters). They are primarily used by Large Language Models (LLMs) for intelligent code generation, execution, and decision-making.

**Usage:**
Use the `sem` keyword followed by the element to annotate and its description.

```jac
# Annotating an object
obj PhotoAnalyzer {
    has photographer_name: str;
    has style_preference: str;
    has image: Image;
}
sem PhotoAnalyzer = "Professional photo analysis tool for photographers";
sem PhotoAnalyzer.photographer_name = "Name of the photographer for personalized analysis";
sem PhotoAnalyzer.style_preference = "Preferred photography style (artistic, documentary, commercial)";

# Annotating an enum for LLM routing
enum RoutingNodes {
    TASK_HANDLING;
    EMAIL_HANDLING;
    GENERAL_CHAT;
}
sem RoutingNodes.TASK_HANDLING = "Creating/deleting/updating/summarizing tasks to TODO";
sem RoutingNodes.EMAIL_HANDLING = "Composing and managing emails";
sem RoutingNodes.GENERAL_CHAT = "Providing intelligent answers, productivity advice, and general AI assistance across various topics.";

# Annotating function parameters
obj Person {
    has name;
    has dob;
    has ssn;
}
sem Person = "Represents the personal record of a person";
sem Person.name = "Full name of the person";
sem Person.dob = "Date of Birth";
sem Person.ssn = "Last four digits of the Social Security Number of a person";

"""Calculate eligibility for various services based on person's data."""
def check_eligibility(person: Person, service_type: str) -> bool by llm();
```

**Best Practices:**
-   Clearly describe **what** the element does and **when** to use it.
-   Be specific about capabilities and use cases.
-   Include examples if the purpose might be ambiguous.
-   For objects, annotate key fields to help the LLM understand the data structure.