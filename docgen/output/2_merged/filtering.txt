# Filtering and Selection

## Filtering and Selection

JacLang provides flexible filtering mechanisms to control graph traversal and operations, allowing precise selection of nodes and edges based on specific criteria. These filters enable developers to optimize traversal and focus only on relevant parts of the graph.

### Jac Clouds Traverse API Filtering

The Jac Clouds Traverse API supports control over traversal results using the following parameters:

-   `source`: Starting node/edge. Defaults to root.
-   `detailed`: If response includes archetype context. Defaults to `False`.
-   `depth`: How deep the traversal from source. Count includes edges. Defaults to `1`.
-   `node_types`: Node filter by name. Can be declared multiple times to include multiple node types (e.g., `node_types=Node1&node_types=Node2`). Defaults to no filter (all node types).
-   `edge_types`: Edge filter by name. Can be declared multiple times to include multiple edge types (e.g., `edge_types=Edge1&edge_types=Edge2`). Defaults to no filter (all edge types).

### Node-Based Filtering

Node-based filtering restricts traversal to specific nodes that satisfy predefined conditions. This is useful when you need to limit traversal to nodes with certain attributes or properties, or filter nodes dynamically based on walker state or external context.

#### Example: Filtering by Node Type and Attributes

```jac
walker filter_nodes {
    has visited_nodes: list[node] = [];

    can entry {
        root {
            spawn --[a, b, c]--> node::A(val=5);
            spawn --[a, b, c]--> node::B(val=10);
            spawn --[a, b, c]--> node::C(val=15);
            spawn --[a, b, c]--> node::C(val=25);
            spawn --[a, b, c]--> node::A(val=20);
        }
        visit *;
    }

    node::A, node::B, node::C {
        if (here.val > 10) {
            self.visited_nodes.append(here);
        }
    }
}
```

### Edge-Based Filtering

Edge filtering in JacLang allows developers to control traversal by selecting edges based on specific attributes or conditions. This is especially useful in scenarios where certain edges in the graph are more relevant to the task at hand, such as weighted graphs or context-sensitive connections.

#### Example: Filtering by Edge Attributes

```jac
walker filter_edges {
    has visited_nodes: list[node] = [];

    can entry {
        root {
            spawn --[a(val=10)]--> node::A(val=10);
            spawn --[a(val=20)]--> node::A(val=20);
            spawn --[b(val=30)]--> node::A(val=30);
        }
        visit *;
    }

    edge::a {
        if (here.val > 15) {
            self.visited_nodes.append(here);
        }
    }
}
```

### Logging Filtering

Jac Cloud logs are structured in JSON format, making it easy to filter and search for specific information using tools like Kibana.

```json
{
  "timestamp": "2024-04-10T14:25:36.789Z",
  "level": "INFO",
  "message": "Request processed successfully",
  "request": {
    "method": "POST",
    "path": "/walker/create_user",
    "headers": {"authorization": "Bearer ***", "content-type": "application/json"},
    "body": {"username": "example_user", "email": "user@example.com"}
  },
  "response": {
    "status_code": 200,
    "body": {"status": 200, "reports": ["User created successfully"]}
  },
  "duration": 125,
  "client_ip": "192.168.1.1"
}
```