# Types and Variables

# Types and Variables

Jac emphasizes type safety and readability, requiring type hints. The built-in typing system reduces boilerplate imports.

## Primitive Types

### Text (Strings)
Strings are sequences of characters enclosed in single or double quotes.
```jac
with entry {
    greeting = "Hello";
    name = "Bob";
    message = "Welcome to Jac!";

    print(greeting);
}
```

### Numbers (Integers)
Integers are whole numbers without decimal points.
```jac
with entry {
    apples = 5;
    students = 30;
    year = 2024;

    print(apples);
}
```

### Numbers (Floats)
Floats are numbers with decimal points.
```jac
with entry {
    temperature = 72.5;
    price = 19.99;
    pi = 3.14159;

    print(temperature);
}
```

### True or False (Booleans)
Booleans represent truth values, either `True` or `False`.
```jac
with entry {
    is_raining = True;
    is_sunny = False;

    print(is_raining);
}
```

## Type Annotations

Type annotations are recommended and can be applied to variables, function parameters, and return types. Fields may specify types and default values directly on declaration.

### Basic Type Annotations
```jac
with entry {
    name: str = "Alice";      # str means string (text)
    age: int = 25;            # int means integer (whole number)
    height: float = 5.6;      # float means decimal number
    is_student: bool = True;  # bool means boolean (True/False)

    print(f"{name} is {age} years old");
}
```

### Collection Types
```jac
with entry {
    numbers: list = [1, 2, 3];
    coords: tuple = (10, 20);
    person: dict = {"name": "Alice", "age": 25};
    unique: set = {1, 2, 3};

    print(f"Name: {name}, Age: {age}");
    print(f"Numbers: {numbers}");
}
```

### Optional Types (Python Interop)
```python
from typing import Optional

class Person(Node):
    name: str
    age: Optional[int] = None
```

## Archetypes

Jac extends the traditional class paradigm with four distinct archetype classes, incorporating object-spatial semantics.

### Object Classes (`obj`)
Conventional classes, analogous to traditional OOP class types. They serve as foundational building blocks.
```jac
obj Tweet {
    has content: str, author: str, timestamp: str, likes: int = 0;

    def like() -> None;
    def unlike() -> None;
    def get_preview(max_length: int) -> str;
    def get_like_count() -> int;
}
```
Implementation of object methods:
```jac
impl Tweet.like() -> None {
    self.likes += 1;
}

impl Tweet.unlike() -> None {
    if self.likes > 0 {
        self.likes -= 1;
    }
}

impl Tweet.get_preview(max_length: int) -> str {
    return self.content[:max_length] + "..." if len(self.content) > max_length else self.content;
}

impl Tweet.get_like_count() -> int {
    return self.likes;
}
```

### Node Classes (`node`)
Extend object classes and can be connected via edges. Nodes represent discrete locations or entities within a topological graph structure. They encapsulate data, compute, and the potential for connections.
```jac
node Person {
    has name: str;
}
```
```jac
node Post {
    has content: str;
    has author: str;
}
```

### Edge Classes (`edge`)
Represent directed relationships between two node instances. Edges encode both the topology and semantics of connections. They are first-class object entities with their own properties and behaviors, and are traversable locations for walkers.

### Walker Classes (`walker`)
Model autonomous entities that traverse node and edge objects. Walkers represent active computational elements that move through the data topological structure, processing data or triggering behaviors.
```jac
walker Greeter {
    has greeting_count: int = 0;
```
```jac
walker create_post {
    has content: str, author: str;
```

## Enums
Enums define a set of named constant values.
```jac
enum Personality {
    INTROVERT,
    EXTROVERT,
    AMBIVERT
}
```

## Variables

### Variable Declaration with Type Annotation
Variables can be declared with explicit type annotations.
```jac
has name: str;
```

### Variable Declaration with Default Value
Variables can be initialized with a default value.
```jac
has greeting_count: int = 0;
```

## Function and Method Signatures

### Function Definition
Functions can have type-annotated parameters and return types.
```jac
def calc_distance(x1: float, y1: float, x2: float, y2: float) -> float {
```

### LLM-driven Function Definition
Functions can be defined to be implemented by a Large Language Model.
```jac
def get_personality(name: str) -> Personality by llm();
```

## Standard Library Types (Python Interop)

-   `TYPE_CHECKING`: Python typing constant for type checking blocks.
-   `EdgeDir`: Enum for edge direction (`IN`, `OUT`, `ANY`).
-   `DSFunc`: Type alias for data spatial functions.

## Keywords and Operators

-   `has x: type`: Explicit type annotation for fields.
-   `&`: Reference operator.
-   `.edges`: Node property to access connected edges.
-   `str "..."`: Semantic String.
-   `async`, `await`: Asynchronous programming constructs.
-   `assert`: For testing and validation.
-   `save`, `load`: For persistence operations.

## Imports

-   `import:py`: Used for importing Python modules and functions.
    ```jac
    import:py from json {dumps};
    ```

## Control Flow Statements

### If Statement
```jac
IfStmt -->|Expr| condition
IfStmt -->|CodeBlockStmt| body
IfStmt -.->|ElseStmt , ElseIf| else_body
```

### Else If Statement
```jac
ElseIf -->|Expr| condition
ElseIf -->|CodeBlockStmt| body
ElseIf -.->|ElseStmt , ElseIf| else_body
```

### Else Statement
```jac
ElseStmt -->|CodeBlockStmt| body
```

### Try-Except-Finally Statement
```jac
TryStmt -->|CodeBlockStmt| body
TryStmt -->|Except| excepts
TryStmt -.->|ElseStmt| else_body
TryStmt -.->|FinallyStmt| finally_body
```
```jac
Except -->|Expr| ex_type
Except -.->|Name| name
Except -->|CodeBlockStmt| body
```
```jac
FinallyStmt -->|CodeBlockStmt| body
```

### For Loop (Iterable)
```jac
InForStmt -->|Expr| target
InForStmt -->|bool| is_async
InForStmt -->|Expr| collection
InForStmt -->|CodeBlockStmt| body
InForStmt -.->|ElseStmt| else_body
```

### For Loop (Iterative)
```jac
IterForStmt -->|Assignment| iter
IterForStmt -->|bool| is_async
IterForStmt -->|Expr| condition
IterForStmt -->|Assignment| count_by
IterForStmt -->|CodeBlockStmt| body
IterForStmt -.->|ElseStmt| else_body
```

### While Loop
```jac
WhileStmt -->|Expr| condition
WhileStmt -->|CodeBlockStmt| body
WhileStmt -.->|ElseStmt| else_body
```
Agent Loop Pattern:
```jac
while (condition) by llm():
    // Agent logic
```

### With Statement
```jac
WithStmt -->|bool| is_async
WithStmt -->|ExprAsItem| exprs
WithStmt -->|CodeBlockStmt| body
```

## Other Statements

### Assert Statement
```jac
AssertStmt -->|Expr| condition
AssertStmt -.->|Expr| error_msg
```

### Raise Statement
```jac
RaiseStmt -.->|Expr| cause
RaiseStmt -.->|Expr| from_target
```

### Return Statement
```jac
ReturnStmt -.->|Expr| expr
```

### Delete Statement
```jac
DeleteStmt -->|Expr| target
```

### Report Statement
```jac
ReportStmt -->|Expr| expr
```

### Control Statement
```jac
CtrlStmt -->|Token| ctrl
```

## Types and Variables

### Basic Types

*   **`str "..."`**: Semantic String.
*   **`bool`**: Boolean values (`True`, `False`).
*   **`int`**: Integer values.
*   **`float`**: Floating-point values.

### Type Annotations

Explicit type annotations are supported using `has x: type`.

```jac
node Person {
    has name: str;
    has age: int;
}
```

### Variables and Assignment

Variables are declared and assigned using `=`. Type tags can be used during assignment.

```jac
number = 1 + 2;
```

### Data Structures

*   **List (`ListVal`)**: Ordered, mutable collection.
    ```jac
    my_list = [1, 2, 3];
    ```
*   **Set (`SetVal`)**: Unordered collection of unique elements.
    ```jac
    my_set = {1, 2, 3};
    ```
*   **Tuple (`TupleVal`)**: Ordered, immutable collection.
    ```jac
    my_tuple = (1, 2, 3);
    ```
*   **Dictionary (`DictVal`)**: Unordered collection of key-value pairs.
    ```jac
    my_dict = {"key": "value", "num": 123};
    ```
    Key-value pairs are represented by `KVPair` (for general expressions as keys) and `KWPair` (for name atoms as keys).

### Comprehensions

Jac supports list, set, dictionary, and generator comprehensions.

*   **List Comprehension (`ListCompr`)**
    ```jac
    my_list = [x for x in my_collection if x > 0];
    ```
*   **Generator Comprehension (`GenCompr`)**
    ```jac
    my_gen = (x for x in my_collection if x > 0);
    ```
*   **Set Comprehension (`SetCompr`)**
    ```jac
    my_set = {x for x in my_collection if x > 0};
    ```
*   **Dictionary Comprehension (`DictCompr`)**
    ```jac
    my_dict = {k: v for k, v in my_collection if k != "ignore"};
    ```
    `InnerCompr` represents the internal structure of a comprehension, including `is_async`, `target`, `collection`, and `conditional`.

### Expressions

*   **`AwaitExpr`**: For `async`/`await` operations.
*   **`ConcurrentExpr`**: For concurrent execution.
*   **`BinaryExpr`**: Binary operations (e.g., `+`, `-`, `==`).
*   **`CompareExpr`**: Comparison operations (e.g., `a < b < c`).
*   **`BoolExpr`**: Boolean logic operations (e.g., `and`, `or`, `not`).
*   **`LambdaExpr`**: Anonymous functions.
*   **`UnaryExpr`**: Unary operations (e.g., `-x`, `not y`).
*   **`IfElseExpr`**: Ternary conditional expressions.
*   **`YieldExpr`**: For generator functions, with optional `with_from`.

### Strings

*   **`MultiString`**: Concatenation of multiple strings.
*   **`FString`**: Formatted string literals (f-strings).
    *   `FormattedValue`: Represents parts within an f-string, including `format_part`, `conversion`, and `format_spec`.

### Function Calls

*   **`FuncCall`**: Represents a function call, including `target`, `params`, and optional `genai_call`.

### Indexing and Slicing

*   **`IndexSlice`**: For accessing elements by index or slice, including `is_range`.

### Control Flow

*   **`VisitStmt`**: Used for graph traversal.
*   **`GlobalStmt`**: Declares a global variable.
*   **`NonLocalStmt`**: Declares a non-local variable.

### Object-Oriented Programming

*   **Nodes (`node`)**: Fundamental building blocks for graph structures.
    ```jac
    node Person {
        has name: str;
        has age: int;

        def greet -> str {
            return f"Hello, I'm {self.name}!";
        }
    }
    ```
*   **Edges (`edge`)**: Connect nodes, forming relationships.
    ```jac
    edge Friend {
        has since: int;
        has strength: int = 5;
    }
    ```
*   **Inheritance**: Nodes can inherit properties and methods from other nodes.
    ```jac
    node Entity {
        has id: str;
        has created: str;
    }

    node Person(Entity) {
        has email: str;
    }
    ```
*   **`self`**: Refers to the current instance of a node or edge.
*   **`here`**: In walkers, refers to the current node being visited.

### Graph Operations

*   **Connecting Nodes**:
    ```jac
    alice +>:Friend(since=2015, strength=9):+> bob;
    root ++> alice ++> bob;
    ```
    `ConnectOp` represents connection operations, including `conn_type`, `conn_assign`, and `edge_dir`.
*   **Disconnecting Nodes**:
    ```jac
    node1 -:EdgeType:- node2;
    ```
    `DisconnectOp` represents disconnection operations, including `edge_spec`.
*   **Edge References (`.edges`)**: Accessing edges connected to a node.
    ```jac
    friends = [alice ->:Friend:->];
    ```
    `EdgeRefTrailer` represents edge reference operations, including `chain`, `edges_only`, and `is_async`.
*   **Edge Operators (`EdgeOpRef`)**: Used in graph traversal and manipulation, including `filter_cond` and `edge_dir`.
*   **Filter Comprehensions (`FilterCompr`)**: Used to filter edges or nodes based on conditions.
    ```jac
    [-->:EdgeType(field == value):-->]
    ```
    Includes `f_type` and `compares`.
*   **Assignment Comprehensions (`AssignCompr`)**: Used to assign values to edge properties during connection.
    ```jac
    +>:EdgeType(prop=value):+>
    ```
    Includes `assigns`.

### Walkers (`walker`)

Walkers are autonomous agents that traverse the graph.

*   **Definition**:
    ```jac
    walker Greeter {
        has greeting_count: int = 0; # Walker state

        can start with `root entry {
            print("Starting journey!");
            visit [-->]; # Begin traversal
        }

        can greet with Person entry {
            print(f"Hello, {here.name}!");
            self.greeting_count += 1;
            visit [-->]; # Continue traversal
        }
    }
    ```
*   **Spawning**: Launching a walker from a node.
    ```jac
    root spawn Greeter();
    ```
*   **`visit [-->]`**: Directs the walker to traverse connected nodes.
*   **`can <action> with <NodeType> entry`**: Defines behavior when a walker encounters a specific node type.
    *   `self`: Refers to the walker instance.
    *   `here`: Refers to the current node being visited.
*   **Action Order**: If a node has both a `can <action> with <WalkerType> entry` and a walker has a `can <action> with <NodeType> entry`, the node's action executes first.
    ```jac
    node Person {
        can greet_visitor with Visitor entry {
            print(f"{self.name} says: Welcome!"); # Executes first
        }
    }

    walker Visitor {
        can meet_person with Person entry {
            print(f"Visitor says: Hello, {here.name}!"); # Executes second
            visit [-->];
        }
    }
    ```

### Imports

*   **`import:py`**: For importing Python modules.
    ```jac
    import:py from json {dumps};
    import time at t;
    ```

### Asynchronous Programming

*   **`async`**: Defines an asynchronous function.
*   **`await`**: Pauses execution until an asynchronous operation completes.

### Testing and Validation

*   **`assert`**: Used for testing and validation.

### Persistence

*   **`save`**: Saves the current graph state.
*   **`load`**: Loads a graph state.

### Entry Point

*   **`with entry`**: The main execution block of a Jac program.
    ```jac
    with entry {
        print("Hello world!");
    }
    ```

## Types and Variables

Jac's type system provides powerful generic programming capabilities, type constraints, and graph-aware type checking. It supports flexible typing with `any`, runtime safety through built-in guards, and integrates type safety with nodes, edges, and walkers.

### The `any` Type

The `any` type provides maximum flexibility, allowing variables to hold values of any type. Type safety is maintained through runtime validation.

```jac
# data_processor.jac
obj DataProcessor {
    has items: list[any] = [];

    def add(item: any) -> None {
        self.items.append(item);
    }

    def process_all(func: any) -> list[any] {
        return [func(item) for item in self.items];
    }

    def find(predicate: any) -> any | None {
        for item in self.items {
            if predicate(item) {
                return item;
            }
        }
        return None;
    }

    def filter_by_type(target_type: any) -> list[any] {
        return [item for item in self.items if isinstance(item, target_type)];
    }
}

with entry {
    // Simple usage with type inference
    processor = DataProcessor();
    processor.add(42);
    processor.add("hello");
    processor.add(3.14);

    // Type-safe operations with runtime validation
    numbers = processor.filter_by_type(int);
    print(f"Numbers: {numbers}");
}
```

### Runtime Type Validation

Jac provides runtime type checking capabilities for robust error handling and dynamic type validation.

#### Type Guards and Validation

```jac
# type_validator.jac
obj TypeValidator {
    has strict_mode: bool = False;

    """Check if value matches expected type."""
    def validate_type(value: any, expected_type: any) -> bool {
        if expected_type == int {
            return isinstance(value, int);
        } elif expected_type == str {
            return isinstance(value, str);
        } elif expected_type == float {
            return isinstance(value, float);
        } elif expected_type == list {
            return isinstance(value, list);
        } elif expected_type == dict {
            return isinstance(value, dict);
        }
        return True;  // Allow any for unknown types
    }

    """Safely cast value to target type."""
    def safe_cast(value: any, target_type: any) -> any | None {
        try {
            if target_type == int {
                return int(value);
            } elif target_type == str {
                return str(value);
            } elif target_type == float {
                return float(value);
            } elif target_type == bool {
                return bool(value);
            }
            return value;
        } except ValueError {
            if self.strict_mode {
                raise ValueError(f"Cannot cast {value} to {target_type}");
            }
            return None;
        }
    }

    """Validate value is within specified range."""
    def validate_range(value: any, min_val: any = None, max_val: any = None) -> bool {
        if min_val is not None and value < min_val {
            return False;
        }
        if max_val is not None and value > max_val {
            return False;
        }
        return True;
    }
}

with entry {
    validator = TypeValidator(strict_mode=True);

    // Test type validation
    test_values = [42, "hello", 3.14, True, [1, 2, 3]];
    expected_types = [int, str, float, bool, list];

    for i in range(len(test_values)) {
        value = test_values[i];
        expected = expected_types[i];
        is_valid = validator.validate_type(value, expected);
        print(f"{value} is {expected}: {is_valid}");
    }

    // Test safe casting
    cast_result = validator.safe_cast("123", int);
    print(f"Cast '123' to int: {cast_result}");

    // Test range validation
    in_range = validator.validate_range(50, 0, 100);
    print(f"50 in range [0, 100]: {in_range}");
}
```

#### Advanced Type Guards (Schema Validation)

```jac
# advanced_validator.jac
obj SchemaValidator {
    has schema: dict[str, any] = {};

    """Define expected type for a field."""
    def set_field_type(field_name: str, field_type: any) -> None {
        self.schema[field_name] = field_type;
    }

    """Validate object against schema."""
    def validate_object(obj: any) -> dict[str, any] {
        results = {
            "valid": True,
            "errors": [],
            "field_results": {}
        };

        if not isinstance(obj, dict) {
            results["valid"] = False;
            results["errors"].append("Object must be a dictionary");
            return results;
        }

        for (field_name, expected_type) in self.schema.items() {
            if field_name not in obj {
                results["valid"] = False;
                results["errors"].append(f"Missing required field: {field_name}");
                results["field_results"][field_name] = False;
            } else {
                field_value = obj[field_name];
                is_valid = self.validate_field(field_value, expected_type);
                results["field_results"][field_name] = is_valid;
                if not is_valid {
                    results["valid"] = False;
                    results["errors"].append(f"Invalid type for {field_name}: expected {expected_type}, got {type(field_value)}");
                }
            }
        }

        return results;
    }

    """Validate individual field value."""
    def validate_field(value: any, expected_type: any) -> bool {
        if expected_type == "string" {
            return isinstance(value, str);
        } elif expected_type == "number" {
            return isinstance(value, (int, float));
        } elif expected_type == "boolean" {
            return isinstance(value, bool);
        } elif expected_type == "list" {
            return isinstance(value, list);
        } elif expected_type == "dict" {
            return isinstance(value, dict);
        }
        return True;
    }
}

with entry {
    // Create schema for user data
    user_validator = SchemaValidator();
    user_validator.set_field_type("name", "string");
    user_validator.set_field_type("age", "number");
    user_validator.set_field_type("email", "string");
    user_validator.set_field_type("active", "boolean");

    // Test valid user
    valid_user = {
        "name": "Alice",
        "age": 30,
        "email": "alice@example.com",
        "active": True
    };

    result = user_validator.validate_object(valid_user);
    print(f"Valid user validation: {result}");

    // Test invalid user
    invalid_user = {
        "name": "Bob",
        "age": "thirty",  // Wrong type
        "email": "bob@example.com"
        // Missing 'active' field
    };

    result = user_validator.validate_object(invalid_user);
    print(f"Invalid user validation: {result}");
}
```

### Graph-Aware Type Checking

Jac's type system extends to Object-Spatial Programming constructs, providing compile-time and runtime guarantees about graph structure and walker behavior.

#### Node and Edge Type Safety

```jac
# typed_graph.jac
node Person {
    has name: str;
    has age: int;

    def validate_person() -> bool {
        return len(self.name) > 0 and self.age >= 0;
    }
}

node Company {
    has company_name: str;
    has industry: str;

    def validate_company() -> bool {
        return len(self.company_name) > 0 and len(self.industry) > 0;
    }
}

edge WorksAt {
    has position: str;
    has salary: float;
    has start_date: str;

    def validate_employment() -> bool {
        return len(self.position) > 0 and self.salary > 0;
    }
}

edge FriendsWith {
    has since: str;
    has closeness: int;  // 1-10 scale

    def validate_friendship() -> bool {
        return self.closeness >= 1 and self.closeness <= 10;
    }
}

obj GraphValidator {
    has validation_errors: list[str] = [];

    """Validate any node type."""
    def validate_node(node: any) -> bool {
        self.validation_errors = [];

        if isinstance(node, Person) {
            if not node.validate_person() {
                self.validation_errors.append(f"Invalid person: {node.name}");
                return False;
            }
        } elif isinstance(node, Company) {
            if not node.validate_company() {
                self.validation_errors.append(f"Invalid company: {node.company_name}");
                return False;
            }
        } else {
            self.validation_errors.append(f"Unknown node type: {type(node)}");
            return False;
        }

        return True;
    }

    """Validate edge connection between nodes."""
    def validate_edge_connection(from_node: any, edge: any, to_node: any) -> bool {
        // Check if edge type is appropriate for node types
        if isinstance(edge, WorksAt) {
            // Person should work at Company
            if not (isinstance(from_node, Person) and isinstance(to_node, Company)) {
                self.validation_errors.append("WorksAt edge must connect Person to Company");
                return False;
            }
            return edge.validate_employment();
        } elif isinstance(edge, FriendsWith) {
            // Both nodes should be Person
            if not (isinstance(from_node, Person) and isinstance(to_node, Person)) {
                self.validation_errors.append("FriendsWith edge must connect Person to Person");
                return False;
            }
            return edge.validate_friendship();
        }

        self.validation_errors.append(f"Unknown edge type: {type(edge)}");
        return False;
    }
}

with entry {
    // Create graph elements
    alice = Person(name="Alice", age=30);
    bob = Person(name="Bob", age=25);
    tech_corp = Company(company_name="TechCorp", industry="Technology");

    // Create relationships
    works_edge = WorksAt(position="Developer", salary=75000.0, start_date="2023-01-15");
    friend_edge = FriendsWith(since="2020-01-01", closeness=8);

    // Validate graph elements
    validator = GraphValidator();

    // Validate nodes
    alice_valid = validator.validate_node(alice);
    print(f"Alice valid: {alice_valid}");

    // Validate edge connections
    work_connection_valid = validator.validate_edge_connection(alice, works_edge, tech_corp);
    print(f"Work connection valid: {work_connection_valid}");

    friend_connection_valid = validator.validate_edge_connection(alice, friend_edge, bob);
    print(f"Friend connection valid: {friend_connection_valid}");

    // Test invalid connection
    invalid_connection = validator.validate_edge_connection(alice, works_edge, bob);  // Wrong types
    print(f"Invalid connection valid: {invalid_connection}");
    print(f"Validation errors: {validator.validation_errors}");
}
```

#### Walker Type Validation

```jac
# typed_walkers.jac

node Person {
    has name: str;
    has age: int;

    def validate_person() -> bool {
        return len(self.name) > 0 and self.age >= 0;
    }
}

node Company {
    has company_name: str;
    has industry: str;

    def validate_company() -> bool {
        return len(self.company_name) > 0 and len(self.industry) > 0;
    }
}

edge WorksAt {
    has position: str;
    has salary: float;
    has start_date: str;

    def validate_employment() -> bool {
        return len(self.position) > 0 and self.salary > 0;
    }
}

edge FriendsWith {
    has since: str;
    has closeness: int;  // 1-10 scale

    def validate_friendship() -> bool {
        return self.closeness >= 1 and self.closeness <= 10;
    }
}

walker PersonVisitor {
    has visited_count: int = 0;
    has person_names: list[str] = [];
    has validation_errors: list[str] = [];

    can visit_person with Person entry {
        // Type-safe person processing
        if self.validate_person_node(here) {
            self.visited_count += 1;
            self.person_names.append(here.name);
            print(f"Visited person: {here.name} (age {here.age})");

            // Continue to connected persons
            friends = [->:FriendsWith:->(`?Person)];
            if friends {
                visit friends;
            }
        } else {
            print(f"Invalid person node encountered: {here.name}");
        }
    }

    can visit_company with Company entry {
        // Companies are not processed by PersonVisitor
        print(f"Skipping company: {here.company_name}");
    }

    """Validate person node before processing."""
    def validate_person_node(person: any) -> bool {
        if not isinstance(person, Person) {
            self.validation_errors.append(f"Expected Person, got {type(person)}");
            return False;
        }

        if not person.validate_person() {
            self.validation_errors.append(f"Invalid person data: {person.name}");
            return False;
        }

        return True;
    }
}

walker CompanyAnalyzer {
    has companies_visited: list[str] = [];
    has total_employees: int = 0;

    can analyze_company with Company entry {
        if self.validate_company_node(here) {
            self.companies_visited.append(here.company_name);
            print(f"Analyzing company: {here.company_name} in {here.industry}");

            // Count employees (people working at this company)
            employees = [<-:WorksAt:<-(`?Person)];
            employee_count = len(employees);
            self.total_employees += employee_count;

            print(f"  Employees: {employee_count}");
            for employee in employees {
                print(f"    - {employee.name}");
            }
        }
    }
}
```

## Types and Variables

Jac is a strongly typed language, requiring explicit type declarations for all variables. This enhances code readability, maintainability, and helps catch errors early.

### Basic Types

Jac supports common literal types:

*   **Integers (`int`)**: Whole numbers.
    ```jac
    with entry {
        student_id: int = 12345;
        print(student_id);
    }
    ```
*   **Floats (`float`)**: Numbers with a decimal point.
    ```jac
    with entry {
        gpa: float = 3.85;
        print(gpa);
    }
    ```
*   **Strings (`str`)**: Sequences of characters enclosed in quotes.
    ```jac
    with entry {
        student_name: str = "Alice Johnson";
        print(f"Student Name: {student_name}");
    }
    ```
*   **Booleans (`bool`)**: Represents `True` or `False`.
    ```jac
    with entry {
        is_enrolled: bool = True;
        print(f"Is enrolled: {is_enrolled}");
    }
    ```
*   **Any (`any`)**: A flexible type that can hold values of different types.
    ```jac
    with entry {
        grade_data: any = 95;
        print(f"Grade as number: {grade_data}");
        grade_data = "A";
        print(f"Grade as letter: {grade_data}");
    }
    ```

### Collection Types

*   **Lists (`list[type]`)**: Ordered, mutable collections of items.
    ```jac
    has interests: list[str] = [];
    has visited_locations: list[str] = [];
    has messages: list[str] = [];
    has present_students: list[str] = [];
    has absent_students: list[str] = [];
    has visited_nodes: list[str] = [];
    has visited_edges: list[str] = [];
    has loaded_tweets: list[dict] = [];
    has recommendations: list[dict] = [];
    ```
*   **Sets (`set[type]`)**: Unordered collections of unique items.
    ```jac
    has rooms_visited: set[str] = {};
    has users_visited: set[str] = set();
    ```
*   **Dictionaries (`dict[key_type, value_type]`)**: Unordered collections of key-value pairs.
    ```jac
    has config_data: dict[str, any] = {};
    ```

### Architypes

Jac introduces special architypes for graph-based programming:

*   **Nodes (`node`)**: Represent entities in the graph.
    ```jac
    node Person {
        has name: str;
        has age: int;
        has interests: list[str] = [];
        has visited: bool = False;
        has city: str;
        has level: int = 0;
        has priority: int;
    }
    ```
    ```jac
    node User {
        has username: str;
        has email: str;
        has created_at: str;
    }
    ```
    ```jac
    node Post {
        has title: str;
        has content: str;
        has likes: int = 0;
    }
    ```
    ```jac
    node Counter {
        has count: int = 0;
        def increment() -> None;
    }
    ```
    ```jac
    node UserProfile {
        has username: str;
        has bio: str = "";
    }
    ```
    ```jac
    node Profile {
        has username: str = "";
        has bio: str = "";
        has follower_count: int = 0;

        can update with update_profile entry;
        can follow with follow_request entry;
        can unfollow with unfollow_request entry;
    }
    ```
    ```jac
    node Tweet {
        has content: str;
        has created_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
        has like_count: int = 0;

        can update with update_tweet exit;
        can delete with remove_tweet exit;
        can like with like_tweet entry;
        can unlike with unlike_tweet entry;
    }
    ```
    ```jac
    node Comment {
        has content: str;
        has created_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");

        can update with update_comment entry;
        can delete with remove_comment entry;
    }
    ```
*   **Edges (`edge`)**: Represent relationships between nodes. Edges can also have properties.
    ```jac
    edge FriendsWith {
        has since: str;
        has closeness: int; # 1-10 scale
    }
    ```
    ```jac
    edge FamilyRelation {
        has relationship_type: str;
    }
    ```
    ```jac
    edge ParentOf {}
    ```
    ```jac
    edge ConnectedTo {
        has strength: int;
    }
    ```
    ```jac
    edge Follow {
        has followed_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
    }
    ```
    ```jac
    edge Post {
        has posted_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
    }
    ```
    ```jac
    edge Like {
        has liked_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
    }
    ```
    ```jac
    edge CommentOn {}
    ```
*   **Walkers (`walker`)**: Functions that traverse the graph.
    ```jac
    walker FindCommonInterests {
        has target_person: Person;
        has common_interests: list[str] = [];
    }
    ```
    ```jac
    walker debug_graph {
        has visited_nodes: list[str] = [];
        has visited_edges: list[str] = [];
        has max_depth: int = 3;
        has current_depth: int = 0;
    }
    ```
    ```jac
    walker feed_loader {
        has user_id: str;
        has loaded_tweets: list[dict] = [];
        has users_visited: set[str] = set();
        has errors: list[str] = [];
    }
    ```
    ```jac
    walker get_recommendations(visit_profile) {
        has limit: int = 5;
        has algorithm: str = "hybrid";
        has recommendations: list[dict] = [];
    }
    ```

### Objects (`obj`)

Custom data structures similar to classes in other languages.
```jac
obj ConfigReader {
    has config_file: str;
    has config_data: dict[str, any] = {};

    def load_config() -> bool;
    def get_value(key: str, default: any = None) -> any;
    def set_value(key: str, value: any) -> None;
    def save_config() -> bool;
    def create_default_config() -> None;
}
```
```jac
obj Application {
    has config: ConfigReader;
    has logger: any;

    def start() -> None;
    def setup_logging() -> None;
    def get_database_config() -> dict[str, any];
    def run_debug_mode() -> None;
    def run_normal_mode() -> None;
}
```
```jac
obj BookData {
    has title: str;
    has author: str;
    has isbn: str;
}
```

### Functions (`def`)

Functions define reusable blocks of code.
```jac
def calculate_average(numbers: list[float]) -> float {
    if len(numbers) == 0 {
        return 0.0;
    }
    return sum(numbers) / len(numbers);
}
```
```jac
def calculate_recommendation_score(
    current_user: Profile,
    candidate: Profile,
    followed_users: list[Profile]
) -> float {
    score = 0.0;
}
```
```jac
def get_recommendation_reason(
    current_user: Profile,
    candidate: Profile,
    followed_users: list[Profile]
) -> str {
}
```

## Types and Variables

### Functions
Functions are defined using the `def` keyword, followed by the function name, parameters with type annotations, and a return type annotation. The function body is enclosed in curly braces `{}`.

```jac
def function_name(param1: Type1, param2: Type2) -> ReturnType {
    // Function body
    return value;
}
```

**Example:**
```jac
def add_numbers(a: int, b: int) -> int {
    result: int = a + b;
    return result;
}
```

**Multiple Return Types:**
Functions can specify multiple possible return types using the `|` symbol.
```jac
def divide(a: float, b: float) -> float | str {
    if b == 0.0 {
        return "Error: Cannot divide by zero!";
    }
    return a / b;
}
```

### Lambda Functions
Lambda functions are concise, single-line, anonymous functions. They are useful for short, specific operations.
**Syntax:** `lambda parameters: return_type: expression`

```jac
# Example: A lambda function for addition
add = lambda x: float, y: float: x + y;

with entry {
    a: float = 10.0;
    b: float = 5.0;
    result: float = add(a, b);
    print(f"Result of add({a}, {b}) = {result}");
}
```

### Higher-Order Functions
Higher-order functions are functions that take other functions as arguments, return functions, or both. The `callable` type hint is used to specify that a parameter or return value is expected to be a function.

```jac
# Function taking another function as an argument
def calculator(a: float, b: float, operation: callable) -> float {
    return operation(a, b);
}

# Function returning a function
def create_multiplier(factor: float) -> callable[[float], float] {
    return lambda x: float: x * factor;
}

# Function composition
def compose(f: callable, g: callable) -> callable {
    return lambda x: any: f(g(x));
}

with entry {
    def add(a: float, b: float) -> float { return a + b; }
    result: float = calculator(10.0, 5.0, add);
    print(f"Calculator result: {result}");

    triple = create_multiplier(3.0);
    print(f"Triple 5.0: {triple(5.0)}");
}
```

### Built-in Higher-Order Functions

#### `filter`
Constructs a new iterable from elements of an existing one for which a given function returns `True`.
**Signature:** `filter(function, iterable)`

```jac
with entry {
    test_scores: list[int] = [78, 85, 92, 69, 88, 95, 72];
    passing_scores_iterator = filter(lambda score: float: score >= 70, test_scores);
    passing_scores: list[int] = list(passing_scores_iterator);
    print(f"Passing scores: {passing_scores}");
}
```

#### `map`
Applies a given function to every item of an iterable and returns an iterator of the results.
**Signature:** `map(function, iterable)`

```jac
def classify_grade(score: int) -> str {
    if score >= 90 { return "A"; }
    elif score >= 80 { return "B"; }
    elif score >= 70 { return "C"; }
    elif score >= 60 { return "D"; }
    else { return "F"; }
}

with entry {
    test_scores = [78, 85, 92, 69, 88, 95, 72];
    passing_scores = list(filter(lambda x: float: x >= 70, test_scores));
    grades = list(map(classify_grade, passing_scores));
    print(f"Grades: {grades}");
}
```

#### `sorted`
Returns a new sorted list from the items in an iterable. The `key` parameter can be used to customize sorting logic.
**Signature:** `sorted(iterable, *, key=None, reverse=False)`

```jac
with entry {
    student_records: list[tuple[str, int]] = [("Charlie", 88), ("Alice", 95), ("Bob", 72)];

    sorted_by_name = sorted(student_records, key=lambda record: str: record[0]);
    print(f"Sorted by name: {sorted_by_name}");

    sorted_by_score = sorted(student_records, key=lambda record: int: record[1], reverse=True);
    print(f"Sorted by score (desc): {sorted_by_score}");
}
```

### Variables and Data Structures

#### Type Annotations
Jac enforces type annotations for all variables and function signatures.
**Syntax:** `variable_name: Type = value;`

```jac
a: float = 10.0;
operation_name: str = "add";
```

#### Collections
Jac enforces type annotations for all collections.

*   **Lists:** Ordered collections of items. Declared with `list[ElementType]`.
    ```jac
    my_list: list[int] = [1, 2, 3];
    ```
*   **Dictionaries:** Key-value pairs. Declared with `dict[KeyType, ValueType]`.
    ```jac
    glob operations: dict[str, callable] = {
        "add": add,
        "subtract": subtract
    };
    ```
*   **Sets:** Unordered collections of unique items. Declared with `set[ElementType]`.
    ```jac
    my_set: set[str] = {"apple", "banana"};
    ```

### Nodes
Nodes are fundamental entities in Jac, often representing agents or data structures with properties and behaviors.

```jac
node Counter {
    has name: str;
    has value: int = 0; // Property with default value

    can increment(amount: int = 1) -> int { // Method with default parameter
        self.value += amount;
        return self.value;
    }

    can reset() -> int {
        self.value = 0;
        return self.value;
    }
}
```

**Node Properties:**
Nodes can have properties defined with the `has` keyword.
```jac
node HistoryEntry {
    has timestamp: str;
    has old_value: int = 0;
    has new_value: int = 0;
}
```

**Node Methods:**
Nodes can have methods defined with the `can` keyword. These methods operate on the node's properties.

**Node Relationships:**
Nodes can form relationships with other nodes.
*   `self ++> new_counter;` creates an edge from `self` to `new_counter`.
*   `[self --> Counter]` retrieves nodes of type `Counter` connected from `self`.
*   `[self --> Counter](?name == name)` filters connected nodes by a property.

### Entry Block
Executable scripts require an `with entry { ... }` block as their main entry point.

```jac
with entry {
    print("Hello, World!");
}
```

### Common Jac Syntax Requirements
*   **Semicolons:** All statements must end with a semicolon `;`.
*   **Type Annotations:** All variables, function parameters, and return types must have explicit type annotations.
*   **Braces for Blocks:** Code blocks (e.g., for functions, `if` statements, `with entry`) use curly braces `{}` instead of indentation.

## Types

### Enums
Enums define a set of named constant values. They can be used to strictly type outputs, especially when interacting with LLMs.

```jac
enum Role {
    VIEWER = "viewer",
    EDITOR = "editor",
    ADMIN = "admin"
}
```

```jac
enum Personality {
    INTROVERT,
    EXTROVERT,
    AMBIVERT
}
```

### Dataclasses
Dataclasses are Python classes primarily used to store data. They are supported as input and output types for `by llm()` functions.

```python
from dataclasses import dataclass, field
from typing import Any, Optional
from enum import Enum

@dataclass
class InlineCandidate:
    """Represents a function that can be inlined"""
    func_node: Any # uni.Ability
    call_site: Any # uni.FuncCall
    caller_node: Any # uni.Ability
    inline_priority: int  # Higher = inline first

@dataclass
class InlineContext:
    """Context for performing inlining"""
    variable_mapping: dict[str, str]  # Old name -> New name
    parent_scope: Any # uni.UniScopeNode
    depth: int  # Current inline depth

class FxOpType(Enum):
    """FX operation types (matching torch.fx)"""
    PLACEHOLDER = "placeholder"
    GET_ATTR = "get_attr"
    CALL_FUNCTION = "call_function"
    CALL_METHOD = "call_method"
    CALL_MODULE = "call_module"
    OUTPUT = "output"

@dataclass
class StaticFxNode:
    """Node in static FX graph"""
    op: FxOpType
    name: str
    target: Any
    args: tuple[Any, ...] = field(default_factory=tuple)
    kwargs: dict[str, Any] = field(default_factory=dict)

    # Additional static analysis info
    meta: dict[str, Any] = field(default_factory=dict)

    # Graph break annotation
    is_graph_break: bool = False
    graph_break_reason: Optional[str] = None
    graph_break_workaround: Optional[str] = None

    # Connections
    users: list['StaticFxNode'] = field(default_factory=list)

    def __repr__(self) -> str:
        args_repr = ', '.join(str(a) for a in self.args)
        kwargs_repr = ', '.join(f'{k}={v}' for k, v in self.kwargs.items())
        all_args = ', '.join(filter(None, [args_repr, kwargs_repr]))

        break_marker = " [GRAPH_BREAK]" if self.is_graph_break else ""
        return f"{self.name}: {self.op.value}[{self.target}]({all_args}){break_marker}"

@dataclass
class GraphBreakRegion:
    """Represents a region causing graph breaks"""
    reason: str
    nodes: list[StaticFxNode] = field(default_factory=list)
    source_loc: Any = None
    workaround: Optional[str] = None
    severity: str = "warning"  # "info", "warning", "error"

    # Detailed analysis
    analysis: dict[str, Any] = field(default_factory=dict)
    fixable: bool = False
```

## Type Checking

Jac provides extensive type checking capabilities:
-   **Type Annotation Validation**: Checks explicit type annotations in variable assignments for type mismatches.
-   **Type Inference**: Simple type inference for assignments with validation against declared types.
-   **Member Access Type Checking**: Type checking for member access patterns (e.g., `obj.field.subfield`).
-   **Import Symbol Type Checking**: Type inference for imported symbols.
-   **Function Call Return Type Validation**: Return type checking for function calls.
-   **Magic Method Support**: Type checking for special methods like `__call__`, `__add__`, `__mul__`.
-   **Binary Operation Type Checking**: Operator type validation with simple custom operator support.
-   **Class Instantiation**: Type checking for class constructor calls and member access.
-   **Cyclic Symbol Detection**: Detection of self-referencing variable assignments.
-   **Missing Import Detection**: Detection of imports from non-existent modules.
-   **Cross-Language Type Checking**: Supports loading and analyzing JavaScript (`.js`) and TypeScript (`.ts`, `.jsx`, `.tsx`) file dependencies when used with client-side (`cl`) imports.
-   **Object Spatial Codes**: Type checking support for the connect operator.
-   **Comprehensions**: Type checking support for assign comprehensions and filter comprehensions.
-   **Return Statements**: Improved type inference from return statements.
-   **Inheritance**: Fixed inheritance-based member lookup by properly iterating through MRO (Method Resolution Order) chain.
-   **Dataclasses**: Improved synthesized `__init__` method generation to correctly collect parameters from all base classes.
-   **Generics**: Type checking for generics, e.e., `dict[int, str]`.
-   **Typed Context Blocks (OSP)**: Fully implemented typed context blocks (`-> NodeType { }` and `-> WalkerType { }`) for Object-Spatial Programming.
-   **`Self` Type Resolution**: Added support for `Self` type resolution.
-   **Method Type Checking**: Enabled method type checking for tools.
-   **Inherited Symbol Resolution**: Improved inherited symbol resolution (e.g., `Cat` recognized as subtype of `Animal`).
-   **Float Type Validation**: Added float type validation.
-   **Parameter–Argument Matching**: Implemented parameter–argument matching in function calls.
-   **Call Expression Parameter Type Checking**: Enhanced call expression parameter type checking.
-   **Import Symbol Type Resolution**: Enhanced import symbol type resolution for better type inference and error detection.

Type errors appear in the Jac VS Code extension (VSCE) with error highlighting during editing.

## Scheduler Parameters

### General Job Parameters
| NAME          | TYPE                   | DESCRIPTION                                                                                   | DEFAULT     |
| ------------- | ---------------------- | --------------------------------------------------------------------------------------------- | ----------- |
| trigger       | str                    | trigger type (`cron`, `interval`, `date`)                                                     | N/A         |
| node          | str or None            | entry node if necessary, defaults to root                                                     | None        |
| args          | list[Any] or None      | list of arguments to initialize the walker                                                    | None        |
| kwargs        | dict[str, Any] or None | dict of keyword arguments to initialize the walker                                            | None        |
| max_instances | int                    | max simultaneous running job per walker type                                                  | 1           |
| next_run_time | datetime or None       | target date before the first trigger will happen                                              | None        |
| propagate     | bool                   | if multiple jac-cloud service can trigger at the same time or first service only per trigger | false       |
| save          | bool                   | if walker instance will be save to the db including the results                               | false       |

### Cron Trigger Parameters
| NAME        | TYPES                   | DESCRIPTION                                                | DEFAULT |
| ----------- | ----------------------- | ---------------------------------------------------------- | ------- |
| year        | int or str              | 4-digit year                                               | \*      |
| month       | int or str              | month (1-12)                                               | \*      |
| day         | int or str              | day of month (1-31)                                        | \*      |
| week        | int or str              | ISO week (1-53)                                            | \*      |
| day_of_week | int or str              | number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) | \*      |
| hour        | int or str              | hour (0-23)                                                | \*      |
| minute      | int or str              | minute (0-59)                                              | \*      |
| second      | int or str              | second (0-59)                                              | \*      |
| start_date  | datetime or str or None | earliest possible date/time to trigger on (inclusive)      | None    |
| end_date    | datetime or str or None | latest possible date/time to trigger on (inclusive)        | None    |

### Interval Trigger Parameters
| NAME       | TYPES                   | DESCRIPTION                             | DEFAULT |
| ---------- | ----------------------- | --------------------------------------- | ------- |
| weeks      | int                     | number of weeks to wait                 |         |
| days       | int                     | number of days to wait                  |         |
| hours      | int                     | number of hours to wait                 |         |
| minutes    | int                     | number of minutes to wait               |         |
| seconds    | int                     | number of seconds to wait               | 1       |
| start_date | datetime or str or None | starting point for the interval calculation |         |
| end_date   | datetime or str or None | latest possible date/time to trigger on |         |

### Date Trigger Parameters
| NAME     | TYPES           | DESCRIPTION                 | DEFAULT |
| -------- | --------------- | --------------------------- | ------- |
| run_date | datetime or str | the date/time to run the job at |         |

## Agent Patterns

### LLM-driven Agent Loop
This pattern demonstrates how to use an LLM to determine a value based on a defined enum type.

```jac
import from byllm.lib { Model }
glob llm = Model(model_name="gemini/gemini-2.0-flash");

enum Personality {
    INTROVERT,
    EXTROVERT,
    AMBIVERT
}

def get_personality(name: str) -> Personality by llm();

with entry {
    name = "Albert Einstein";
    result = get_personality(name);
    print(f"{result} personality detected for {name}");
}
```

```python
import jaclang
from byllm.lib import Model, by
from enum import Enum

llm = Model(model_name="gemini/gemini-2.0-flash")

class Personality(Enum):
    INTROVERT
    EXTROVERT
    AMBIVERT

@by(model=llm)
def get_personality(name: str) -> Personality: ...

name = "Albert Einstein"
result = get_personality(name)
print(f"{result} personality detected for {name}")
```

## Types and Variables

### Enums
Enums define a set of named constant values.

```jac
enum RoutingNodes {
  TASK_HANDLING,
  EMAIL_HANDLING,
  GENERAL_CHAT
}
```

### Objects
Objects are custom data structures that can hold properties.

```jac
obj TaskPartition {
  has task: str;
  has agent_type: RoutingNodes;
}

obj Person {
    has name: str;
    has age: int;
    has description: str | None;
}
```

### Type Annotations
Explicit type annotations can be used to define the type of a variable or object property.
```jac
has x: type
```

### Function Definitions
Functions can be defined with type hints for parameters and return values.
```jac
def generate_random_person() -> Person by llm();
```

### Traversal Parameters
These parameters are used for graph traversals.

| Name         | Type      | Description                                                                                                                                                                              | Default Value       |
| :----------- | :-------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------ |
| `source`     | `string`  | The **JID** of the starting root, node, or edge for the traversal.                                                                                                                       | Current user's root |
| `detailed`   | `boolean` | If `true`, the response will include the archetype's context for each traversed item.                                                                                                    | `false`             |
| `depth`      | `integer` | The maximum number of steps to traverse. Both nodes and edges are considered one step.                                                                                                   | `1`                 |
| `node_types` | `string`  | Can be declared multiple times to filter the traversal results by node type. For example, `node_types=Node1&node_types=Node2` will include only nodes that are `Node1` or `Node2` types. | All node types      |
| `edge_types` | `string`  | Can be declared multiple times to filter the traversal results by edge type. For example, `edge_types=Edge1&edge_types=Edge2` will include only edges that are `Edge1` or `Edge2` types. | All edge types      |

### Agent Patterns
Agent loops often involve calling LLMs to generate data.

```jac
with entry {
    person = generate_random_person();
    assert isinstance(person, Person);
    print(f"Generated Person: {person.name}, Age: {person.age}, Description: {person.description}");
}
```