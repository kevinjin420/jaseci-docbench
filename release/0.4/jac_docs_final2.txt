Jac: Py superset for AI+graph, LLM orchestration, agentic workflows. Integrates Jaseci. Executes on Py runtime (transpiles Jac to Py bytecode). Obj-oriented maps to `jaclang.lib.Obj`. Features: Hybrid (imperative, OO, aspect), Graph-based, OSP (node-walker, send computation to data), AI-centric, LLM Orchestration, Agentic Workflows, MTP (AI-driven query classification), MCP (modular AI tools), Multimodal AI, Scalability, Static Typing, Concurrency (async), Extensibility. Use for: Graph problems, deep LLM/AI integration, scaling prototypes to services, extending Py with graph/AI.
Syntax: Py, C++, Rust inspired. Comments: `# single`, `// single`, `/* multi */`, `#* multi *#`. Example: `#* Multi *#`. IDs: `_` or `a-zA-Z` start; then `_`, `a-zA-Z`, `0-9`. Case-sensitive. Keywords reserved.
Keywords: All Py keywords + Jac specific. Case-sensitive, lowercase. Context-specific.
Archetype/DS: `obj` (std obj), `node` (graph vertex), `edge` (graph connection), `walker` (graph traversal agent), `class` (Py-compatible class), `enum` (named constants), `graph` (graph scope).
Var/State: `has` (instance var, type hints req), `let` (module-level var), `glob` (global var), `global` (modify global in local scope: `global x;`), `nonlocal` (modify non-global enclosing scope: `nonlocal y;`).
Ability/Func: `can` (archetype method), `def` (std func, type annotations req), `impl` (separate impl from decl). `impl Type.m -> r {body}`. `impl Type.a with Ctx entry {body}`. `impl f(p:t,...) -> r {body}`. Examples: `impl Circle.area -> float {return math.pi * self.radius * self.radius;}`. `impl Person.greet with Room entry {return "Hello, I am " + self.name;}`. `impl calculate_distance(x:float, y:float) -> float {return math.sqrt(x*x + y*y);}`. `yield` (pause func, return val, generator), `return` (return val from func).
Control Flow: `if/elif/else`, `for item in iter`, `for i=10 to i<=20 by i+=2`, `while (cond)`, `match v {case 1: print("one"); case int() if 10<=x<15: print("range"); case _: print("else");}`, `try: except E as e: except: else:`, `break`, `continue`, `raise`, `assert`, `pass`.
Walker Control: `visit` (traverse to node/edge), `spawn` (create/start walker), `ignore` (exclude from traversal), `disengage` (terminate traversal), `report` (send result to spawner), `with entry` (module main exec block), `take` (move along edge), `await` (wait for yielded walker), `entry` (walker entry action), `exit` (walker exit action), `travel` (walker traversal action).
Concurrency: `flow` (concurrent non-blocking expr), `wait` (pause, await concurrent op), `async` (async func/ability), `sync` (sync exec decorator).
AI/LLM: `sem` (associate natural lang "semantic string" with code), `by` (defer task to LLM).
Misc: `del` (delete obj/prop/elem), `<>` (escape keywords: `<>node=90;`), `test` (define test cases), `import`, `from`, `as` (alias), `private` (restrict access), `public` (allow access), `std` (std lib namespace), `dot` (Graphviz output), `json` (JSON output), `csv` (CSV output), `md` (Markdown output), `text` (Plain text output), `visitor` (walker context in nodes/edges), `here` (current node/edge in walker abilities), `self` (current obj), `cl` (Experimental: client-side decls for JS, JSX, generates Py/JS), `true`, `false`, `null`, `inf`, `nan`.
Literals: Nums: `123`, `-45`, `3.14`, `1e-3`, `0xAF`, `0o755`, `0b1010`. Strings: `'hello'`, `"world"`, `"""multi\nline"""`, `f"value {var}"`, `r"C:\path"`. Bools: `True`, `False`. Null: `null`. Special: `inf`, `nan`.
Operators: Arith: `+,-,*,/,//,%,**`. Comp: `==,!=,<,>,<=,>=`. Logic: `and,or,xor,not`. Assign: `=`,`+=,-=,*=,/=,//=,%=,**=`. Member: `in,not in`. Identity: `is,is not`. Bitwise: `&,|,^,~,<<,>>`.
Program Exec: `with entry {code}` (replaces `if __name__ == "__main__":`). Example: `with entry {print("Welcome"); my_function("hello", 5); spawn MyWalker;}`.
Variables: Declared with `has` or `var`. Type annotations req. `has n:t=v`. Access: `:pub, :priv, :protect`. Example: `has count:int=0`. Store/manage data, strong typing. Local (block-scoped) or global.
Var Decl: `with entry {student_name:str="Alice"; grade:int=95; gpa:float=3.8; is_honor_student:bool=True;}`. Examples: `var x=10;`, `has name="Alice";`, `has count:int=0`.
Local Vars: `def add_numbers(a:int, b:int)->int {result:int=a+b; return result;}`. `with entry {sum=add_numbers(5,10); print(f"Sum: {sum}");}`.
Global Vars: Program-wide, `glob` keyword. For constants. `glob school_name:str="Jac High School"; glob passing_grade:int=60; glob honor_threshold:float=3.5;`. Access: `:g:school_name`. Example: `def get_school_info()->str {:g:school_name; return f"Welcome to {school_name}";}`. `with entry {print(get_school_info()); print(f"Honor threshold is {honor_threshold}");}`.
Var Assign/Ops: Assign: `score=0;`. Change: `score=10; score=score+5; score+=5;`. Assign Ops: `x+=y`, `x-=y`, `x*=y`, `x/=y`, `x//=y`, `x%=y`, `x**=y`. Math Ops: `sum=5+3;`, `difference=10-4;`, `product=6*7;`, `quotient=20/4;`, `remainder=17%5;`, `power=2**3;`, `total=(5+3)*2;`.
Data Types: Primitive: `int` (e.g., `12345`), `float` (e.g., `3.85`), `bool` (`True`/`False`), `str` (e.g., `"Alice Johnson"`), `null`. Collection: `list`, `dict`, `set`, `tuple`. Graph: `node`, `edge`, `walker`. User-defined: custom `node`/`edge`. Other: `bytes`, `datetime`, `uuid`, `type`, `enum`. `any`: dynamic typing. Example: `grade_data:any=95; print(f"Num: {grade_data}"); grade_data="A"; print(f"Letter: {grade_data}");`.
Type Hinting: `var:type`, `param:type`, `->return_type`. Multiple return types: `-> T1 | T2`. Example: `def divide(a:float, b:float)->float|str {if b==0.0 {return "Error"}; return a/b;}`.
Control Flow: Statements end with `;`.
Conditional: `if (cond) {code} else if (cond) {code} else {code}`. Match: `match x {case 1: print("one"); case int() if 10<=x<15: print("range"); case _: print("else");}`.
Loops: For: `for item in my_list {code}`. `for i=10 to i<=20 by i+=2 {print(f"element: {i}");}`. While: `while (cond) {code}`.
Exception Handling: `try: code except ExceptionType as e: handle except: catch_all`.
Functions: Group code for reuse. `def` or `func`. Params/return types specified.
Def: `func my_first_func(): pass` or `def greet {print("Hello");}`. Call: `greet();`.
Params: `def greet(name:str) {print(f"Hello, {name}!");}`. Call: `greet("Alice");`.
Multi Params: `def add(x:int, y:int) {sum=x+y; print(f"{x}+{y}={sum}");}`. Call: `add(5,3);`.
Return Vals: `def add(x:int, y:int)->int {return x+y;}`. `result=add(5,3);`.
Multi Return Vals: `def learnMultiple(x:int, y:int=5)->(int,int) {return`