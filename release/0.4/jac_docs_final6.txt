Abilities define behavior for nodes and walkers, triggered by events or explicit calls. Types of Abilities: Callable Abilities are explicitly called, similar to OOP methods. Visit-dependent Abilities are triggered automatically when a walker interacts with a node or performs a visit. Walker Abilities can be callable and visit-dependent. self refers to the walker instance. Visit-Dependent Walker Abilities execute when the walker visits a node or at specific points in its lifecycle. can <abilityname> with entry: Triggered once when the walker is spawned (initial entry point). can <abilityname> with <NodeType> entry: Executed each time the walker visits a node of the specified <NodeType>. can <abilityname> with exit: Triggered once when the walker finishes its traversal. can <abilityname> with <NodeType> exit: Executed each time the walker exits a node of the specified <NodeType>. can <abilityname> with `root entry`: Triggered when the walker starts its traversal from the root node. can <abilityname> with specificnode entry`: Triggered when the walker starts its traversal from a specific node. can <abilityname> with `root | specificnode entry`: Triggered when the walker starts its traversal from either the root or a specific node. Walker Ability Examples: walker Greeter { has greetingcount: int = 0; can start with `root entry { print("Starting journey!"); visit [-->]; } can greet with Person entry { print(f"Hello, {here.name}!"); self.greetingcount += 1; visit [-->]; } } walker createpost { has content: str, author: str; can funcname with `root entry { newpost = Post(content=self.content, author=self.author); here ++> newpost; report {"id": newpost.id, "status": "posted"}; } } import from datetime {datetime} walker publicinfo { obj specs { static has methods: list = ["get"]; static has auth: bool = False; } can getcurrenttime with `root entry{ report { "timestamp": datetime.now().isoformat() }; } } walker searchusers { has query: str; static has users: list = [ {"username": "alice", "email": "alice@example.com"}, {"username": "bob", "email": "bob@example.com"} ]; obj specs { static has methods: list = ["get"]; static has asquery: list = ["query"]; static has auth: bool = False; } can searchbyname with `root entry{ for user in self.users { if user['username'] == self.query { report user; return; } } report { "error": f"User with username {self.query} not found" }; } } import from fastapi { UploadFile } walker singlefileupload { has file: UploadFile; obj specs { static has methods: list = ["post"]; static has auth: bool = False; } can enter with `root entry { report { "output": f"Received file: {self.file.filename}" }; } } Walker Lifecycle Abilities: walker Walker { can entry1 with entry { print("walker entry"); } can entry2 with `root entry { print("walker enter to root"); visit [-->]; } can entry3 with Node entry { print(f"{here.val}-1"); } can exit1 with Node exit { print(f"{here.val}-6"); } can exit2 with exit { print("walker exit"); } } Node Abilities can be callable and visit-dependent. self refers to the node instance. here refers to the visiting walker instance. Visit-Dependent Node Abilities are triggered when a specific walker interacts with the node. can <abilityname> with entry: Triggered when any walker enters the node. can <abilityname> with <WalkerType> entry: Triggered when a walker of the specified <WalkerType> enters the node. can <abilityname> with exit: Triggered when any walker exits the node. can <abilityname> with <WalkerType> exit: Triggered when a walker of the specified <WalkerType> exits the node. Node Ability Examples: node Node { has val: str; can entry1 with entry { print(f"{self.val}-2"); } can entry2 with Walker entry { print(f"{self.val}-3"); } can exit1 with Walker exit { print(f"{self.val}-4"); } can exit2 with exit { print(f"{self.val}-5"); } } node testnode { has value: int; can logentry with entry { print(f">>> Some Walker entered the node: ", self); } can logtestwalkerentry with testwalker entry { print(f">>> {here} entered the node {self}"); here.callable(); } can logtestwalkerexit with testwalker exit { print(f"<<< {here} exited the node {self}"); } can logexit with exit { print(f"<<< Some Walker exited the node {self}"); } def callable { print(f"===== Callable on {self}"); } } Node Implementation (impl): Node abilities can be implemented separately from their definition. node Profile { has username: str; can update with updateprofile entry; } impl Profile.update { self.username = here.newusername; report self; } Agentic System Node Abilities: Nodes can act as agents, maintaining local state and responding to visitor events. can execute with taskmanager entry { print("[TaskHandling Node Activated]"); response = self.routeandrun(visitor.curtask.task); print("â†’", response); report { "utterance": visitor.curtask.task, "response": response, "nodetype": self.class.name }; } can execute with `root entry { # Step 1: Plan - decompose the user's request subtasks = self.plantasks(self.utterance); print("[Planned Subtasks]:", subtasks); # Step 2: Map agent types to node classes nodemap = { RoutingNodes.TASKHANDLING: TaskHandling, RoutingNodes.EMAILHANDLING: EmailHandling, RoutingNodes.GENERALCHAT: GeneralChat }; # Step 3: Execute - route and visit each agent for subtask in subtasks { nodetype = nodemap[subtask.agenttype]; routednode = [-->(`?nodetype)]; # Check if agent exists if not routednode { routednode = here ++> nodetype(); # Create if doesn't exist } self.curtask = subtask; # Pass subtask to agent visit routednode; # Trigger agent's can execute ability } } AI Agents in Jac enable intelligent applications with task planning, code generation, and multi-agent workflows. They maintain state, reason, act using tools, and persist context. Agent Characteristics: Maintains State (e.g., chathistory), Reasons (e.g., using ReAct), Acts (uses external tools), Persists Context (builds understanding across multiple turns). Agent Loop Example: Agents often operate within a loop, generating responses and updating their state. def chatwithplayer(player: Person, npc: Person, chathistory: list[Chat]) -> Chat by llm(method="ReAct", tools=[maketransaction]); while True { # AI agent generates response with state chat = chatwithplayer(player, npc, history); history.append(chat); } Stateful AI Agents: AI agents can maintain persistent state across interactions. The chathistory parameter in chatwithplayer() retains conversation context, allowing agents to build understanding and reference previous interactions. Tool Integration: AI agents can access application functions through tools. An AI agent can call functions like maketransaction. The AI extracts parameters from natural language. Tool results are incorporated into responses. State Management: AI agents maintain state through: Structured data objects (e.g., Person, InventoryItem), Conversation history (e.g., Chat objects), Global registries (e.g., personrecord). Structured datatypes provide a vocabulary for communicating concepts to the AI, enabling natural language interactions that result in functional mechanics. AI Integration: Jac integrates AI directly into the programming model, simplifying the development of AI-powered applications. It provides language-level constructs and a runtime that seamlessly uses machine learning models, reducing prompt engineering and making agent workflows natural. by llm() Keyword: The by llm() keyword enables functions to process inputs and generate contextually appropriate outputs of a specified type using an LLM. It automatically generates optimized prompts, removing the need for manual prompt engineering and enabling seamless model integration. import from byllm.lib {Model} glob llm = Model(modelname="gemini/gemini-2.0-flash"); def getpersonality(name: str) -> Personality by llm(); Python Equivalent: import jaclang from byllm.lib import Model, by from enum import Enum llm = Model(modelname="gemini/gemini-2.0-flash") class Personality(Enum): INTROVERT EXTROVERT AMBIVERT @by(model=llm) def getpersonality(name: str) -> Personality: ... AI Function Types: AI Functions (Stateless): AI-integrated functions that operate without persistent state. These are AI-powered utilities. def makeplayer() -> Person by llm(); def makerandomnpc() -> Person by llm(); AI Agents (Stateful): AI systems that maintain persistent state across interactions. def chatwithplayer(player: Person, npc: Person, chathistory: list[Chat]) -> Chat by llm(method="ReAct", tools=[maketransaction]); Agent Characteristics: Maintains State (uses chathistory), Reasons (processes conversation context using the specified method, e.g., "ReAct"), Acts (can use tools specified in the tools parameter), Persists Context (builds understanding across multiple conversation turns). Tool Integration: AI agents can access application functions through tools. The tools parameter in by llm() allows specifying functions for the AI to call. The AI extracts parameters from natural language. Tool results are incorporated into responses. byLLM supports adding methods of classes as tools, e.g., tools=[ToolHolder.tool]. Streaming with ReAct Tool Calling: Real-time streaming support for the ReAct method when using tools. After tool execution, the LLM streams the final synthesized answer token-by-token. byLLM Framework: byLLM is an AI integration framework built for the Jaseci ecosystem, implementing the Meaning Typed Programming (MTP) paradigm. It embeds prompt engineering directly into code semantics, making AI interactions more natural and maintainable. byLLM can be used as a Python library or natively within Jac. Installation: pip install byllm Core Concepts: Meaning Typed Programming (MTP): Embeds prompt engineering directly into code semantics. Semantic Strings (sem): Attach natural language descriptions to code elements (functions, classes, parameters). These annotations can be used by LLMs for intelligent, AI-powered code generation and execution. In Jac: obj Person { has name:str; has age:int; has ssn: int; } sem Person.ssn = "last four digits of the Social Security number"; In Python (work-in-progress, syntax may change): from jaclang import JacRuntimeInterface as Jac from dataclasses import dataclass @Jac.sem('<Person Semstring>', { 'name' : '<name semstring>', 'age' : '<age semstring>', 'ssn' : "<ssn semstring>" }) @dataclass class Person: name: str age: int ssn: int Agentic AI Workflows: Leveraging Jac's graph-based semantics, byLLM supports the creation of interacting agents that collaborate, share memory, and act on dynamic context. byLLM in Jac: Model Initialization: Models are initialized using the Model class from byllm.lib. import from byllm.lib { Model } glob llm = Model(modelname="gpt-4o"); Basic Usage: import from byllm.lib { Model } glob llm = Model(modelname="gpt-4o"); def translateto(language: str, phrase: str) -> str by llm(); with entry { output = translateto(language="Welsh", phrase="Hello world"); print(output); } Using Enums as Return Types: import from byllm.lib { Model } glob llm = Model(modelname="gemini/gemini-2.0-flash"); enum Personality { INTROVERT, EXTROVERT, AMBIVERT } def getpersonality(name: str) -> Personality by llm(); with entry { name = "Albert Einstein"; result = getpersonality(name); print(f"{result} personality detected for {name}"); } Hyper-parameters: Hyper-parameters are set by passing them to the by llm() call: import from byllm.lib { Model } glob llm = Model(modelname="gpt-4o") def generatejoke() -> str by llm(temperature=0.3); byLLM in Python: byLLM can be integrated into Python applications. It is recommended to implement AI features in Jaclang and import the Jac module into Python for seamless interoperability. Importing byLLM in Python: import jaclang from dataclasses import dataclass from byllm.lib import Model, Image, by llm = Model(modelname="gpt-4o") @dataclass class Person: fullname: str description: str yearofbirth: int @by(llm) def getpersoninfo(img: Image) -> Person: ... img = Image("https://bricknellschool.co.uk/wp-content/uploads/2024/10/einstein3.webp") person = getpersoninfo(img) print(f"Name: {person.fullname}, Description: {person.description}, Year of Birth: {person.yearofbirth}") Hyper-parameters in Python: import jaclang from byllm.lib import Model, by llm = Model(modelname="gpt-4o") @by(llm(temperature=0.3)) def generatejoke() -> str: ... Using Python Functions as Tools: Python functions can be used as tools callable by the LLM: import jaclang from byllm.lib import Model llm = Model(modelname="gpt-4o") def getweather(city: str) -> str: return f"The weather in {city} is sunny." @by(llm(tools=[getweather])) def answer_question(question: str) -> str: ... Custom Model Declaration: Custom model interfaces can be defined by using the BaseLLM class from byllm.lib. This is useful for self-hosted models or custom APIs. from byllm.llm import BaseLLM from openai import OpenAI class MyOpenAIModel(Base