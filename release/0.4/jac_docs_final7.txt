Abilities are methods within nodes/walkers, callable or visit-dependent. Callable abilities are like OOP methods; self refers to the node/walker. Visit-dependent abilities trigger on walker-node interactions or walker state changes. here (node ability) is the visiting walker; self (walker ability) is the walker. Walkers prioritize their own visit-dependent abilities. Walker Abilities: can <abilityname> with entry: Triggered once when walker spawns, before visiting nodes. can <abilityname> with exit: Triggered once when walker finishes traversal. Example: walker Walker { can entry1 with entry { print("walker entry"); } can exit2 with exit { print("walker exit"); } } Walker Node-Specific Entry/Exit Abilities: can <abilityname> with <nodetype> entry: Executed each time walker visits a node of specified type. can <abilityname> with <nodetype> exit: Executed each time walker exits a node of specified type. Example: walker Greeter { has greetingcount: int = 0; can greet with Person entry { print(f"Hello, {here.name}!"); self.greetingcount += 1; visit [-->]; } } Walker Root Entry Abilities: can <abilityname> with `root entry`: Triggered when walker starts traversal from root node. Example: walker Greeter { can start with `root entry { print("Starting journey!"); visit [-->]; } } Walker Root/Node Entry Combinations: can <abilityname> with `root | specificnode entry`: Triggered if walker enters through root or specific node. Example: walker walkername { can walkerability with `root | specificnode entry; } Node Abilities: Node Entry/Exit Abilities: can <abilityname> with entry: Triggered when any walker enters the node. can <abilityname> with exit: Triggered when any walker exits the node. Example: node Node { has val: str; can entry1 with entry { print(f"{self.val}-2"); } can exit2 with exit { print(f"{self.val}-5"); } } Node Walker-Specific Entry/Exit Abilities: can <abilityname> with <walkertype> entry: Triggered when a walker of specified type enters the node. can <abilityname> with <walkertype> exit: Triggered when a walker of specified type exits the node. Example: node testnode { has value: int; can logtestwalkerentry with testwalker entry { print(f">>> {here} entered the node {self}"); here.callable(); } can logtestwalkerexit with testwalker exit { print(f"<<< {here} exited the node {self}"); } } Agentic Patterns: Nodes act as agents, maintaining local state, responding to visitor events. can execute with <walkertype> entry is common. Example: can execute with taskmanager entry { print("[TaskHandling Node Activated]"); response = self.routeandrun(visitor.curtask.task); print("â†’", response); report { "utterance": visitor.curtask.task, "response": response, "nodetype": self.class.name }; } Orchestrator walker manages agent nodes: can execute with `root entry { subtasks = self.plantasks(self.utterance); print("[Planned Subtasks]:", subtasks); nodemap = { RoutingNodes.TASKHANDLING: TaskHandling, RoutingNodes.EMAILHANDLING: EmailHandling, RoutingNodes.GENERALCHAT: GeneralChat }; for subtask in subtasks { nodetype = nodemap[subtask.agenttype]; routednode = [-->(`?nodetype)]; if not routednode { routednode = here ++> nodetype(); } self.curtask = subtask; visit routednode; } } AI Agents: Maintain state, execute actions, interact with tools. Characteristics: Maintains State (e.g., chathistory), Reasons (e.g., ReAct), Acts (uses tools), Persists Context. Agent Patterns: Agent Loops: Agents often operate in a loop. Example: while True { chat = chatwithplayer(player, npc, history); history.append(chat); } Stateful Agents: Maintain persistent state. Example: def chatwithplayer(player: Person, npc: Person, chathistory: list[Chat]) -> Chat by llm(method="ReAct", tools=[maketransaction]); chathistory retains context. Tool Integration: Agents access functions via tools. by llm() decorator specifies tools. AI extracts parameters, incorporates tool results. State Management: Structured data, conversation history, global registries. AI Integration: Jac integrates AI directly. Key Concepts: by llm: Language construct for optimized prompt generation, seamless model integration. Usable as Python library or natively in Jac. Native Agentic AI Workflows: OSP's graph semantics support agentic workflows for interacting agents. Meaning Typed Programming (MTP): Embeds prompt engineering into code semantics. Model Context Protocol (MCP): Enables modular, reusable AI tools. byLLM Framework: AI integration framework for Jaseci, implements MTP. Jac native and Python library interfaces. Installation: pip install byllm Model Configuration: Module: byllm.lib Model(modelname: str, apikey: str = None, baseurl: str = None, proxyurl: str = None, verbose: bool = False, method: str = None, tools: list = None, hyperparams: dict = None) -> Model modelname (Required): Model name (e.g., "gpt-4o"). apikey (Optional): API key. baseurl (Optional): API endpoint URL. proxyurl (Optional): Proxy URL, sets baseurl. verbose (Optional): Enable verbose logging. method (Optional): LLM method ('Reason' for step-by-step reasoning). tools (Optional): List of tool functions for ReAct. hyperparams (Optional): Model-specific parameters (e.g., temperature). Model Initialization (Jac): import from byllm.lib {Model} glob llm = Model(modelname="gpt-4o", verbose=True); Model Initialization (Python): from byllm.lib import Model llm = Model(modelname="gemini/gemini-2.0-flash") AI-Powered Functions (by llm): Functions integrated with LLM via by llm declaration. Function Definition with by llm() (Jac): import from byllm.lib { Model } glob llm = Model(modelname="gpt-4o"); def translate(text: str, targetlanguage: str) -> str by llm(); def analyzesentiment(text: str) -> str by llm(); def summarize(content: str, maxwords: int) -> str by llm(); Functions with Reasoning: method='Reason' enables step-by-step reasoning. import from byllm.lib { Model } glob llm = Model(modelname="gpt-4o"); def analyzesentiment(text: str) -> str by llm(method='Reason'); Function Definition with @by decorator (Python): from byllm.lib import Model, by from enum import Enum llm = Model(modelname="gemini/gemini-2.0-flash") class Personality(Enum): INTROVERT EXTROVERT AMBIVERT @by(model=llm) def getpersonality(name: str) -> Personality: ... Hyper-parameters: Passed to LLM model. Jac: import from byllm.lib { Model } glob llm = Model(modelname="gpt-4o") def generatejoke() -> str by llm(temperature=0.3); Python: import jaclang from byllm.lib import Model, by llm = Model(modelname="gpt-4o") @by(llm(temperature=0.3)) def generatejoke() -> str: ... AI Agents (Stateful): Maintain persistent state, build understanding. Agent Loop Example: with entry { history = []; while True { chat = chatwithplayer(player, npc, history); history.append(chat); print("\n[[npc]] >> ", chat.message); inp = input("\n[[Player input]] >> "); history.append(Chat(person=player.name, message=inp)); } } Tool Integration (ReAct): by llm(method="ReAct", tools=[...]) enables LLM to use specified functions, extract parameters, incorporate tool results. def chatwithplayer(player: Person, npc: Person, chathistory: list[Chat]) -> Chat by llm(method="ReAct", tools=[maketransaction]); LiteLLM Proxy: Use a model via LiteLLM proxy server. from byllm.lib import Model llm = Model( modelname="gpt-4o", apikey="yourlitellmapikey", proxyurl="http://localhost:8000", ) apikey is for LiteLLM proxy. Custom LLM Model: Create custom LLM bypassing LiteLLM. import from byllm.llm { BaseLLM } import from openai { OpenAI } obj MyOpenAIModel(BaseLLM){ has modelname: str; has config: dict = {}; def postinit() { super().init(modelname=self.modelname, kwargs); } def modelcallnostream(params: dict) { client = OpenAI(apikey=self.apikey); response = client.chat.completions.create(params); return response; } def modelcallwithstream(params: dict) { client = OpenAI(apikey=self.apikey); response = client.chat.completions.create(stream=True, *params); return response; } } Initialize custom model: glob llm = MyLLM(modelname="gpt-4o"); OpenAI API key: export OPENAIAPIKEY="your-api-key-here" LLM Agent Interaction: import from byllm.llm { Model } import from datetime { datetime } class Person { has name: str; has dob: str; has age: int; } def act(person: Person, npc: str, history: list) -> str: chat = chatwithperson(person, npc, history); history.append(chat); print(f"\n[[npc.name]] >> {chat.message}"); inp = input(f"\n[[player.name]] >> "); chat.append(chat(person=person, message=a)); return a; Chat History Structure: chathistory is a list of chat objects. Each chat object has: person: Sender. message: Content. time: Timestamp. id: Chat ID. reply: Reply content. replyid: Reply ID. replyto: Chat object this message replies to. replyfrom: Chat object this message is replied from. Control Flow: Dictates instruction execution order. Jac uses curly braces {} for code blocks. Conditional Statements: if, elif, else execute blocks based on conditions. Operators: > (Greater than), < (Less than), >= (Greater than or equal), <= (Less than or equal), == (Equal to), != (Not equal to). Logical Operators: and (Both true), or (At least one true), not (Reverses condition). Example: if st.button("Calculate") { if operation == "Add" { result = num1 + num2; } elif operation == "Subtract" { result = num1 - num2; } elif operation == "Multiply" { result = num1 num2; } elif operation == "Divide" { if num2 != 0 { result = num1 / num2; } else { st.error("Cannot divide by zero!"); return; } } st.success("Result: " + str(result)); } Example: if not st.sessionstate.token { with st.form("loginform") { email = st.textinput("Email"); password = st.textinput