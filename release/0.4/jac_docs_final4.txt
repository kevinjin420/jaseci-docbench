Abilities&Interactions: Abilities: m that auto-execute on graph traversal events. Types: Callable (std m, `self`=node/walker), Visit-dependent (walker-node interaction). `can` Keyword: `can <ability_n> [with <trigger_cond>] {...}`. Trigger Conditions: Walker Entry/Exit on Nodes: `entry` (any walker enters node), `<walker_n> entry` (specific walker enters node), `exit` (any walker exits node), `<walker_n> exit` (specific walker exits node). Ex: `node test_node {has value:int; can log_entry with entry {print(f">>> Some Walker entered the node: ", self);}. can log_test_walker_entry with test_walker entry {print(f">>> {here} entered the node {self}"); here.callable();}. can log_test_walker_exit with test_walker exit {print(f"<<< {here} exited the node {self}");}. can log_exit with exit {print(f"<<< Some Walker exited the node {self}");}. def callable {print(f"===== Callable on {self}");}}`. Walker Entry/Exit on Specific Node Types (within Walker): `root entry` (walker starts from root), `<node_t> entry` (walker enters node of type), `<node_t> exit` (walker exits node of type), `exit` (walker finishes traversal). Ex: `walker Greeter {has greeting_count:int=0; can start with `root entry {print("Starting journey!"); visit [-->];}. can greet with Person entry {print(f"Hello, {here.name}!"); self.greeting_count += 1; visit [-->];}}`. Multiple Trigger Conditions: `|` operator. Ex: `walker walker_name {can walker_ability with `root | specific_node entry;}`. Context Keywords: `self` (current node/walker instance), `here` (visited node/visiting walker instance). Ex `here`: `node node_name {can node_ability with walker_name entry{print("Current walker : ", here);}}. walker walker_name {can log_visit with test_node entry{print("Visiting node : ", here);}}`. Walker Attributes&Abilities: Walkers have a & callable/visit-dependent abilities. Walker visit-dependent abilities execute before node's. Ex: `walker create_post {has content:str, author:str; can func_name with `root entry {new_post = Post(content=self.content, author=self.author); here ++> new_post; report {"id": new_post.id, "status": "posted"};}}`. `report` Statement: returns data from ability. Ex: `import from datetime {datetime} walker public_info {obj __specs__ {static has methods:list=["get"]; static has auth:bool=False;} can get_current_time with `root entry{report {"timestamp": datetime.now().isoformat()};}}`. `obj __specs__` for API Endpoints: metadata for API exposure. `static has methods:list` (HTTP methods), `static has as_query:list` (walker `has` a mapped from query p), `static has auth:bool` (auth required). Ex: `walker search_users {has query:str; static has users:list=[{"username": "alice", "email": "alice@example.com"},{"username": "bob", "email": "bob@example.com"}]; obj __specs__ {static has methods:list=["get"]; static has as_query:list=["query"]; static has auth:bool=False;} can search_by_name with `root entry{for user in self.users {if user['username'] == self.query {report user; return;}} report {"error": f"User with username {self.query} not found"};}}`. File Uploads: `UploadFile` from `fastapi` in walker `has` a. Ex: `import from fastapi { UploadFile } walker single_file_upload {has file:UploadFile; obj __specs__ {static has methods:list=["post"]; static has auth:bool=False;} can enter with `root entry {report {"output": f"Received file: {self.file.filename}"};}}`. Node&Walker Interaction Sequence: 1. Walker's `entry` (e.g., `entry`, `<node_t> entry`, `root entry`). 2. Node's `entry` (e.g., `entry`, `<walker_n> entry`). 3. Walker's `exit` (e.g., `<node_t> exit`, `exit`). 4. Node's `exit` (e.g., `exit`, `<walker_n> exit`). Ex: `node Node {has val:str; can entry1 with entry {print(f"{self.val}-2");} can entry2 with Walker entry {print(f"{self.val}-3");} can exit1 with Walker exit {print(f"{self.val}-4");} can exit2 with exit {print(f"{self.val}-5");}} walker Walker {can entry1 with entry {print("walker entry");} can entry2 with `root entry {print("walker enter to root"); visit [-->];} can entry3 with Node entry {print(f"{here.val}-1");} can exit1 with Node exit {print(f"{here.val}-6");} can exit2 with exit {print("walker exit");}}`.
AIAgents&Integration: Overview: AI Agents for intelligent routing, specialized handling, multi-agent workflows. Orchestrate external tools, coordinate interactions. Supports small agentic patterns, lightweight multi-step reasoning, multi-turn planning, simple agents. `byLLM` Framework: AI integration framework for Jaseci, implements MTP. Jac & Python interfaces. Installation: `pip install byllm`. Key Features: Streaming with ReAct Tool Calling, Custom Model Declaration (`BaseLLM`), Lazy Loading (`byllm.lib`), NonGPT Fallback (mock impl), Enum Support (no values in prompts), Semantic Strings (`sem`) for LLM generation/execution, LiteLLM Proxy Integration. LLM Configuration: Module: `byllm.lib`. `Model` Class: `Model(model_n:str, api_key:str=None, base_url:str=None, proxy_url:str=None, verbose:bool=False, method:str=None, tools:list=None, hyperparams:dict=None)`. Args: `model_n` (str, Req: "gpt-4o", "gemini/gemini-2.0-flash", "ollama/llama3:70b"), `api_key` (str, Opt), `base_url` (str, Opt), `proxy_url` (str, Opt, sets `base_url`), `verbose` (bool, Opt), `method` (str, Opt: 'Reason' for step-by-step, 'ReAct' for agentic/tool-calling, Default: std generation), `tools` (list, Opt: tool f for ReAct), `hyperparams` (dict, Opt: model-specific, e.g., `temperature`, `max_tokens`). Model Init Ex: `import from byllm.lib {Model} glob llm = Model(model_name="gpt-4o"); glob llm = Model(model_name="gemini/gemini-2.0-flash"); glob llm = Model(model_name="claude-3-5-sonnet-20240620"); glob llm = Model(model_name="ollama/llama3:70b"); glob llm = Model(model_name="huggingface/meta-llama/Llama-3.3-70B-Instruct"); glob llm = Model(model_name="gpt-4o", verbose=True); glob llm = Model(model_name="gpt-4o", api_key="your_litellm_api_key", proxy_url="http://localhost:8000");`. LLM-Integrated Functions (`by llm`): `def f_n(p1:T1, ...) -> R by llm(method="MethodName", tools=[tool1, tool2, ...], hyperparam=v);`. Characteristics: Auto-gen prompts, strict type adherence for R. Ex: Stateless AI: `def get_personality(name:str)->Personality by llm(); def make_player()->Person by llm(); def make_random_npc()->Person by llm(); def translate(text:str, target_language:str)->str by llm(); def analyze_sentiment(text:str)->str by llm(); def summarize(content:str, max_words:int)->str by llm();`. Reasoning: `method='Reason'`. Ex: `def analyze_sentiment(text:str)->str by llm(method='Reason'); def generate_response(original_text:str, sentiment:str)->str by llm(method='Reason');`. Hyper-parameters: `by llm(temperature=0.3)`. Ex: `def generate_joke()->str by llm(temperature=0.3);`. AI Agents (Stateful): Maintain persistent state. Ex: `def chat_with_player(player:Person, npc:Person, chat_history:list[Chat])->Chat by llm(method="ReAct", tools=[make_transaction]);`. Agent Characteristics: Maintains State (`chat_history`), Reasons (`method`), Acts (`tools`), Persists Context. Tool Integration: `tools` p in `Model` constructor or `by llm` declaration. AI extracts p from NL. Tool Definition: Class methods as tools: `tools=[ToolHolder.tool]`. State Management: Structured data, conversation history, global registries. Ex Usage: Game Loop: `while True {chat = chat_with_player(player, npc, history); history.append(chat);}`. Ex Usage: RPG Level Generator: `import from byllm.lib { Model } glob llm = Model(model_name="gpt-4o", verbose=True); obj LevelManager {has current_level:int=0, current_difficulty:int=1, prev_levels:list[Level]=[], prev_level_maps:list[Map]=[]; def create_next_level (last_levels:list[Level], difficulty:int, level_width:int, level_height:int)->Level by llm(); def create_next_map(level:Level)->Map by llm(); def get_next_level->tuple(Level, Map) {self.current_level += 1; if len(self.prev_levels) > 3 {self.prev_levels.pop(0); self.prev_level_maps.pop(0);} new_level = self.create_next_level(self.prev_levels, self.current_difficulty, 20, 20); self.prev_levels.append(new_level); new_level_map = self.create_next_map(new_level); self.prev_level_maps.append(new_level_map); if self.current_level % 2 == 0 {self.current_difficulty += 1;} return (new_level, new_level_map);}}`. Core Concepts: `by llm` Keyword (auto-gen prompts, no manual prompt engineering). Native Agentic AI Workflows (OSP, graph-based semantics for interacting agents, shared memory, dynamic contexts). Meaning Typed Programming (MTP: embeds prompt engineering into code semantics). Model Context Protocol (MCP: modular, reusable AI tools). `byLLM` Usage in Jac: LLM-Integrated Function: `def get_personality(name:str)->Personality by llm();`. Basic Ex: `import from byllm.lib { Model } glob llm = Model(model_name="gpt-4o"); def translate_to(language:str, phrase:str)->str by llm(); with entry {output = translate_to(language="Welsh", phrase="Hello world"); print(output);}`. Types with LLMs (Enums): `import from byllm.lib { Model } glob llm = Model(model_name="gemini/gemini-2.0-flash"); enum Personality {`.
API&REST: Jac Cloud: Transforms Jac apps into production-ready API servers. Features: Deploys.