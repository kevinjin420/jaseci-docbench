Abilities are event-driven or callable methods attached to walkers, nodes, and archetypes. Callable abilities are invoked directly like methods using def. Visit-dependent abilities auto-execute on triggers using syntax: can abilityname with triggertype { ... }. Trigger types include: entry (walker enters node/starts), exit (walker exits node/ends), `root entry` (walker starts at root), NodeType entry (walker enters specific node type), WalkerType entry (specific walker enters), and combined triggers like `root | NodeType entry`. Walker execution order follows: 1. Walker entry ability (once at spawn), 2. Walker visit-dependent abilities, 3. Node visit-dependent abilities, 4. Walker exit ability. Context keywords define scope: self refers to the current instance (Walker in walker abilities, Node in node abilities). here refers to the interaction context (Node in walker abilities, Walker in node abilities). Abilities can be declared on the archetype and implemented separately using impl Archetype.abilityname { ... }. Common patterns include API Endpoint Walkers using `root entry` to report results, Cache Checks querying existing nodes via [-->(`?Type)], and defining static obj specs for API configuration (methods, auth). Functions are defined using def and require type annotations for parameters and return values. Syntax supports positional-only /, keyword-only , and kwargs. Multiple returns use tuple types. Generators use yield. Global variables defined with glob name: type = val are accessed using :g: name. Callables can be passed as types. Lambda syntax is lambda parameters: returntype: expression, for example: lambda x: int: x x.