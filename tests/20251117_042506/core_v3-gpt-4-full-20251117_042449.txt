{
  "metadata": {
    "model": "gpt-4o",
    "model_alias": "gpt-4",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {PENDING, ACTIVE, COMPLETED};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#* This is a\nmulti-line comment *#",
    "basic_07": "name: str = \"Jac\";\ngreeting: str = f\"Hello, {name}\";",
    "basic_08": "value: str|int = \"Hello\";",
    "basic_09": "squares: list[int] = [x * x for x in range(1, 6)];",
    "basic_10": "num: int = 0;\n\nif num > 0 {\n    print(\"Positive\");\n} elif num < 0 {\n    print(\"Negative\");\n} else {\n    print(\"Zero\");\n}",
    "control_01": "count: int = 1;\n\nwhile count <= 5 {\n    print(count);\n    count += 1;\n}",
    "control_02": "status: str = \"active\";\n\nmatch status {\n    case \"active\":\n        print(\"Active status\");\n    case \"inactive\":\n        print(\"Inactive status\");\n    case _:\n        print(\"Unknown status\");\n}",
    "control_03": "for i in range(10) {\n    if i == 5 {\n        break;\n    }\n    print(i);\n}",
    "control_04": "for i in range(10) {\n    if i % 2 == 0 {\n        continue;\n    }\n    print(i);\n}",
    "collection_01": "numbers: set[int] = set();\nnumbers.add(1);\nnumbers.add(2);",
    "collection_02": "person: tuple[str, int] = (\"Alice\", 30);",
    "collection_03": "squares: dict[int, int] = {x: x * x for x in range(1, 6)};",
    "collection_04": "names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n\nfor name in names {\n    print(name);\n}",
    "collection_05": "ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n\nage = ages.get(\"Alice\");",
    "type_01": "value: any = \"Hello\";\n\nif isinstance(value, str) {\n    print(\"It's a string\");\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.brand} ({self.year})\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "square = lambda x: int: x * x;",
    "obj_06": "obj MyObject {\n    has :priv: secret: str;\n}",
    "obj_07": "obj MyObject {\n    has :pub: info: str;\n}",
    "obj_08": "def my_decorator(func: callable[[], None]) -> callable[[], None] {\n    def wrapper() {\n        print(\"Before\");\n        func();\n        print(\"After\");\n    }\n    return wrapper;\n}\n\n@my_decorator\ndef my_function() {\n    print(\"Inside function\");\n}",
    "obj_09": "def execute(callable_func: callable[[], None]) {\n    callable_func();\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello {name}\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n    has population: int;\n}\n\ncity1 = City(name=\"City1\", population=100000);\ncity2 = City(name=\"City2\", population=150000);\n\ncity1 <++> city2;",
    "graph_03": "edge Road {\n    has distance: float;\n}\n\ncity1 +>:Road:distance=10.5:+> city2;",
    "graph_04": "node MyNode {\n    can enter with Walker entry {\n        print(\"Entered node\");\n    }\n}",
    "graph_05": "node MyNode {\n    can visit with Walker entry {\n        print(f\"Visited by {visitor}\");\n    }\n}",
    "graph_06": "node Node1 {}\nnode Node2 {}\n\nnode1 ++> node2;",
    "graph_07": "node MyNode {}\n\nroot ++> MyNode();",
    "graph_08": "node MyNode {\n    can exit with Walker exit {\n        print(\"Exiting node\");\n    }\n}",
    "graph_09": "edge MyEdge {\n    can cross with Walker entry {\n        print(\"Crossing edge\");\n    }\n}",
    "graph_10": "node Node1 {}\nnode Node2 {}\nnode Node3 {}\n\nnode1 ++> node2 ++> node3;",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker MyWalker {\n    can explore with Node entry {\n        visit [here -->];\n    }\n}",
    "walker_03": "walker TypeFilter {\n    can filter with Node entry {\n        visit [here --> (`?Type)];\n    }\n}",
    "walker_04": "walker PrintNode {\n    can print with Node entry {\n        print(f\"Current node: {here}\");\n    }\n}",
    "walker_05": "walker Reporter {\n    can report_value with Node entry {\n        report here.value;\n    }\n}",
    "walker_06": "node MyNode { has name: str; } walker MyWalker { can start with MyNode entry { report here.name; } } with entry { my_node = MyNode(name=\"Test\"); my_node spawn MyWalker(); }",
    "walker_07": "walker MyWalker { can start with `root entry { report \"Started at root\"; } } with entry { root spawn MyWalker(); }",
    "walker_08": "walker IncomingVisitor { can visit with Node entry { visit [<--]; } }",
    "walker_09": "walker ExitWalker { can start with Node entry { report \"Starting\"; } can finish with Node exit { report \"Exiting\"; } }",
    "walker_10": "walker ReportHere { can report_here with Node entry { report here; } }",
    "advanced_01": "walker AttributeFilter { can filter with Node entry { visit [here -->](?attr == value); } }",
    "advanced_02": "walker EdgeTypeFilter { can filter with Node entry { visit [here ->:EdgeType:->]; } }",
    "advanced_03": "walker MultiHop { can traverse with Node entry { visit [here --> --> -->]; } }",
    "advanced_04": "walker EarlyExit { can exit_early with Node entry { if some_condition { disengage; } } }",
    "advanced_05": "edge MyEdge { can trigger with WalkerType entry { report \"Edge triggered\"; } }",
    "advanced_06": "walker DFSWalker { has visited: set = set(); can search with Node entry { if here not in self.visited { self.visited.add(here); visit [here -->:0:]; } } }",
    "advanced_07": "walker MultiNodeVisit { can visit_nodes with Node entry { visit [node1, node2, node3]; } }",
    "advanced_08": "walker CombinedFilter { can filter with Node entry { visit [here --> (`?Person)](?age > 18); } }",
    "advanced_09": "walker EdgeAttributeFilter { can filter with Node entry { visit [here ->:EdgeType:weight > 5:->]; } }",
    "advanced_10": "node1 del --> node2;",
    "ai_01": "import from byllm { Model };",
    "ai_02": "glob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "def generate_greeting() -> str by llm() { return \"Hello!\"; }",
    "ai_04": "obj MyObject { has description: str; sem description = \"This is a description\"; }",
    "ai_05": "enum GreetingType { HELLO, HI, HEY } def generate_greeting() -> GreetingType by llm();",
    "ai_06": "def solve_problem(problem: str) -> int by llm(method='Reason');",
    "ai_07": "def react_function(query: str) -> str by llm(method='ReAct', tools=[search_web]);",
    "ai_08": "import from byllm { Image };",
    "ai_09": "obj MyObject { has content: str; def summarize() -> str by llm(); }",
    "ai_10": "obj CustomType { has data: str; } def generate_custom() -> CustomType by llm();",
    "cloud_01": "walker MyWalker { obj __specs__ { static has methods: list = [\"get\", \"post\"]; } }",
    "cloud_02": "walker NoAuthWalker { obj __specs__ { static has auth: bool = False; } }",
    "cloud_03": "walker CustomPathWalker { obj __specs__ { static has path: str = \"/api/custom\"; } }",
    "cloud_04": "walker QueryWalker { has param1: str; has param2: int; obj __specs__ { static has as_query: list = [\"param1\", \"param2\"]; } }",
    "cloud_05": "walker PrivateWalker { obj __specs__ { static has private: bool = True; } }",
    "cloud_06": "async walker AsyncWalker { can process with Node entry { await some_async_function(); } }",
    "cloud_07": "walker_id = \"w::123abc\"; walker_instance = &walker_id;",
    "cloud_08": "walker WebhookHandler { obj __specs__ { static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"}; } }",
    "cloud_09": "node MyNode { has data: str; } with entry { root ++> MyNode(data=\"Persistent\"); }",
    "cloud_10": "walker TypedResponse { can respond with Node entry -> str { return \"Response\"; } }",
    "import_01": "import os;",
    "import_02": "import from math { sqrt, pi };",
    "import_03": "include \"module.jac\";",
    "import_04": "import numpy as np;",
    "file_01": "with open(\"file.txt\", \"r\") as file { content = file.read(); }",
    "file_02": "with open(\"file.txt\", \"w\") as file { file.write(\"Hello, World!\"); }",
    "file_03": "import json; with open(\"data.json\", \"r\") as file { data = json.load(file); }",
    "impl_01": "obj MyObject { def my_method(); } impl MyObject.my_method() { return \"Implemented\"; }",
    "advanced_func_01": "def sum_all(*args: int) -> int { return sum(args); }",
    "advanced_func_02": "def config(**kwargs: str) -> dict { return kwargs; }",
    "integration_01": "node Person { has name: str; }\nedge Friendship { has strength: float; }\nwalker TraverseGraph { can traverse with Person entry { visit [here -->]; } }",
    "integration_02": "node State { has name: str; }\nwalker StateMachine { has current_state: State; can transition with State entry { visit [here -->]; } }",
    "integration_03": "walker ErrorHandler { can handle with `root entry { try { risky_operation(); } except ValueError as e { report \"ValueError occurred\"; } } }",
    "integration_04": "async def fetch_data() { data = await get_data(); return data; }",
    "integration_05": "walker CRUD { can create with `root entry { new_node = root ++> Node(); save(new_node); commit(); } can read with `root entry { nodes = [root -->]; report nodes; } can update with `root entry { node = [root -->][0]; node.attr = \"new value\"; save(node); commit(); } can delete with `root entry { node = [root -->][0]; del node; commit(); } }",
    "integration_06": "def analyze_data(data: str) -> str by llm();\nwalker AnalyzeGraph { can analyze with Node entry { result = analyze_data(here.data); report result; } }",
    "integration_07": "walker PersistData { can persist with `root entry { node = root ++> Node(); save(node); commit(); } }",
    "integration_08": "walker BFS { has queue: list; has visited: set = set(); can search with Node entry { if here not in self.visited { self.visited.add(here); self.queue.extend([here -->]); process(here); } if self.queue { visit [self.queue.pop(0)]; } } }",
    "integration_09": "node Task { has status: str; can start with Worker entry { here.status = \"running\"; } can finish with Worker exit { here.status = \"done\"; } }",
    "integration_10": "walker Recommend { can recommend with User entry { visit [here -->:Friendship:-> (`?User) --> (`?Post)]; } }",
    "prod_websocket_01": "walker Broadcast { has msg: str; can send with `root entry { socket.notify_channels([\"public\"], {\"text\": self.msg}); } }",
    "prod_permissions_01": "node Document { has owner_id: str; is_public: bool; def __jac_access__() -> AccessLevel { if here.is_public { return ReadPerm; } if _Jac.get_root().id == here.owner_id { return WritePerm; } return NoPerm; } }",
    "prod_cache_01": "walker Cache { has key: str; can get with `root entry { caches = [here --> (`?Cache)](?key == self.key); if caches and caches[0].expires > time() { report caches[0].value; } else { if caches { del caches[0]; } value = compute_expensive(self.key); cache = here ++> Cache(key=self.key, value=value, expires=time()+3600); report value; } } }",
    "prod_validation_01": "walker ValidateInput { has input: str; can validate with `root entry { if not self.input { raise ValueError(\"Invalid input\"); } } }",
    "prod_pagination_01": "walker Paginate { has page: int = 1; per_page: int = 10; can list with `root entry { items = [here --> (`?Item)]; start = (self.page - 1) * self.per_page; end = start + self.per_page; report {\"items\": items[start:end], \"page\": self.page, \"total\": len(items)}; } }",
    "prod_scheduler_01": "walker DailyTask { obj __specs__ { static has schedule: dict = {\"trigger\": \"cron\", \"hour\": \"9\", \"minute\": \"0\", \"save\": True}; } can execute with `root entry { report \"Task executed\"; } }",
    "prod_versioning_01": "node Document { has version: int = 1; content: str; }\nnode DocumentVersion { has version: int; content: str; created: float; }\nwalker VersionControl { can update with Document entry { doc ++> DocumentVersion(version=doc.version, content=doc.content, created=time()); doc.version += 1; doc.content = \"new content\"; save(doc); commit(); } }",
    "prod_softdelete_01": "node Item { has is_deleted: bool = False; deleted_at: float | None = None; }\nwalker SoftDelete { can delete with Item entry { here.is_deleted = True; here.deleted_at = time(); save(here); commit(); } }",
    "prod_audit_01": "node AuditLog { has action: str; user_id: str; timestamp: float; details: dict; }\nwalker LogAction { can log with `root entry { log = root ++> AuditLog(action=\"action\", user_id=\"user\", timestamp=time(), details={}); save(log); commit(); } }",
    "prod_ratelimit_01": "node RateLimit { has user_id: str; count: int; window_start: float; }\nwalker RateLimiter { can limit with `root entry { limit = [here --> (`?RateLimit)](?user_id == \"user\"); if limit and limit[0].count > 100 { raise Exception(\"Rate limit exceeded\"); } } }",
    "advanced_ai_stream_01": "def generate(prompt: str) -> str by llm(stream=True);\nwalker StreamAI { can stream with `root entry { for token in generate(\"Write story\") { print(token, end=\"\"); } } }",
    "advanced_ai_multimodal_01": "walker ImageProcessor { has image_path: str; can process with `root entry { img = Image(self.image_path); desc = analyze_image(img); report desc; } }",
    "advanced_ai_react_01": "def search_web(query: str) -> str { import requests; return requests.get(f\"https://api.search.com?q={query}\").json(); }\ndef assistant(question: str, context: dict) -> str by llm(method='ReAct', tools=[search_web]);",
    "advanced_ai_structured_01": "obj CustomObject { has name: str; age: int; }\ndef extract_info(text: str) -> CustomObject by llm();",
    "advanced_graph_complex_filter_01": "walker ComplexQuery { can query with Node entry { visit [here --> (`?Type)](?attr > 10) ->:EdgeType:->; } }",
    "advanced_graph_pathfind_01": "walker ShortestPath { has target_id: str; has distances: dict; has unvisited: set; can search with Node entry { update_distances(); if here.id == self.target_id { report reconstruct_path(); disengage; } visit min_unvisited(); } }",
    "advanced_graph_cycle_01": "walker CycleDetection { has visited: set = set(); can detect with Node entry { if here in self.visited { report \"Cycle detected\"; disengage; } self.visited.add(here); visit [here -->]; } }",
    "advanced_persist_transaction_01": "walker Transaction { can process with `root entry { node1 = root ++> Node(); node2 = root ++> Node(); save(node1); save(node2); commit(); } }",
    "advanced_persist_reference_01": "walker Reference { can store with `root entry { node = root ++> Node(); node_id = node.id; save(node); commit(); } can retrieve with `root entry { node = &node_id; report node; } }",
    "advanced_cloud_webhook_01": "walker WebhookHandler { obj __specs__ { static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"}; } can handle with `root entry { report here; } }",
    "advanced_cloud_async_retrieve_01": "async walker AsyncTask { can execute with `root entry { result = compute(); report result; } }\nwalker TaskManager { can manage with `root entry { task_id = root spawn AsyncTask(); task = &task_id; status = task.__jac__.status; report status; } }",
    "advanced_cloud_query_params_01": "walker QueryParams { has param1: str; has param2: int; obj __specs__ { static has as_query: list = [\"param1\", \"param2\"]; } can execute with `root entry { report {\"param1\": self.param1, \"param2\": self.param2}; } }",
    "integration_error_handling_01": "walker ErrorHandling { can handle with `root entry { try { risky_operation(); } except SpecificError as e { log_error(e); report \"Fallback value\"; } } }",
    "integration_external_api_01": "import requests;\nwalker FetchAPI { has url: str; can fetch with `root entry { try { response = requests.get(self.url); data = response.json(); report data; } except Exception as e { report \"Error fetching API\"; } } }",
    "integration_conditional_visit_01": "walker ConditionalVisit { can traverse with Node entry { visit [here -->] else { disengage; } } }",
    "integration_multi_ability_01": "node MultiAbilityNode { can enter with Walker entry { process_entry(); } can exit with Walker exit { process_exit(); } }",
    "integration_batch_process_01": "walker BatchProcess { can process with `root entry { items = [root -->]; for item in items { process(item); save(item); } commit(); } }",
    "integration_visitor_communication_01": "node Communicator { can modify with Walker entry { visitor.state = \"modified\"; } }",
    "integration_root_ability_01": "walker RootAbility { can trigger with `root entry { report \"Triggered on root\"; } }",
    "integration_edge_traversal_01": "walker EdgeTraversal { can traverse with Node entry { edges = [here --->]; for edge in edges { process(edge); } } }"
  }
}