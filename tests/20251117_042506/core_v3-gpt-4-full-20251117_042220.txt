{
  "metadata": {
    "model": "gpt-4o",
    "model_alias": "gpt-4",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {PENDING, ACTIVE, COMPLETED};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#* This is a\nmulti-line comment *#",
    "basic_07": "name: str = \"Jac\";\ngreeting: str = f\"Hello, {name}\";",
    "basic_08": "value: str|int = \"Hello\";",
    "basic_09": "squares: list[int] = [x * x for x in range(1, 6)];",
    "basic_10": "number: int = 0;\n\nif number > 0 {\n    print(\"Positive\");\n} elif number < 0 {\n    print(\"Negative\");\n} else {\n    print(\"Zero\");\n}",
    "control_01": "count: int = 1;\n\nwhile count <= 5 {\n    print(count);\n    count += 1;\n}",
    "control_02": "status: str = \"active\";\n\nmatch status {\n    case \"active\":\n        print(\"Active status\");\n    case \"inactive\":\n        print(\"Inactive status\");\n    case _:\n        print(\"Unknown status\");\n}",
    "control_03": "for i in range(10) {\n    if i == 5 {\n        break;\n    }\n    print(i);\n}",
    "control_04": "for i in range(10) {\n    if i % 2 == 0 {\n        continue;\n    }\n    print(i);\n}",
    "collection_01": "numbers: set[int] = set();\nnumbers.add(1);\nnumbers.add(2);",
    "collection_02": "person: tuple[str, int] = (\"Alice\", 30);",
    "collection_03": "squares: dict[int, int] = {x: x * x for x in range(1, 6)};",
    "collection_04": "names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n\nfor name in names {\n    print(name);\n}",
    "collection_05": "ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n\nage = ages.get(\"Alice\");",
    "type_01": "value: any = \"Hello\";\n\nif isinstance(value, str) {\n    print(\"Value is a string\");\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.brand} ({self.year})\";\n    }\n}",
    "obj_03": "obj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "square = lambda x: int: x * x;",
    "obj_06": "obj Secret {\n    has :priv: secret_code: str;\n}",
    "obj_07": "obj PublicData {\n    has :pub: info: str;\n}",
    "obj_08": "def my_decorator(func: callable[[], None]) -> callable[[], None] {\n    def wrapper() {\n        print(\"Before function\");\n        func();\n        print(\"After function\");\n    }\n    return wrapper;\n}\n\n@my_decorator\ndef say_hello() {\n    print(\"Hello!\");\n}",
    "obj_09": "def execute(callable_func: callable[[], None]) {\n    callable_func();\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello {name}\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n    has population: int;\n}\n\ncity1 = City(name=\"City1\", population=100000);\ncity2 = City(name=\"City2\", population=150000);\n\ncity1 <++> city2;",
    "graph_03": "edge Road {\n    has distance: float;\n}\n\ncity1 = City(name=\"City1\", population=100000);\ncity2 = City(name=\"City2\", population=150000);\n\ncity1 +>:Road:distance=10.5:+> city2;",
    "graph_04": "node Sensor {\n    can activate with entry {\n        print(\"Sensor activated\");\n    }\n}",
    "graph_05": "node Checkpoint {\n    can log with entry {\n        print(f\"Visited by {visitor}\");\n    }\n}",
    "graph_06": "node A {}\nnode B {}\n\na = A();\nb = B();\n\na ++> b;",
    "graph_07": "node Data {}\n\nroot ++> Data();",
    "graph_08": "node ExitNode {\n    can on_exit with exit {\n        print(\"Exiting node\");\n    }\n}",
    "graph_09": "edge Bridge {\n    can cross with entry {\n        print(\"Crossing bridge\");\n    }\n}",
    "graph_10": "node A {}\nnode B {}\nnode C {}\n\na = A();\nb = B();\nc = C();\n\na ++> b ++> c;",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker OutgoingVisitor {\n    can visit_all with entry {\n        visit [here -->];\n    }\n}",
    "walker_03": "walker TypeFilter {\n    can filter with entry {\n        visit [here -->(`?Type)];\n    }\n}",
    "walker_04": "walker CurrentNodePrinter {\n    can print_node with entry {\n        print(f\"Current node: {here}\");\n    }\n}",
    "walker_05": "walker Reporter {\n    can report_value with entry {\n        report \"Value to report\";\n    }\n}",
    "walker_06": "node MyNode { has name: str; } walker MyWalker { can start with MyNode entry { print(\"Walker started\"); } } with entry { my_node = MyNode(name=\"Test\"); my_node spawn MyWalker(); }",
    "walker_07": "walker MyWalker { can start with `root entry { print(\"Walker started on root\"); } } with entry { root spawn MyWalker(); }",
    "walker_08": "walker IncomingWalker { can visit with Node entry { visit [<--]; } }",
    "walker_09": "walker ExitWalker { can start with Node entry { print(\"Starting walker\"); } can finish with Node exit { print(\"Exiting walker\"); } }",
    "walker_10": "walker ReportWalker { can report with Node entry { report here; } }",
    "advanced_01": "walker FilterWalker { can filter with Node entry { visit [here](?attr == value); } }",
    "advanced_02": "walker EdgeTypeWalker { can filter with Node entry { visit [here ->:EdgeType:->]; } }",
    "advanced_03": "walker MultiHopWalker { can traverse with Node entry { visit [here --> --> -->]; } }",
    "advanced_04": "walker DisengageWalker { can exit with Node entry { disengage; } }",
    "advanced_05": "edge MyEdge { can trigger with Walker entry { print(\"Walker entered edge\"); } }",
    "advanced_06": "walker DFSWalker { has visited: set = set(); can search with Node entry { if here not in self.visited { self.visited.add(here); visit [here -->:0:]; } } }",
    "advanced_07": "walker MultiVisitWalker { can visit with Node entry { visit [node1, node2, node3]; } }",
    "advanced_08": "walker CombinedFilterWalker { can filter with Node entry { visit [here --> (`?Person)](?age > 18); } }",
    "advanced_09": "walker EdgeAttrWalker { can filter with Node entry { visit [here ->:EdgeType:weight > 5:->]; } }",
    "advanced_10": "node NodeA {} node NodeB {} edge MyEdge {} with entry { a = NodeA(); b = NodeB(); a +>:MyEdge:+> b; del a --> b; }",
    "ai_01": "import from byllm {Model};",
    "ai_02": "glob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "def generate_greeting() -> str by llm() { return \"Hello!\"; }",
    "ai_04": "obj Person { has name: str; sem name = \"The person's name\"; }",
    "ai_05": "enum GreetingType { FORMAL, INFORMAL } def generate_greeting() -> GreetingType by llm() { return GreetingType.FORMAL; }",
    "ai_06": "def solve_problem(problem: str) -> int by llm(method='Reason') { return 42; }",
    "ai_07": "def search_web(query: str) -> str { return \"Result\"; } def react_function() by llm(method='ReAct', tools=[search_web]) { return \"Response\"; }",
    "ai_08": "import from byllm {Image};",
    "ai_09": "obj Article { has content: str; def summarize() -> str by llm() { return \"Summary\"; } }",
    "ai_10": "obj CustomType { has data: str; } def generate_custom() -> CustomType by llm() { return CustomType(data=\"Example\"); }",
    "cloud_01": "walker MyWalker { obj __specs__ { static has methods: list = [\"get\", \"post\"]; } }",
    "cloud_02": "walker NoAuthWalker { obj __specs__ { static has auth: bool = False; } }",
    "cloud_03": "walker CustomPathWalker { obj __specs__ { static has path: str = \"/api/custom\"; } }",
    "cloud_04": "walker QueryWalker { has param1: str; has param2: int; obj __specs__ { static has as_query: list = [\"param1\", \"param2\"]; } }",
    "cloud_05": "walker PrivateWalker { obj __specs__ { static has private: bool = True; } }",
    "cloud_06": "async walker AsyncWalker { can process with Node entry { print(\"Async processing\"); } }",
    "cloud_07": "walker MyWalker {} with entry { walker_id = \"w::123\"; walker_ref = &walker_id; }",
    "cloud_08": "walker WebhookWalker { obj __specs__ { static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"}; } }",
    "cloud_09": "node PersistentNode {} with entry { root ++> PersistentNode(); }",
    "cloud_10": "walker TypedResponseWalker { can respond with Node entry { report {\"status\": \"success\"}; } }",
    "import_01": "import os;",
    "import_02": "import from math {sqrt, pi};",
    "import_03": "include \"module.jac\";",
    "import_04": "import numpy as np;",
    "file_01": "with open(\"file.txt\", \"r\") as file { content = file.read(); }",
    "file_02": "with open(\"file.txt\", \"w\") as file { file.write(\"Hello, World!\"); }",
    "file_03": "import json; with open(\"data.json\", \"r\") as file { data = json.load(file); }",
    "impl_01": "obj Calculator { def add(a: int, b: int) -> int; } impl Calculator.add(a: int, b: int) -> int { return a + b; }",
    "advanced_func_01": "def sum_all(*args: int) -> int { return sum(args); }",
    "advanced_func_02": "def config(**kwargs: str) -> dict { return kwargs; }",
    "integration_01": "node Person {has name: str;}; edge Friendship {has strength: float;}; walker TraverseGraph {can traverse with Person entry {visit [here -->];}};",
    "integration_02": "node State {has name: str;}; walker StateMachine {can transition with State entry {visit [here -->];}};",
    "integration_03": "walker ErrorHandling {can handle with `root entry {try {risky_operation();} except ValueError as e {report \"ValueError occurred\";} except Exception {report \"Unknown error\";}}};",
    "integration_04": "async def fetch_data() {data = await get_data(); return data;};",
    "integration_05": "walker CRUD {can create with `root entry {new_node = root ++> Node(); save(new_node); commit();} can read with `root entry {nodes = [root -->]; report nodes;} can update with `root entry {node = [root -->][0]; node.attr = \"new value\"; save(node); commit();} can delete with `root entry {node = [root -->][0]; del node; commit();}};",
    "integration_06": "def analyze_data(data: str) -> str by llm(); walker AnalyzeGraph {can analyze with Node entry {result = analyze_data(here.data); report result;}};",
    "integration_07": "walker PersistData {can save with `root entry {node = root ++> Node(); save(node); commit();}};",
    "integration_08": "walker BFS {has queue: list; has visited: set = set(); can search with Node entry {if here not in self.visited {self.visited.add(here); self.queue.extend([here -->]); process(here);}; if self.queue {visit [self.queue.pop(0)];}}};",
    "integration_09": "node Step {has name: str; can execute with Workflow entry {visitor.progress.append(here.name);}}; walker Workflow {has progress: list = []; can start with `root entry {visit [here -->];}};",
    "integration_10": "walker Recommend {can suggest with User entry {visit [here -->:Friendship:-> (`?User) --> (`?Item)];}};",
    "prod_websocket_01": "walker Broadcast {has msg: str; can send with `root entry {socket.notify_channels([\"public\"], {\"text\": self.msg});}};",
    "prod_permissions_01": "node Document {has owner_id: str; is_public: bool; def __jac_access__() -> AccessLevel {if here.is_public {return ReadPerm;}; if _Jac.get_root().id == here.owner_id {return WritePerm;}; return NoPerm;}};",
    "prod_cache_01": "walker Cache {has key: str; can get with `root entry {caches = [here --> (`?Cache)](?key == self.key); if caches and caches[0].expires > time() {report caches[0].value;} else {if caches {del caches[0];}; value = compute_expensive(self.key); cache = here ++> Cache(key=self.key, value=value, expires=time()+3600); report value;}}};",
    "prod_validation_01": "walker ValidateInput {has param: str; can validate with `root entry {if not self.param {raise ValueError(\"Invalid input\");} report \"Valid input\";}};",
    "prod_pagination_01": "walker Paginate {has page: int = 1; per_page: int = 10; can list with `root entry {items = [here --> (`?Item)]; start = (self.page - 1) * self.per_page; end = start + self.per_page; report {\"items\": items[start:end], \"page\": self.page, \"total\": len(items)};}};",
    "prod_scheduler_01": "walker DailyTask {obj __specs__ {static has schedule: dict = {\"trigger\": \"cron\", \"hour\": \"9\", \"minute\": \"0\", \"save\": True};}; can execute with `root entry {report \"Task executed\";}};",
    "prod_versioning_01": "node Document {has version: int = 1; content: str;}; node DocumentVersion {has version: int; content: str; created: float;}; walker VersionControl {can update with Document entry {doc ++> DocumentVersion(version=doc.version, content=doc.content, created=time()); doc.version += 1; doc.content = \"new content\"; save(doc); commit();}};",
    "prod_softdelete_01": "node Item {has is_deleted: bool = False; deleted_at: float | None = None;}; walker SoftDelete {can mark with Item entry {here.is_deleted = True; here.deleted_at = time(); save(here); commit();}};",
    "prod_audit_01": "node AuditLog {has action: str; user_id: str; timestamp: float; details: dict;}; walker LogAction {has action: str; user_id: str; details: dict; can log with `root entry {log = root ++> AuditLog(action=self.action, user_id=self.user_id, timestamp=time(), details=self.details); save(log); commit();}};",
    "prod_ratelimit_01": "node RateLimit {has user_id: str; count: int; window_start: float;}; walker RateLimiter {has user_id: str; can limit with `root entry {limit = [here --> (`?RateLimit)](?user_id == self.user_id); if limit and limit[0].count >= 100 {raise Exception(\"Rate limit exceeded\");} else {if not limit {limit = root ++> RateLimit(user_id=self.user_id, count=0, window_start=time());} limit[0].count += 1; save(limit[0]); commit();}}};",
    "advanced_ai_stream_01": "def generate_text(prompt: str) -> str by llm(stream=True); walker StreamAI {can generate with `root entry {for token in generate_text(\"Write story\") {print(token, end=\"\");}}};",
    "advanced_ai_multimodal_01": "walker ProcessImage {has image_path: str; can analyze with `root entry {img = Image(self.image_path); desc = describe_image(img); report desc;}};",
    "advanced_ai_react_01": "def search_web(query: str) -> str {return api_call(query);}; def assistant(question: str, context: dict) -> str by llm(method='ReAct', tools=[search_web]);",
    "advanced_ai_structured_01": "obj ExtractedData {has name: str; age: int;}; def extract_info(text: str) -> ExtractedData by llm();",
    "advanced_graph_complex_filter_01": "walker ComplexQuery {can query with Node entry {visit [here --> (`?Type)](?attr > 10) -->:EdgeType:->];}};",
    "advanced_graph_pathfind_01": "walker ShortestPath {has target_id: str; has distances: dict; has unvisited: set; can search with Node entry {update_distances(); if here.id == self.target_id {report reconstruct_path(); disengage;}; visit min_unvisited();}};",
    "advanced_graph_cycle_01": "walker CycleDetection {has visited: set = set(); can detect with Node entry {if here in self.visited {report \"Cycle detected\"; disengage;} else {self.visited.add(here); visit [here -->];}}};",
    "advanced_persist_transaction_01": "walker Transaction {can process with `root entry {node1 = root ++> Node(); node2 = root ++> Node(); save(node1); save(node2); commit();}};",
    "advanced_persist_reference_01": "walker Reference {has node_id: str; can retrieve with `root entry {node = &self.node_id; report node;}};",
    "advanced_cloud_webhook_01": "walker WebhookHandler {obj __specs__ {static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"};}; can handle with `root entry {report here;}};",
    "advanced_cloud_async_retrieve_01": "async walker AsyncTask {has data: list; can process with `root entry {for item in self.data {compute(item);}}}; result = root spawn AsyncTask(data=large_dataset); task_id = result; task = &task_id; task.__jac__.status;",
    "advanced_cloud_query_params_01": "walker QueryParams {has param1: str; has param2: int; obj __specs__ {static has as_query: list = [\"param1\", \"param2\"];}; can execute with `root entry {report {\"param1\": self.param1, \"param2\": self.param2};}};",
    "integration_error_handling_01": "walker GracefulErrorHandling {can handle with `root entry {try {risky_operation();} except ValueError as e {report \"ValueError occurred\";} except Exception {report \"Unknown error\";}}};",
    "integration_external_api_01": "import requests; walker FetchAPI {has url: str; can fetch with `root entry {try {response = requests.get(self.url); data = response.json(); report data;} except Exception {report \"Failed to fetch data\";}}};",
    "integration_conditional_visit_01": "walker ConditionalTraversal {can traverse with Node entry {visit [here -->] else {disengage;}}};",
    "integration_multi_ability_01": "node MultiAbilityNode {can enter with Walker entry {print(\"Entering node\");} can exit with Walker exit {print(\"Exiting node\");}};",
    "integration_batch_process_01": "walker BatchProcess {has items: list; can process with `root entry {for item in self.items {process(item); save(item);} commit();}};",
    "integration_visitor_communication_01": "node Communicator {can modify with Walker entry {visitor.state = \"modified\";}};",
    "integration_root_ability_01": "walker RootAbility {can trigger with `root entry {report \"Triggered on root\";}};",
    "integration_edge_traversal_01": "walker EdgeAccess {can access with Node entry {edges = [here --->]; for edge in edges {process(edge);}}};"
  }
}