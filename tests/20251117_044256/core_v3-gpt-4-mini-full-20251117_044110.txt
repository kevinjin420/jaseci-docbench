{
  "metadata": {
    "model": "gpt-4o-mini",
    "model_alias": "gpt-4-mini",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "for i = 1 to i <= 5 by i += 1 {\n    print(i);\n}",
    "basic_06": "#* This is a multi-line comment *#",
    "basic_07": "name = \"Jac\";\nmessage = f\"Hello, {name}!\";",
    "basic_08": "value: str|int = \"Hello\";",
    "basic_09": "squares = [x * x for x in range(1, 6)];",
    "basic_10": "number = 0;\nif number > 0 {\n    print(\"Positive\");\n} elif number < 0 {\n    print(\"Negative\");\n} else {\n    print(\"Zero\");\n}",
    "control_01": "count = 1;\nwhile count <= 5 {\n    print(count);\n    count += 1;\n}",
    "control_02": "status = \"unknown\";\nmatch status {\n    case \"active\":\n        print(\"Active\");\n    case \"pending\":\n        print(\"Pending\");\n    case _:\n        print(\"Unknown status\");\n}",
    "control_03": "for i = 1 to i <= 10 by i += 1 {\n    if i == 5 {\n        break;\n    }\n    print(i);\n}",
    "control_04": "for i = 1 to i <= 10 by i += 1 {\n    if i % 2 == 0 {\n        continue;\n    }\n    print(i);\n}",
    "collection_01": "my_set: set[int] = set();\nmy_set.add(1);\nmy_set.add(2);\nmy_set.add(3);",
    "collection_02": "my_tuple: tuple[str, int] = (\"Alice\", 30);",
    "collection_03": "squares_dict = {x: x * x for x in range(1, 6)};",
    "collection_04": "my_list: list[str] = [\"apple\", \"banana\", \"cherry\"];\nfor item in my_list {\n    print(item);\n}",
    "collection_05": "my_dict: dict[str, int] = {\"one\": 1, \"two\": 2};\nvalue = my_dict.get(\"one\");",
    "type_01": "var = \"Hello\";\nif isinstance(var, str) {\n    print(\"It's a string!\");\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.brand}, {self.year}\";\n    }\n}",
    "obj_03": "obj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "square = lambda x: int: x * x;",
    "obj_06": "obj MyClass {\n    :priv: secret: str;\n}",
    "obj_07": "obj MyClass {\n    :pub: public_attr: str;\n}",
    "obj_08": "def timer(func) {\n    def wrapper() {\n        print(\"Timing...\");\n        return func();\n    }\n    return wrapper;\n}\n\n@timer\ndef my_function() {\n    print(\"Function executed\");\n}",
    "obj_09": "def call_function(func: callable[[int], int]) -> int {\n    return func(5);\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "city1 = City(name=\"New York\", population=8000000);\ncity2 = City(name=\"Los Angeles\", population=4000000);\ncity1 <++> city2;",
    "graph_03": "edge Road {\n    has distance: float;\n}\n\ncity1 +>:Road:distance=300.0:+> city2;",
    "graph_04": "node MyNode {\n    can enter with Visitor entry {\n        print(\"Entering node\");\n    }\n}",
    "graph_05": "node MyNode {\n    can enter with Visitor entry {\n        print(visitor);\n    }\n}",
    "graph_06": "node1 = City(name=\"City1\", population=1000);\nnode2 = City(name=\"City2\", population=2000);\nnode1 ++> node2;",
    "graph_07": "root ++> City(name=\"Root City\", population=10000);",
    "graph_08": "node MyNode {\n    can exit with Visitor exit {\n        print(\"Exiting node\");\n    }\n}",
    "graph_09": "edge MyEdge {\n    can cross with Visitor entry {\n        print(\"Crossing edge\");\n    }\n}\n\ncity1 +>:MyEdge:+> city2;",
    "graph_10": "node1 = City(name=\"City1\", population=1000);\nnode2 = City(name=\"City2\", population=2000);\nnode3 = City(name=\"City3\", population=3000);\nnode1 ++> node2 ++> node3;",
    "walker_06": "walker MyWalker {can search with Node entry {visit [here -->];}}",
    "walker_07": "with entry {root spawn MyWalker();}",
    "walker_08": "walker IncomingWalker {can search with Node entry {visit [<-- here];}}",
    "walker_09": "walker ExitWalker {can search with Node entry {disengage;}}",
    "walker_10": "walker ReportWalker {can search with Node entry {report here;}}",
    "advanced_01": "walker FilterWalker {can search with Node entry {visit [here -->] (?attr == value);}}",
    "advanced_02": "walker EdgeTypeWalker {can search with Node entry {visit [here -->:EdgeType:->];}}",
    "advanced_03": "walker MultiHopWalker {can search with Node entry {visit [here --> --> -->];}}",
    "advanced_04": "walker EarlyExitWalker {can search with Node entry {if condition {disengage;}}}",
    "advanced_05": "edge TriggerEdge {has strength: float; can trigger with Walker entry {visitor.log(\"Triggered\");}}",
    "advanced_06": "walker DFSWalker {can search with Node entry {visit [here -->:0:];}}",
    "advanced_07": "walker MultiTargetWalker {can search with Node entry {visit [node1, node2, node3];}}",
    "advanced_08": "walker CombinedFilterWalker {can search with Node entry {visit [here --> (`?Person)](?age > 18);}}",
    "advanced_09": "walker EdgeAttrFilterWalker {can search with Node entry {visit [here -->:EdgeType:weight > 5:->];}}",
    "advanced_10": "walker DeleteEdgeWalker {can search with Node entry {del edge;}}",
    "ai_01": "import from byllm {Model};",
    "ai_02": "glob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "def generate_greeting() -> str by llm();",
    "ai_04": "sem MyAttribute.attr = \"description\";",
    "ai_05": "def get_enum() -> Status by llm();",
    "ai_06": "def reason_function(problem: str) -> int by llm(method='Reason');",
    "ai_07": "def react_function() -> str by llm(method='ReAct', tools=[tool_function]);",
    "ai_08": "import from byllm {Image};",
    "ai_09": "obj AIObject {has data: str; def ai_method(self) -> str by llm();};",
    "ai_10": "def create_custom_object() -> CustomType by llm();",
    "cloud_01": "walker MyWalker {obj __specs__ {static has methods: list = [\"get\", \"post\"];}}",
    "cloud_02": "walker NoAuthWalker {obj __specs__ {static has auth: bool = False;}}",
    "cloud_03": "walker CustomPathWalker {obj __specs__ {static has path: str = \"/api/custom\";}}",
    "cloud_04": "walker QueryParamsWalker {obj __specs__ {static has as_query: list = [\"param1\", \"param2\"];}}",
    "cloud_05": "walker PrivateWalker {obj __specs__ {static has private: bool = True;}}",
    "cloud_06": "async walker AsyncWalker {can process with `root entry {await task();}}",
    "cloud_07": "walker ReferenceWalker {can search with Node entry {walker_ref = &walker_id;}}",
    "cloud_08": "walker WebhookWalker {obj __specs__ {static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"}};}}",
    "cloud_09": "node MyNode {has attr: str;};\nwith entry {root ++> MyNode();}",
    "cloud_10": "walker TypedResponseWalker {can search with Node entry {report here as ResponseType;}}",
    "import_01": "import requests;",
    "import_02": "import from math {sqrt};",
    "import_03": "include my_module;",
    "import_04": "import numpy as np;",
    "file_01": "with open(\"file.txt\") as f {content = f.read();}",
    "file_02": "with open(\"output.txt\", \"w\") as f {f.write(\"Hello, World!\");}",
    "file_03": "with open(\"data.json\") as f {data = json.load(f);}",
    "impl_01": "impl MyClass.method() {code}",
    "advanced_func_01": "def variadic_function(*args: int) -> int {return sum(args);}",
    "advanced_func_02": "def keyword_function(**kwargs: str) -> dict {return kwargs;}",
    "integration_01": "node Person {\\n    has name: str;\\n    has age: int;\\n}\\n\\nedge Friendship {\\n    has strength: float;\\n}\\n\\nwalker SocialGraph {\\n    can traverse with `root entry {\\n        visit [root --> (`?Person)];\\n        visit [here -->:Friendship:-> (`?Person)];\\n    }}\\n",
    "integration_02": "node State {\\n    has name: str;\\n}\\n\\nwalker StateMachine {\\n    has current_state: str;\\n    can transition with State entry {\\n        self.current_state = here.name;\\n    }}\\n",
    "integration_03": "walker ErrorHandling {\\n    can process with `root entry {\\n        try {\\n            risky_operation();\\n        } except ValueError as e {\\n            report f\"Error: {e}\";\\n        }\\n    }}\\n",
    "integration_04": "async walker AsyncFunction {\\n    can process with `root entry {\\n        result = await fetch_data();\\n        report result;\\n    }}\\n",
    "integration_05": "node Item {\\n    has name: str;\\n    has quantity: int;\\n}\\n\\nwalker CRUD {\\n    can create with `root entry {\\n        item = root ++> Item(name=\"New Item\", quantity=1);\\n        save(item);\\n        commit();\\n    }\\n    can read with `root entry {\\n        items = [root --> (`?Item)];\\n        report items;\\n    }\\n    can update with `root entry {\\n        item = &self.item_id;\\n        item.quantity += 1;\\n        save(item);\\n        commit();\\n    }\\n    can delete with `root entry {\\n        item = &self.item_id;\\n        del root --> item;\\n        commit();\\n    }}\\n",
    "integration_06": "walker AITraversal {\\n    can traverse with `root entry {\\n        data = [root --> (`?Node)];\\n        result = process_data(data);\\n        report result;\\n    }}\\n",
    "integration_07": "walker APIPersist {\\n    can save_data with `root entry {\\n        data = here.data;\\n        save(data);\\n        commit();\\n    }}\\n",
    "integration_08": "walker BFS {\\n    has queue: list;\\n    has visited: set = set();\\n    can search with Node entry {\\n        if here not in self.visited {\\n            self.visited.add(here);\\n            self.queue.extend([here -->]);\\n            process(here);\\n        }\\n        if self.queue {\\n            visit [self.queue.pop(0)];\\n        }\\n    }}\\n",
    "integration_09": "walker Workflow {\\n    can step_one with Node entry {\\n        here.do_something();\\n        visit [here -->];\\n    }\\n    can step_two with Node entry {\\n        here.do_something_else();\\n        visit [here -->];\\n    }}\\n",
    "integration_10": "walker Recommendation {\\n    can recommend with User entry {\\n        friends = [here -->:Friendship:-> (`?User)];\\n        recommendations = [friend --> (`?Post)];\\n        report recommendations;\\n    }}\\n",
    "prod_websocket_01": "walker WebSocketBroadcast {\\n    has message: str;\\n    can broadcast with `root entry {\\n        socket.notify_channels([\"channel1\"], {\"text\": self.message});\\n    }}\\n",
    "prod_permissions_01": "node Document {\\n    has owner_id: str;\\n    def __jac_access__() -> AccessLevel {\\n        if _Jac.get_root().id == self.owner_id {\\n            return WritePerm;\\n        }\\n        return ReadPerm;\\n    }}\\n",
    "prod_cache_01": "node Cache {\\n    has key: str;\\n    has value: any;\\n    has expires: float;\\n}\\n\\nwalker CacheCheck {\\n    can get_value with `root entry {\\n        caches = [here --> (`?Cache)](?key == self.key);\\n        if caches and caches[0].expires > time() {\\n            report caches[0].value;\\n        } else {\\n            if caches {\\n                del caches[0];\\n            }\\n            value = compute_expensive(self.key);\\n            cache = here ++> Cache(key=self.key, value=value, expires=time()+3600);\\n            report value;\\n        }\\n    }}\\n",
    "prod_validation_01": "walker InputValidation {\\n    can validate with `root entry {\\n        if not is_valid(self.input) {\\n            raise ValueError(\"Invalid input\");\\n        }\\n        report self.input;\\n    }}\\n",
    "prod_pagination_01": "walker PaginatedQuery {\\n    has page: int = 1;\\n    has per_page: int = 10;\\n    can list with `root entry {\\n        items = [here --> (`?Item)];\\n        start = (self.page - 1) * self.per_page;\\n        end = start + self.per_page;\\n        report {\"items\": items[start:end], \"page\": self.page, \"total\": len(items)};\\n    }}\\n",
    "prod_scheduler_01": "walker DailyTask {\\n    obj __specs__ {\\n        static has schedule: dict = {\"trigger\": \"cron\", \"hour\": \"9\", \"minute\": \"0\", \"save\": True};\\n    }\\n    can execute with `root entry {\\n        report \"Task executed\";\\n    }}\\n",
    "prod_versioning_01": "node Document {\\n    has version: int = 1;\\n    has content: str;\\n}\\n\\nnode DocumentVersion {\\n    has version: int;\\n    has content: str;\\n    has created: float;\\n}\\n\\nwalker VersionControl {\\n    can update with Document entry {\\n        versioned_doc = here ++> DocumentVersion(version=here.version, content=here.content, created=time());\\n        here.version += 1;\\n        here.content = new_content;\\n        save(versioned_doc);\\n        commit();\\n    }}\\n",
    "prod_softdelete_01": "node Item {\\n    has is_deleted: bool = False;\\n    has deleted_at: float | None = None;\\n}\\n\\nwalker SoftDelete {\\n    can delete with `root entry {\\n        item = &self.item_id;\\n        item.is_deleted = True;\\n        item.deleted_at = time();\\n        save(item);\\n        commit();\\n    }}\\n",
    "prod_audit_01": "node AuditLog {\\n    has action: str;\\n    has user_id: str;\\n    has timestamp: float;\\n    has details: dict;\\n}\\n\\nwalker AuditTrail {\\n    can log_action with `root entry {\\n        log = here ++> AuditLog(action=\"action_name\", user_id=\"user_id\", timestamp=time(), details={});\\n        save(log);\\n        commit();\\n    }}\\n",
    "prod_ratelimit_01": "node RateLimit {\\n    has user_id: str;\\n    has count: int;\\n    has window_start: float;\\n}\\n\\nwalker RateLimiter {\\n    can limit with `root entry {\\n        rate_limit = &self.rate_limit_id;\\n        if rate_limit.count >= limit {\\n            raise ValueError(\"Rate limit exceeded\");\\n        }\\n        rate_limit.count += 1;\\n        save(rate_limit);\\n        commit();\\n    }}\\n",
    "advanced_ai_stream_01": "def generate_stream(prompt: str) -> str by llm(stream=True);\\n\\nfor token in generate_stream(\"Prompt text\") {\\n    print(token, end=\"\");\\n}\\n",
    "advanced_ai_multimodal_01": "walker ImageProcessing {\\n    can analyze with `root entry {\\n        img = Image(visitor.files[0]);\\n        desc = analyze_image(img);\\n        report desc;\\n    }}\\n",
    "advanced_ai_react_01": "def assistant(question: str, context: dict) -> str by llm(method='ReAct', tools=[search_web]);\\n\\nresult = assistant(\"What is the weather?\", {});\\n",
    "advanced_ai_structured_01": "def extract_person(text: str) -> Person by llm();\\n\\nperson = extract_person(\"John, 25\");\\n",
    "advanced_graph_complex_filter_01": "walker ComplexQuery {\\n    can query with `root entry {\\n        results = [root --> (`?Node)](?attr > 10) -->:EdgeType:-> (`?OtherNode);\\n        report results;\\n    }}\\n",
    "advanced_graph_pathfind_01": "walker ShortestPath {\\n    has target_id: str;\\n    has distances: dict;\\n    has unvisited: set;\\n    can search with Node entry {\\n        update_distances();\\n        if here.id == self.target_id {\\n            report reconstruct_path();\\n            disengage;\\n        }\\n        visit min_unvisited();\\n    }}\\n",
    "advanced_graph_cycle_01": "walker CycleDetection {\\n    has visited: set = set();\\n    can detect with Node entry {\\n        if here in self.visited {\\n            report f\"Cycle detected at {here.id}\";\\n            disengage;\\n        }\\n        self.visited.add(here);\\n        visit [here -->];\\n    }}\\n",
    "advanced_persist_transaction_01": "walker TransactionPattern {\\n    can process with `root entry {\\n        item1 = root ++> Item();\\n        item2 = root ++> Item();\\n        save(item1);\\n        save(item2);\\n        commit();\\n    }}\\n",
    "advanced_persist_reference_01": "node ReferenceNode {\\n    has id: str;\\n}\\n\\nwalker ReferenceRetrieval {\\n    can retrieve with `root entry {\\n        ref_id = \"n::123abc\";\\n        node = &ref_id;\\n        report node;\\n    }}\\n",
    "advanced_cloud_webhook_01": "walker WebhookHandler {\\n    obj __specs__ {\\n        static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"};\\n    }\\n    can handle with `root entry {\\n        report here;\\n    }}\\n",
    "advanced_cloud_async_retrieve_01": "async walker AsyncRetrieve {\\n    can retrieve with `root entry {\\n        task_id = await spawn_async_task();\\n        task = &task_id;\\n        status = task.__jac__.status;\\n        report status;\\n    }}\\n",
    "advanced_cloud_query_params_01": "walker QueryParams {\\n    obj __specs__ {\\n        static has as_query: list = [\"param1\", \"param2\"];\\n    }\\n    can query with `root entry {\\n        report here;\\n    }}\\n",
    "integration_error_handling_01": "walker ErrorHandling {\\n    can process with `root entry {\\n        try {\\n            risky_operation();\\n        } except ValueError as e {\\n            report f\"Error: {e}\";\\n            report \"Fallback value\";\\n        }\\n    }}\\n",
    "integration_external_api_01": "import requests;\\n\\nwalker ExternalAPIFetch {\\n    can fetch with `root entry {\\n        try {\\n            response = requests.get(\"https://api.example.com/data\");\\n            data = response.json();\\n            report data;\\n        } except Exception as e {\\n            report f\"Error: {e}\";\\n        }\\n    }}\\n",
    "integration_conditional_visit_01": "walker ConditionalVisit {\\n    can visit with `root entry {\\n        if condition {\\n            visit [here -->];\\n        } else {\\n            disengage;\\n        }\\n    }}\\n",
    "integration_multi_ability_01": "node MultiAbilityNode {\\n    can entry_ability with Walker entry {\\n        report \"Entry ability triggered\";\\n    }\\n    can exit_ability with Walker exit {\\n        report \"Exit ability triggered\";\\n    }}\\n",
    "integration_batch_process_01": "walker BatchProcess {\\n    can process with `root entry {\\n        items = [root --> (`?Item)];\\n        for item in items {\\n            save(item);\\n        }\\n        commit();\\n    }}\\n",
    "integration_visitor_communication_01": "node CommunicatingNode {\\n    can modify_visitor with Walker entry {\\n        visitor.state = \"modified\";\\n    }}\\n",
    "integration_root_ability_01": "walker RootAbility {\\n    can trigger with `root entry {\\n        report \"Triggered on root node\";\\n    }}\\n",
    "integration_edge_traversal_01": "walker EdgeTraversal {\\n    can traverse with `root entry {\\n        edges = [here --->];\\n        for edge in edges {\\n            report edge;\\n        }\\n    }}\\n"
  }
}