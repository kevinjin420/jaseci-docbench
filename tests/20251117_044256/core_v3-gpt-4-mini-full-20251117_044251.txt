{
  "metadata": {
    "model": "gpt-4o-mini",
    "model_alias": "gpt-4-mini",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "for i = 1 to i <= 5 by i += 1 {\n    print(i);\n}",
    "basic_06": "#* This is a multi-line comment *#",
    "basic_07": "name = \"Jac\";\nmessage = f\"Hello, {name}!\";",
    "basic_08": "value: str|int = \"Hello\";",
    "basic_09": "squares = [x * x for x in range(1, 6)];",
    "basic_10": "number = 0;\nif number > 0 {\n    print(\"Positive\");\n} elif number < 0 {\n    print(\"Negative\");\n} else {\n    print(\"Zero\");\n}",
    "control_01": "count = 1;\nwhile count <= 5 {\n    print(count);\n    count += 1;\n}",
    "control_02": "match status {\n    case \"active\":\n        print(\"Status is active\");\n    case \"pending\":\n        print(\"Status is pending\");\n    case _:\n        print(\"Unknown status\");\n}",
    "control_03": "for i = 1 to i <= 10 by i += 1 {\n    if i == 5 {\n        break;\n    }\n    print(i);\n}",
    "control_04": "for i = 1 to i <= 10 by i += 1 {\n    if i % 2 == 0 {\n        continue;\n    }\n    print(i);\n}",
    "collection_01": "my_set: set[int] = set();\nmy_set.add(1);\nmy_set.add(2);\nmy_set.add(3);",
    "collection_02": "my_tuple: tuple[str, int] = (\"Alice\", 30);",
    "collection_03": "squares_dict = {x: x * x for x in range(1, 6)};",
    "collection_04": "my_list: list[str] = [\"apple\", \"banana\", \"cherry\"];\nfor item in my_list {\n    print(item);\n}",
    "collection_05": "my_dict: dict[str, int] = {\"one\": 1, \"two\": 2};\nvalue = my_dict.get(\"one\");",
    "type_01": "var = \"Hello\";\nif isinstance(var, str) {\n    print(\"It's a string\");\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.brand}, {self.year}\";\n    }\n}",
    "obj_03": "obj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "square = lambda x: int: x * x;",
    "obj_06": "obj MyClass {\n    :priv: secret: str;\n    has public_attr: str;\n}",
    "obj_07": "obj MyClass {\n    :pub: public_attr: str;\n    has private_attr: str;\n}",
    "obj_08": "def timer(func) {\n    def wrapper() {\n        print(\"Timing...\");\n        return func();\n    }\n    return wrapper;\n}\n\n@timer\ndef my_function() {\n    print(\"Function executed\");\n}",
    "obj_09": "def call_function(func: callable[[int], int], value: int) -> int {\n    return func(value);\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "city1 = City(name=\"New York\", population=8000000);\ncity2 = City(name=\"Los Angeles\", population=4000000);\ncity1 <++> city2;",
    "graph_03": "edge Road {\n    has distance: float;\n}\n\ncity1 +>:Road:distance=300.0:+> city2;",
    "graph_04": "node ActionNode {\n    can execute with Visitor entry {\n        print(\"Action executed\");\n    }\n}",
    "graph_05": "node VisitorNode {\n    can access_visitor with Visitor entry {\n        print(visitor);\n    }\n}",
    "graph_06": "node A {\n    has value: int;\n}\nnode B {\n    has value: int;\n}\nA ++> B;",
    "graph_07": "root ++> City(name=\"Root City\", population=100000);\n",
    "graph_08": "node ExitNode {\n    can exit_action with Visitor exit {\n        print(\"Exited node\");\n    }\n}",
    "graph_09": "edge CrossableEdge {\n    can cross with Visitor entry {\n        print(\"Crossed edge\");\n    }\n}\n\ncity1 +>:CrossableEdge:+> city2;",
    "graph_10": "node A {};\nnode B {};\nnode C {};\nA ++> B ++> C;",
    "walker_06": "walker MyWalker {can search with Node entry {visit [here -->];}}",
    "walker_07": "root spawn MyWalker();",
    "walker_08": "walker IncomingWalker {can search with Node entry {visit [<-- here];}}",
    "walker_09": "walker ExitWalker {can exit with Node entry {disengage;}}",
    "walker_10": "walker ReportWalker {can report with Node entry {report here;}}",
    "advanced_01": "walker FilterWalker {can search with Node entry {if here.attr == value {report here;}}}",
    "advanced_02": "walker EdgeFilterWalker {can search with Node entry {visit [here ->:EdgeType:->];}}",
    "advanced_03": "walker MultiHopWalker {can search with Node entry {visit [here --> --> -->];}}",
    "advanced_04": "walker EarlyExitWalker {can search with Node entry {if condition {disengage;}}}",
    "advanced_05": "edge TriggerEdge {has strength: float; can trigger with Walker entry {visitor.log(\"Triggered\");}}",
    "advanced_06": "walker DFSWalker {can search with Node entry {visit [here:index:0:];}}",
    "advanced_07": "walker MultiTargetWalker {can search with Node entry {visit [target1, target2];}}",
    "advanced_08": "walker CombinedFilterWalker {can search with Node entry {visit [here --> (`?Person)(?age > 18)];}}",
    "advanced_09": "walker EdgeAttrFilterWalker {can search with Node entry {visit [here ->:EdgeType:weight > 5:->];}}",
    "advanced_10": "del edge_name --> edge_target;",
    "ai_01": "import from byllm {Model};",
    "ai_02": "glob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "def generate_greeting() -> str by llm();",
    "ai_04": "sem MyAttribute.attr = \"description\";",
    "ai_05": "def get_enum() -> Status by llm();",
    "ai_06": "def reason_function(problem: str) -> int by llm(method='Reason');",
    "ai_07": "def react_function(query: str) -> str by llm(method='ReAct', tools=[tool_function]);",
    "ai_08": "import from byllm {Image};",
    "ai_09": "obj Article {has content: str; def summary(self) -> str by llm();};",
    "ai_10": "def create_custom_object() -> CustomObject by llm();",
    "cloud_01": "walker MyWalker {obj __specs__ {static has methods: list = [\"get\", \"post\"];}};",
    "cloud_02": "walker AuthDisabledWalker {obj __specs__ {static has auth: bool = False;}};",
    "cloud_03": "walker CustomPathWalker {obj __specs__ {static has path: str = \"/api/custom\";}};",
    "cloud_04": "walker QueryParamsWalker {obj __specs__ {static has as_query: list = [\"param1\", \"param2\"];}};",
    "cloud_05": "walker PrivateWalker {obj __specs__ {static has private: bool = True;}};",
    "cloud_06": "async walker AsyncWalker {can process with `root entry {await some_async_function();}};",
    "cloud_07": "walker ReferenceWalker {can search with Node entry {walker_id = &self.id;}};",
    "cloud_08": "walker WebhookWalker {obj __specs__ {static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"}};}};",
    "cloud_09": "node MyNode {has attr: str;};\nroot ++> MyNode();",
    "cloud_10": "walker TypedResponseWalker {can search with Node entry {report here as MyType;}};",
    "import_01": "import requests;",
    "import_02": "import from mymodule {my_function};",
    "import_03": "include my_jac_module;",
    "import_04": "import mymodule as alias;",
    "file_01": "with open(\"file.txt\") as f {content = f.read();}",
    "file_02": "with open(\"file.txt\", \"w\") as f {f.write(\"Hello, World!\");}",
    "file_03": "with open(\"data.json\") as f {data = json.load(f);}",
    "impl_01": "impl MyClass.method() {code}",
    "advanced_func_01": "def variable_args_function(*args: int) -> int {return sum(args);}",
    "advanced_func_02": "def keyword_args_function(**kwargs: str) -> dict {return kwargs;}",
    "integration_01": "node Person {\\n    has name: str;\\n    has age: int;\\n}\\n\\nedge Friendship {\\n    has strength: float;\\n}\\n\\nwalker SocialGraph {\\n    can traverse with Person entry {\\n        visit [here --> (`?Person)];\\n        visit [here +>:Friendship:-> (`?Person)];\\n    }\\n}\\n\\nroot spawn SocialGraph();",
    "integration_02": "node State {\\n    has name: str;\\n}\\n\\nwalker StateMachine {\\n    has current_state: str;\\n    can transition with State entry {\\n        if here.name == self.current_state {\\n            self.current_state = here.name;\\n        }\\n    }\\n}\\n\\nroot spawn StateMachine();",
    "integration_03": "walker ErrorHandler {\\n    can handle with Node entry {\\n        try {\\n            risky_operation();\\n        } except ValueError as e {\\n            report f\"Error: {e}\";\\n        }\\n    }\\n}\\n\\nroot spawn ErrorHandler();",
    "integration_04": "async walker AsyncTask {\\n    can execute with `root entry {\\n        result = await async_operation();\\n        report result;\\n    }\\n}\\n\\nroot spawn AsyncTask();",
    "integration_05": "walker CRUD {\\n    can create with Node entry {\\n        new_item = here ++> Item();\\n        save(new_item);\\n    }\\n    can read with Node entry {\\n        items = [root --> (`?Item)];\\n        report items;\\n    }\\n    can update with Node entry {\\n        item = &self.item_id;\\n        item.attr = new_value;\\n        save(item);\\n    }\\n    can delete with Node entry {\\n        item = &self.item_id;\\n        del item;\\n    }\\n}\\n\\nroot spawn CRUD();",
    "integration_06": "walker AITraversal {\\n    can traverse with Node entry {\\n        data = fetch_data(here.id);\\n        result = process_data(data);\\n        report result;\\n    }\\n}\\n\\nroot spawn AITraversal();",
    "integration_07": "walker APISaver {\\n    can save_data with `root entry {\\n        new_data = here ++> Data();\\n        save(new_data);\\n        commit();\\n    }\\n}\\n\\nroot spawn APISaver();",
    "integration_08": "walker BFS {\\n    has queue: list = [];\\n    has visited: set = set();\\n    can search with Node entry {\\n        if here not in self.visited {\\n            self.visited.add(here);\\n            self.queue.extend([here -->]);\\n            process(here);\\n        }\\n        if self.queue {\\n            visit [self.queue.pop(0)];\\n        }\\n    }\\n}\\n\\nroot spawn BFS();",
    "integration_09": "walker Workflow {\\n    can step_one with Node entry {\\n        here.do_something();\\n        visit [here --> next_step];\\n    }\\n    can step_two with Node entry {\\n        here.do_another_thing();\\n        visit [here --> final_step];\\n    }\\n}\\n\\nroot spawn Workflow();",
    "integration_10": "walker Recommendation {\\n    can recommend with User entry {\\n        friends = [here -->:Friendship:-> (`?User)];\\n        recommendations = find_friends_of_friends(friends);\\n        report recommendations;\\n    }\\n}\\n\\nroot spawn Recommendation();",
    "prod_websocket_01": "walker WebSocketBroadcaster {\\n    has message: str;\\n    can broadcast with `root entry {\\n        socket.notify_channels([\"channel1\"], {\\n            \"text\": self.message\\n        });\\n    }\\n}\\n\\nroot spawn WebSocketBroadcaster();",
    "prod_permissions_01": "node Document {\\n    has owner_id: str;\\n    def __jac_access__() -> AccessLevel {\\n        if _Jac.get_root().id == here.owner_id {\\n            return WritePerm;\\n        }\\n        return ReadPerm;\\n    }\\n}\\n\\nroot ++> Document();",
    "prod_cache_01": "node Cache {\\n    has key: str;\\n    has value: any;\\n    has expires: float;\\n}\\n\\nwalker Caching {\\n    can get with `root entry {\\n        caches = [here --> (`?Cache)](?key == self.key);\\n        if caches and caches[0].expires > time() {\\n            report caches[0].value;\\n        } else {\\n            if caches {\\n                del caches[0];\\n            }\\n            value = compute_expensive(self.key);\\n            cache = here ++> Cache(key=self.key, value=value, expires=time()+3600);\\n            report value;\\n        }\\n    }\\n}\\n\\nroot spawn Caching();",
    "prod_validation_01": "walker InputValidator {\\n    can validate with Node entry {\\n        if not is_valid_input(here.input) {\\n            raise ValueError(\"Invalid input\");\\n        }\\n    }\\n}\\n\\nroot spawn InputValidator();",
    "prod_pagination_01": "walker PaginatedQuery {\\n    has page: int = 1;\\n    has per_page: int = 10;\\n    can list with `root entry {\\n        items = [here --> (`?Item)];\\n        start = (self.page - 1) * self.per_page;\\n        end = start + self.per_page;\\n        report {\\n            \"items\": items[start:end],\\n            \"page\": self.page,\\n            \"total\": len(items)\\n        };\\n    }\\n}\\n\\nroot spawn PaginatedQuery();",
    "prod_scheduler_01": "walker DailyTask {\\n    obj __specs__ {\\n        static has schedule: dict = {\\n            \"trigger\": \"cron\",\\n            \"hour\": \"9\",\\n            \"minute\": \"0\",\\n            \"save\": true\\n        };\\n    }\\n    can execute with `root entry {\\n        report \"Task executed\";\\n    }\\n}\\n\\nroot spawn DailyTask();",
    "prod_versioning_01": "node Document {\\n    has version: int = 1;\\n    has content: str;\\n}\\n\\nnode DocumentVersion {\\n    has version: int;\\n    has content: str;\\n    has created: float;\\n}\\n\\nwalker VersionControl {\\n    can update with Document entry {\\n        versioned_doc = here ++> DocumentVersion(version=here.version, content=here.content, created=time());\\n        here.version += 1;\\n        here.content = new_content;\\n        save(versioned_doc);\\n        save(here);\\n        commit();\\n    }\\n}\\n\\nroot spawn VersionControl();",
    "prod_softdelete_01": "node Item {\\n    has is_deleted: bool = false;\\n    has deleted_at: float | None = None;\\n}\\n\\nwalker SoftDelete {\\n    can delete with Item entry {\\n        here.is_deleted = true;\\n        here.deleted_at = time();\\n        save(here);\\n    }\\n}\\n\\nroot spawn SoftDelete();",
    "prod_audit_01": "node AuditLog {\\n    has action: str;\\n    has user_id: str;\\n    has timestamp: float;\\n    has details: dict;\\n}\\n\\nwalker AuditTrail {\\n    can log_action with Node entry {\\n        log = here ++> AuditLog(action=\"action_name\", user_id=visitor.id, timestamp=time(), details={});\\n        save(log);\\n    }\\n}\\n\\nroot spawn AuditTrail();",
    "prod_ratelimit_01": "node RateLimit {\\n    has user_id: str;\\n    has count: int;\\n    has window_start: float;\\n}\\n\\nwalker RateLimiter {\\n    can limit with Node entry {\\n        if self.count > limit {\\n            raise ValueError(\"Rate limit exceeded\");\\n        }\\n    }\\n}\\n\\nroot spawn RateLimiter();",
    "advanced_ai_stream_01": "def generate_stream(prompt: str) -> str by llm(stream=true);\\n\\nfor token in generate_stream(\"Hello, world!\") {\\n    print(token, end=\"\");\\n}",
    "advanced_ai_multimodal_01": "walker ImageProcessor {\\n    can process with Image entry {\\n        img = Image(visitor.files[0]);\\n        analysis = analyze_image(img);\\n        report analysis;\\n    }\\n}\\n\\nroot spawn ImageProcessor();",
    "advanced_ai_react_01": "def assistant(question: str, context: dict) -> str by llm(method='ReAct', tools=[search_web, another_tool]);\\n\\nresult = assistant(\"What is the weather?\", {});",
    "advanced_ai_structured_01": "def extract_person(text: str) -> Person by llm();\\n\\nperson = extract_person(\"John, 25\");",
    "advanced_graph_complex_filter_01": "walker ComplexQuery {\\n    can query with Node entry {\\n        results = [root --> (`?User)](?age > 18)(?active);\\n        report results;\\n    }\\n}\\n\\nroot spawn ComplexQuery();",
    "advanced_graph_pathfind_01": "walker ShortestPath {\\n    has distances: dict;\\n    has unvisited: set;\\n    can search with Node entry {\\n        update_distances();\\n        if here.id == self.target_id {\\n            report reconstruct_path();\\n            disengage;\\n        }\\n        visit min_unvisited();\\n    }\\n}\\n\\nroot spawn ShortestPath();",
    "advanced_graph_cycle_01": "walker CycleDetector {\\n    has visited: set = set();\\n    can detect with Node entry {\\n        if here in self.visited {\\n            report f\"Cycle detected at {here.id}\";\\n        } else {\\n            self.visited.add(here);\\n            visit [here -->];\\n        }\\n    }\\n}\\n\\nroot spawn CycleDetector();",
    "advanced_persist_transaction_01": "walker Transactional {\\n    can process with Node entry {\\n        item1 = here ++> Item();\\n        item2 = here ++> Item();\\n        save(item1);\\n        save(item2);\\n        commit();\\n    }\\n}\\n\\nroot spawn Transactional();",
    "advanced_persist_reference_01": "node ReferenceHolder {\\n    has ref_id: str;\\n}\\n\\nwalker ReferenceRetriever {\\n    can retrieve with Node entry {\\n        ref = &self.ref_id;\\n        report ref;\\n    }\\n}\\n\\nroot spawn ReferenceRetriever();",
    "advanced_cloud_webhook_01": "walker WebhookHandler {\\n    obj __specs__ {\\n        static has webhook: dict = {\\n            \"type\": \"header\",\\n            \"name\": \"X-API-KEY\"\\n        };\\n    }\\n    can handle with `root entry {\\n        report here;\\n    }\\n}\\n\\nroot spawn WebhookHandler();",
    "advanced_cloud_async_retrieve_01": "async walker AsyncRetriever {\\n    can retrieve with `root entry {\\n        task_id = await spawn_task();\\n        status = &task_id.__jac__.status;\\n        report status;\\n    }\\n}\\n\\nroot spawn AsyncRetriever();",
    "advanced_cloud_query_params_01": "walker QueryParams {\\n    obj __specs__ {\\n        static has as_query: list = [\"param1\", \"param2\"];\\n    }\\n    can query with `root entry {\\n        report here;\\n    }\\n}\\n\\nroot spawn QueryParams();",
    "integration_error_handling_01": "walker ErrorHandling {\\n    can handle with Node entry {\\n        try {\\n            risky_operation();\\n        } except Exception as e {\\n            report f\"Error occurred: {e}\";\\n        }\\n    }\\n}\\n\\nroot spawn ErrorHandling();",
    "integration_external_api_01": "import requests;\\n\\nwalker ExternalAPIFetcher {\\n    can fetch with `root entry {\\n        response = requests.get(\"https://api.example.com/data\");\\n        if response.status_code != 200 {\\n            raise ValueError(\"Failed to fetch data\");\\n        }\\n        report response.json();\\n    }\\n}\\n\\nroot spawn ExternalAPIFetcher();",
    "integration_conditional_visit_01": "walker ConditionalVisit {\\n    can visit with Node entry {\\n        if here.condition {\\n            visit [here --> next];\\n        } else {\\n            disengage;\\n        }\\n    }\\n}\\n\\nroot spawn ConditionalVisit();",
    "integration_multi_ability_01": "node MultiAbilityNode {\\n    can entry_ability with Walker entry {\\n        report \"Entered\";\\n    }\\n    can exit_ability with Walker exit {\\n        report \"Exited\";\\n    }\\n}\\n\\nroot ++> MultiAbilityNode();",
    "integration_batch_process_01": "walker BatchProcessor {\\n    can process with Node entry {\\n        items = [root --> (`?Item)];\\n        for item in items {\\n            save(item);\\n        }\\n        commit();\\n    }\\n}\\n\\nroot spawn BatchProcessor();",
    "integration_visitor_communication_01": "node CommunicatingNode {\\n    can modify_visitor with Walker entry {\\n        visitor.state = \"modified\";\\n    }\\n}\\n\\nroot ++> CommunicatingNode();",
    "integration_root_ability_01": "walker RootSpecific {\\n    can execute with `root entry {\\n        report \"Root node accessed\";\\n    }\\n}\\n\\nroot spawn RootSpecific();",
    "integration_edge_traversal_01": "walker EdgeTraversal {\\n    can traverse with Node entry {\\n        edges = [here --->];\\n        for edge in edges {\\n            report edge;\\n        }\\n    }\\n}\\n\\nroot spawn EdgeTraversal();"
  }
}