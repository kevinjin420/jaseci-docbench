{
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n}",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#* This is a\nmulti-line comment\nin Jac *#\n\nwith entry {\n    print(\"Code here\");\n}",
    "basic_07": "with entry {\n    name: str = \"Alice\";\n    message: str = f\"Hello, {name}!\";\n    print(message);\n}",
    "basic_08": "with entry {\n    value: str | int = \"hello\";\n    print(value);\n}",
    "basic_09": "with entry {\n    squares: list = [x * x for x in range(1, 6)];\n    print(squares);\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"positive\");\n    } elif num < 0 {\n        print(\"negative\");\n    } else {\n        print(\"zero\");\n    }\n}",
    "control_01": "with entry {\n    count: int = 1;\n    while count <= 5 {\n        print(count);\n        count += 1;\n    }\n}",
    "control_02": "with entry {\n    status: str = \"active\";\n    match status {\n        case \"active\": {\n            print(\"Processing\");\n        }\n        case \"pending\": {\n            print(\"Waiting\");\n        }\n        case _: {\n            print(\"Unknown\");\n        }\n    }\n}",
    "control_03": "with entry {\n    for i in range(10) {\n        if i == 5 {\n            break;\n        }\n        print(i);\n    }\n}",
    "control_04": "with entry {\n    for i in range(10) {\n        if i % 2 == 0 {\n            continue;\n        }\n        print(i);\n    }\n}",
    "collection_01": "with entry {\n    numbers: set[int] = {1, 2, 3};\n    numbers.add(4);\n    numbers.add(5);\n    print(numbers);\n}",
    "collection_02": "with entry {\n    person: tuple[str, int] = (\"Alice\", 30);\n    print(person);\n}",
    "collection_03": "with entry {\n    squares: dict = {x: x * x for x in range(1, 6)};\n    print(squares);\n}",
    "collection_04": "with entry {\n    names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n    for name in names {\n        print(name);\n    }\n}",
    "collection_05": "with entry {\n    data: dict[str, int] = {\"age\": 30, \"score\": 95};\n    age: int | None = data.get(\"age\");\n    print(age);\n}",
    "type_01": "with entry {\n    value: any = \"hello\";\n    if isinstance(value, str) {\n        print(\"It's a string\");\n    }\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n\n    def get_info(self) -> str {\n        return f\"{self.brand} ({self.year})\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyClass {\n    has value: int;\n\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square = lambda x: int: x * x;\n    result: int = square(5);\n    print(result);\n}",
    "obj_06": "obj MyClass {\n    has _private_attr: str;\n\n    def __init__(self, value: str) {\n        self._private_attr = value;\n    }\n}",
    "obj_07": "obj MyClass {\n    has public_attr: str;\n}",
    "obj_08": "def timer(func: callable) -> callable {\n    def wrapper(*args, **kwargs) {\n        print(\"Starting\");\n        result = func(*args, **kwargs);\n        print(\"Finished\");\n        return result;\n    }\n    return wrapper;\n}\n\n@timer\ndef my_function() -> str {\n    return \"Hello\";\n}",
    "obj_09": "def execute(func: callable) -> any {\n    return func();\n}\n\nwith entry {\n    result = execute(lambda: str: \"Done\");\n    print(result);\n}",
    "obj_10": "def greet(name: str = \"World\", greeting: str = \"Hello\") -> str {\n    return f\"{greeting}, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n    has population: int;\n}\n\nwith entry {\n    city1 = City(name=\"NYC\", population=8000000);\n    city2 = City(name=\"LA\", population=4000000);\n    city1 <++> city2;\n}",
    "graph_03": "node City {\n    has name: str;\n}\n\nedge Road {\n    has distance: float;\n}\n\nwith entry {\n    city1 = City(name=\"NYC\");\n    city2 = City(name=\"LA\");\n    city1 +>:Road:distance=2800.5:+> city2;\n}",
    "graph_04": "node Task {\n    has status: str;\n\n    can process with Worker entry {\n        print(\"Processing task\");\n    }\n}\n\nwalker Worker {}",
    "graph_05": "node Task {\n    has name: str;\n\n    can process with Worker entry {\n        print(f\"Walker ID: {visitor}\");\n    }\n}\n\nwalker Worker {}",
    "graph_06": "node City {\n    has name: str;\n}\n\nwith entry {\n    city1 = City(name=\"NYC\");\n    city2 = City(name=\"LA\");\n    city1 ++> city2;\n}",
    "graph_07": "node User {\n    has username: str;\n}\n\nwith entry {\n    user = User(username=\"alice\");\n    root ++> user;\n}",
    "graph_08": "node Task {\n    has status: str;\n\n    can finish with Worker exit {\n        print(\"Task completed\");\n    }\n}\n\nwalker Worker {}",
    "graph_09": "node City {\n    has name: str;\n}\n\nedge Highway {\n    has toll: float;\n\n    can cross with Driver entry {\n        print(f\"Crossing highway, toll: {self.toll}\");\n    }\n}\n\nwalker Driver {}",
    "graph_10": "node Step {\n    has number: int;\n}\n\nwith entry {\n    step1 = Step(number=1);\n    step2 = Step(number=2);\n    step3 = Step(number=3);\n    step1 ++> step2 ++> step3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker Traverser {\n    can explore with Node entry {\n        visit [here -->];\n    }\n}\n\nnode Node {}",
    "walker_03": "walker TypedTraverser {\n    can explore with Node entry {\n        visit [here --> (`?City)];\n    }\n}\n\nnode Node {}\nnode City {}",
    "walker_04": "walker Explorer {\n    can explore with Node entry {\n        print(here);\n    }\n}\n\nnode Node {}",
    "walker_05": "walker DataCollector {\n    can collect with Node entry {\n        report \"collected data\";\n    }\n}\n\nnode Node {}",
    "walker_06": "node MyNode {}\n\nwalker MyWalker {}\n\nwith entry {\n    node = MyNode();\n    node spawn MyWalker();\n}",
    "walker_07": "walker MyWalker {}\n\nwith entry {\n    root spawn MyWalker();\n}",
    "walker_08": "walker BackwardTraverser {\n    can explore with Node entry {\n        visit [<-- here];\n    }\n}\n\nnode Node {}",
    "walker_09": "walker Explorer {\n    can cleanup with Node exit {\n        print(\"Leaving node\");\n    }\n}\n\nnode Node {}",
    "walker_10": "walker CurrentNode {\n    can get_current with Node entry {\n        report here;\n    }\n}\n\nnode Node {}",
    "advanced_01": "walker FilteredTraverser {\n    can explore with Node entry {\n        visit [here --> (`?Task)](?status == \"active\");\n    }\n}\n\nnode Node {}\nnode Task {\n    has status: str;\n}",
    "advanced_02": "walker EdgeFiltered {\n    can explore with Node entry {\n        visit [here ->:Follows:-> (`?User)];\n    }\n}\n\nnode Node {}\nnode User {}\nedge Follows {}",
    "advanced_03": "walker MultiHop {\n    can explore with Node entry {\n        visit [here --> --> --> (`?Target)];\n    }\n}\n\nnode Node {}\nnode Target {}",
    "advanced_04": "walker EarlyExit {\n    has max_visits: int = 5;\n    has count: int = 0;\n\n    can explore with Node entry {\n        self.count += 1;\n        if self.count >= self.max_visits {\n            disengage;\n        }\n        visit [here -->];\n    }\n}\n\nnode Node {}",
    "advanced_05": "node City {\n    has name: str;\n}\n\nedge Road {\n    has distance: float;\n\n    can traverse with Driver entry {\n        print(f\"Driving on road: {self.distance} miles\");\n    }\n}\n\nwalker Driver {}",
    "advanced_06": "walker DFS {\n    has visited: set = set();\n\n    can search with Node entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            children: list = [here -->];\n            for child in children {\n                if child not in self.visited {\n                    visit [child];\n                }\n            }\n        }\n    }\n}\n\nnode Node {}",
    "advanced_07": "walker MultiTarget {\n    has targets: list;\n\n    can visit_targets with Node entry {\n        visit self.targets;\n    }\n}\n\nnode Node {}",
    "advanced_08": "walker CombinedFilter {\n    can explore with Node entry {\n        visit [here --> (`?Person)](?age > 18);\n    }\n}\n\nnode Node {}\nnode Person {\n    has age: int;\n}",
    "advanced_09": "walker WeightFilter {\n    can explore with Node entry {\n        visit [here ->:Connection:weight > 5:-> (`?Node)];\n    }\n}\n\nnode Node {}\nedge Connection {\n    has weight: float;\n}",
    "advanced_10": "node City {\n    has name: str;\n}\n\nwith entry {\n    city1 = City(name=\"NYC\");\n    city2 = City(name=\"LA\");\n    city1 ++> city2;\n    city1 del --> city2;\n}",
    "ai_01": "import from byllm {Model}",
    "ai_02": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef generate_greeting(name: str) -> str by llm();",
    "ai_04": "node Person {\n    has name: str;\n    has age: int;\n}\n\nsem Person.age = \"The person's age in years\";",
    "ai_05": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nenum Sentiment {\n    POSITIVE,\n    NEGATIVE,\n    NEUTRAL\n}\n\ndef analyze_sentiment(text: str) -> Sentiment by llm();",
    "ai_06": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef solve_problem(problem: str) -> str by llm(method='Reason');",
    "ai_07": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef search_web(query: str) -> str {\n    return \"search results\";\n}\n\ndef assistant(question: str) -> str by llm(method='ReAct', tools=[search_web]);",
    "ai_08": "import from byllm {Image}",
    "ai_09": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nobj Article {\n    has content: str;\n\n    def summarize(self) -> str by llm();\n}",
    "ai_10": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nobj PersonData {\n    has name: str;\n    has age: int;\n}\n\ndef extract_person(text: str) -> PersonData by llm();",
    "cloud_01": "walker ApiWalker {\n    has data: str;\n\n    obj __specs__ {\n        static has methods: list = [\"get\", \"post\"];\n    }\n\n    can process with `root entry {\n        report self.data;\n    }\n}",
    "cloud_02": "walker PublicWalker {\n    has message: str;\n\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n\n    can process with `root entry {\n        report self.message;\n    }\n}",
    "cloud_03": "walker CustomPath {\n    has data: str;\n\n    obj __specs__ {\n        static has path: str = \"/api/custom\";\n    }\n\n    can process with `root entry {\n        report self.data;\n    }\n}",
    "cloud_04": "walker SearchWalker {\n    has query: str;\n    has limit: int;\n\n    obj __specs__ {\n        static has as_query: list = [\"query\", \"limit\"];\n    }\n\n    can search with `root entry {\n        report self.query;\n    }\n}",
    "cloud_05": "walker InternalWalker {\n    has data: str;\n\n    obj __specs__ {\n        static has private: bool = True;\n    }\n\n    can process with `root entry {\n        report self.data;\n    }\n}",
    "cloud_06": "async walker HeavyTask {\n    has data: list;\n\n    can process with `root entry {\n        report \"Processing\";\n    }\n}",
    "cloud_07": "walker TaskManager {\n    has task_id: str;\n\n    can retrieve with `root entry {\n        task = &self.task_id;\n        report task;\n    }\n}",
    "cloud_08": "walker WebhookHandler {\n    has payload: dict;\n\n    obj __specs__ {\n        static has webhook: dict = {\"type\": \"header\", \"name\": \"X-API-KEY\"};\n    }\n\n    can handle with `root entry {\n        report self.payload;\n    }\n}",
    "cloud_09": "node User {\n    has username: str;\n}\n\nwalker CreateUser {\n    has username: str;\n\n    can create with `root entry {\n        user = User(username=self.username);\n        root ++> user;\n        report user;\n    }\n}",
    "cloud_10": "walker GetData {\n    has id: str;\n\n    can fetch with `root entry -> dict {\n        return {\"id\": self.id, \"status\": \"success\"};\n    }\n}",
    "import_01": "import json;\n\nwith entry {\n    data = json.dumps({\"key\": \"value\"});\n    print(data);\n}",
    "import_02": "import from json {dumps, loads};\n\nwith entry {\n    data = dumps({\"key\": \"value\"});\n    print(data);\n}",
    "import_03": "include:jac my_module;\n\nwith entry {\n    print(\"Module included\");\n}",
    "import_04": "import json as j;\n\nwith entry {\n    data = j.dumps({\"key\": \"value\"});\n    print(data);\n}",
    "file_01": "with entry {\n    with open(\"data.txt\", \"r\") as f {\n        content = f.read();\n        print(content);\n    }\n}",
    "file_02": "with entry {\n    with open(\"output.txt\", \"w\") as f {\n        f.write(\"Hello, World!\");\n    }\n}",
    "file_03": "import json;\n\nwith entry {\n    with open(\"data.json\", \"r\") as f {\n        data = json.load(f);\n        print(data);\n    }\n}",
    "impl_01": "obj Calculator {\n    has value: int;\n\n    def add(n: int) -> int;\n}\n\nimpl Calculator.add(n: int) -> int {\n    self.value += n;\n    return self.value;\n}",
    "advanced_func_01": "def sum_all(*nums: int) -> int {\n    return sum(nums);\n}",
    "advanced_func_02": "def configure(**options: str) -> dict {\n    return options;\n}",
    "integration_01": "node Person {\n    has name: str;\n    has age: int;\n}\n\nedge Friendship {\n    has since: str;\n}\n\nwalker FriendFinder {\n    has results: list = [];\n\n    can explore with Person entry {\n        self.results.append(here);\n        visit [here ->:Friendship:-> (`?Person)];\n    }\n}\n\nwith entry {\n    alice = Person(name=\"Alice\", age=30);\n    bob = Person(name=\"Bob\", age=25);\n    alice +>:Friendship:since=\"2020\":+> bob;\n    root ++> alice;\n    root spawn FriendFinder();\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nwalker StateMachine {\n    has current_state: str = \"idle\";\n\n    can transition with State entry {\n        if here.name == \"start\" {\n            self.current_state = \"running\";\n        } elif here.name == \"stop\" {\n            self.current_state = \"stopped\";\n        }\n        report self.current_state;\n    }\n}\n\nwith entry {\n    idle = State(name=\"idle\");\n    start = State(name=\"start\");\n    stop = State(name=\"stop\");\n    idle ++> start ++> stop;\n    root ++> idle;\n}",
    "integration_03": "walker SafeProcessor {\n    has value: int;\n\n    can process with `root entry {\n        try {\n            result: int = 100 / self.value;\n            report result;\n        } except ZeroDivisionError {\n            report \"Error: Division by zero\";\n        }\n    }\n}",
    "integration_04": "import asyncio;\n\nasync def fetch_data(url: str) -> str {\n    await asyncio.sleep(1);\n    return f\"Data from {url}\";\n}\n\nwith entry {\n    result = asyncio.run(fetch_data(\"http://example.com\"));\n    print(result);\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker CRUDManager {\n    has action: str;\n    has name: str;\n    has value: int;\n    has item_id: str;\n\n    can execute with `root entry {\n        if self.action == \"create\" {\n            item = Item(name=self.name, value=self.value);\n            root ++> item;\n            save(item);\n            commit();\n            report item;\n        } elif self.action == \"read\" {\n            items: list = [root --> (`?Item)];\n            report items;\n        } elif self.action == \"update\" {\n            item = &self.item_id;\n            item.value = self.value;\n            save(item);\n            commit();\n            report item;\n        } elif self.action == \"delete\" {\n            item = &self.item_id;\n            del item;\n            commit();\n            report \"deleted\";\n        }\n    }\n}",
    "integration_06": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nnode Document {\n    has content: str;\n}\n\ndef summarize(text: str) -> str by llm();\n\nwalker AITraverser {\n    has summaries: list = [];\n\n    can process with Document entry {\n        summary: str = summarize(here.content);\n        self.summaries.append(summary);\n        report summary;\n        visit [here -->];\n    }\n}",
    "integration_07": "node User {\n    has username: str;\n    has email: str;\n}\n\nwalker RegisterUser {\n    has username: str;\n    has email: str;\n\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n    }\n\n    can register with `root entry {\n        user = User(username=self.username, email=self.email);\n        root ++> user;\n        save(user);\n        commit();\n        report user;\n    }\n}",
    "integration_08": "node Node {\n    has value: int;\n}\n\nwalker BFS {\n    has queue: list = [];\n    has visited: set = set();\n    has results: list = [];\n\n    can search with Node entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            self.results.append(here.value);\n            children: list = [here -->];\n            for child in children {\n                if child not in self.visited {\n                    self.queue.append(child);\n                }\n            }\n        }\n        if self.queue {\n            next_node = self.queue.pop(0);\n            visit [next_node];\n        } else {\n            report self.results;\n        }\n    }\n}",
    "integration_09": "node TaskNode {\n    has name: str;\n    has status: str = \"pending\";\n\n    can start with Worker entry {\n        here.status = \"running\";\n        print(f\"Started: {here.name}\");\n    }\n\n    can finish with Worker exit {\n        here.status = \"done\";\n        print(f\"Finished: {here.name}\");\n    }\n}\n\nwalker Worker {\n    can execute with TaskNode entry {\n        visit [here -->];\n    }\n}",
    "integration_10": "node User {\n    has name: str;\n}\n\nnode Post {\n    has content: str;\n}\n\nedge Follows {}\nedge Posted {}\n\nwalker Recommender {\n    has recommendations: list = [];\n\n    can recommend with User entry {\n        friends: list = [here ->:Follows:-> (`?User)];\n        for friend in friends {\n            friend_posts: list = [friend ->:Posted:-> (`?Post)];\n            for post in friend_posts {\n                self.recommendations.append(post);\n            }\n        }\n        report self.recommendations;\n    }\n}",
    "prod_websocket_01": "import from jac_cloud.plugin {WEBSOCKET_MANAGER as socket};\n\nwalker BroadcastWalker {\n    has message: str;\n\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can broadcast with `root entry {\n        socket.notify_channels([\"public\"], {\"text\": self.message});\n        report \"broadcasted\";\n    }\n}",
    "prod_permissions_01": "import from jac_cloud.plugin {ReadPerm, WritePerm, NoPerm, _Jac};\n\nnode Document {\n    has owner_id: str;\n    has is_public: bool;\n\n    def __jac_access__() -> any {\n        if here.is_public {\n            return ReadPerm;\n        }\n        if _Jac.get_root().id == here.owner_id {\n            return WritePerm;\n        }\n        return NoPerm;\n    }\n}",
    "prod_cache_01": "import time;\n\nnode Cache {\n    has key: str;\n    has value: any;\n    has expires: float;\n}\n\nwalker GetCached {\n    has key: str;\n\n    can get with `root entry {\n        caches: list = [root --> (`?Cache)](?key == self.key);\n        if caches and caches[0].expires > time.time() {\n            report caches[0].value;\n        } else {\n            if caches {\n                del caches[0];\n            }\n            value: str = \"expensive_computation_result\";\n            cache = Cache(key=self.key, value=value, expires=time.time() + 3600);\n            root ++> cache;\n            save(cache);\n            commit();\n            report value;\n        }\n    }\n}",
    "prod_validation_01": "walker ValidatedInput {\n    has email: str;\n    has age: int;\n\n    can validate with `root entry {\n        if \"@\" not in self.email {\n            raise ValueError(\"Invalid email format\");\n        }\n        if self.age < 0 or self.age > 150 {\n            raise ValueError(\"Invalid age range\");\n        }\n        report {\"email\": self.email, \"age\": self.age};\n    }\n}",
    "prod_pagination_01": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker PaginatedQuery {\n    has page: int = 1;\n    has per_page: int = 10;\n    has min_value: int = 0;\n\n    can query with `root entry {\n        items: list = [root --> (`?Item)](?value > self.min_value);\n        start: int = (self.page - 1) * self.per_page;\n        end: int = start + self.per_page;\n        report {\n            \"items\": items[start:end],\n            \"page\": self.page,\n            \"total\": len(items),\n            \"pages\": (len(items) + self.per_page - 1) // self.per_page\n        };\n    }\n}",
    "prod_scheduler_01": "walker DailyReport {\n    obj __specs__ {\n        static has private: bool = True;\n        static has schedule: dict = {\n            \"trigger\": \"cron\",\n            \"hour\": \"9\",\n            \"minute\": \"0\",\n            \"save\": True\n        };\n    }\n\n    can generate with `root entry {\n        report \"Daily report generated\";\n    }\n}",
    "prod_versioning_01": "import time;\n\nnode Document {\n    has version: int = 1;\n    has content: str;\n}\n\nnode DocumentVersion {\n    has version: int;\n    has content: str;\n    has created: float;\n}\n\nwalker UpdateDocument {\n    has doc_id: str;\n    has new_content: str;\n\n    can update with `root entry {\n        doc = &self.doc_id;\n        version_node = DocumentVersion(\n            version=doc.version,\n            content=doc.content,\n            created=time.time()\n        );\n        doc ++> version_node;\n        doc.version += 1;\n        doc.content = self.new_content;\n        save(doc);\n        save(version_node);\n        commit();\n        report doc;\n    }\n}",
    "prod_softdelete_01": "node Item {\n    has name: str;\n    has is_deleted: bool = False;\n    has deleted_at: float | None = None;\n}\n\nwalker SoftDelete {\n    has item_id: str;\n\n    can delete with `root entry {\n        item = &self.item_id;\n        item.is_deleted = True;\n        item.deleted_at = 1234567890.0;\n        save(item);\n        commit();\n        report \"deleted\";\n    }\n}\n\nwalker QueryActive {\n    can query with `root entry {\n        items: list = [root --> (`?Item)](?not is_deleted);\n        report items;\n    }\n}",
    "prod_audit_01": "import time;\n\nnode AuditLog {\n    has action: str;\n    has user_id: str;\n    has timestamp: float;\n    has details: dict;\n}\n\nwalker LogAction {\n    has action: str;\n    has user_id: str;\n    has details: dict;\n\n    can log with `root entry {\n        log = AuditLog(\n            action=self.action,\n            user_id=self.user_id,\n            timestamp=time.time(),\n            details=self.details\n        );\n        root ++> log;\n        save(log);\n        commit();\n        report log;\n    }\n}",
    "prod_ratelimit_01": "import time;\n\nnode RateLimit {\n    has user_id: str;\n    has count: int;\n    has window_start: float;\n}\n\nwalker CheckRateLimit {\n    has user_id: str;\n    has max_requests: int = 100;\n    has window_seconds: float = 3600.0;\n\n    can check with `root entry {\n        limits: list = [root --> (`?RateLimit)](?user_id == self.user_id);\n        current_time: float = time.time();\n\n        if limits {\n            limit = limits[0];\n            if current_time - limit.window_start > self.window_seconds {\n                limit.count = 1;\n                limit.window_start = current_time;\n            } else {\n                limit.count += 1;\n                if limit.count > self.max_requests {\n                    raise Exception(\"Rate limit exceeded\");\n                }\n            }\n            save(limit);\n            commit();\n        } else {\n            limit = RateLimit(\n                user_id=self.user_id,\n                count=1,\n                window_start=current_time\n            );\n            root ++> limit;\n            save(limit);\n            commit();\n        }\n        report \"allowed\";\n    }\n}",
    "advanced_ai_stream_01": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef generate_story(prompt: str) -> str by llm(stream=True);\n\nwith entry {\n    for token in generate_story(\"Write a story\") {\n        print(token);\n    }\n}",
    "advanced_ai_multimodal_01": "import from byllm {Model, Image};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef analyze_image(img: Image) -> str by llm();\n\nwalker ImageAnalyzer {\n    has image_path: str;\n\n    can analyze with `root entry {\n        img = Image(self.image_path);\n        description: str = analyze_image(img);\n        report description;\n    }\n}",
    "advanced_ai_react_01": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef search_web(query: str) -> str {\n    return \"search results for: \" + query;\n}\n\ndef calculator(expression: str) -> str {\n    return \"calculated: \" + expression;\n}\n\ndef assistant(question: str) -> str by llm(method='ReAct', tools=[search_web, calculator]);",
    "advanced_ai_structured_01": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nobj PersonInfo {\n    has name: str;\n    has age: int;\n    has occupation: str;\n}\n\ndef extract_person_info(text: str) -> PersonInfo by llm();",
    "advanced_graph_complex_filter_01": "node Person {\n    has name: str;\n    has age: int;\n}\n\nedge Knows {\n    has strength: float;\n}\n\nwalker ComplexQuery {\n    can query with Person entry {\n        visit [here ->:Knows:strength > 0.5:-> (`?Person)](?age > 18);\n    }\n}",
    "advanced_graph_pathfind_01": "node GraphNode {\n    has id: str;\n    has value: int;\n}\n\nedge Connection {\n    has weight: float;\n}\n\nwalker ShortestPath {\n    has target_id: str;\n    has distances: dict = {};\n    has unvisited: set = set();\n    has visited: set = set();\n\n    can search with GraphNode entry {\n        if here.id not in self.distances {\n            self.distances[here.id] = 999999.0;\n        }\n        if here.id == self.target_id {\n            report self.distances;\n            disengage;\n        }\n        self.visited.add(here.id);\n        neighbors: list = [here -->];\n        for neighbor in neighbors {\n            if neighbor.id not in self.visited {\n                self.unvisited.add(neighbor);\n            }\n        }\n        if self.unvisited {\n            next_node = list(self.unvisited)[0];\n            self.unvisited.remove(next_node);\n            visit [next_node];\n        }\n    }\n}",
    "advanced_graph_cycle_01": "node GraphNode {\n    has id: str;\n}\n\nwalker CycleDetector {\n    has visited: set = set();\n    has path: set = set();\n    has cycles: list = [];\n\n    can detect with GraphNode entry {\n        if here.id in self.path {\n            self.cycles.append(here.id);\n            report \"Cycle detected\";\n            disengage;\n        }\n        if here.id in self.visited {\n            disengage;\n        }\n        self.visited.add(here.id);\n        self.path.add(here.id);\n        visit [here -->];\n        self.path.remove(here.id);\n    }\n}",
    "advanced_persist_transaction_01": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker BatchUpdate {\n    has items_data: list;\n\n    can update with `root entry {\n        for item_data in self.items_data {\n            item = Item(name=item_data[\"name\"], value=item_data[\"value\"]);\n            root ++> item;\n            save(item);\n        }\n        commit();\n        report \"batch complete\";\n    }\n}",
    "advanced_persist_reference_01": "node User {\n    has username: str;\n}\n\nwalker StoreReference {\n    has username: str;\n\n    can store with `root entry {\n        user = User(username=self.username);\n        root ++> user;\n        save(user);\n        commit();\n        user_id: str = user.id;\n        report user_id;\n    }\n}\n\nwalker RetrieveByReference {\n    has user_id: str;\n\n    can retrieve with `root entry {\n        user = &self.user_id;\n        report user;\n    }\n}",
    "advanced_cloud_webhook_01": "walker WebhookReceiver {\n    has data: dict;\n\n    obj __specs__ {\n        static has webhook: dict = {\n            \"type\": \"header\",\n            \"name\": \"X-Webhook-Key\"\n        };\n    }\n\n    can handle with `root entry {\n        report self.data;\n    }\n}",
    "advanced_cloud_async_retrieve_01": "async walker BackgroundTask {\n    has data: list;\n\n    can process with `root entry {\n        report \"processing\";\n    }\n}\n\nwalker TaskSpawner {\n    can spawn with `root entry {\n        result = root spawn BackgroundTask(data=[1, 2, 3]);\n        task_id: str = result;\n        report task_id;\n    }\n}\n\nwalker TaskChecker {\n    has task_id: str;\n\n    can check with `root entry {\n        task = &self.task_id;\n        status: str = task.__jac__.status;\n        reports: list = task.__jac__.reports;\n        report {\"status\": status, \"reports\": reports};\n    }\n}",
    "advanced_cloud_query_params_01": "walker SearchAPI {\n    has query: str;\n    has limit: int;\n    has offset: int;\n\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has as_query: list = [\"query\", \"limit\", \"offset\"];\n    }\n\n    can search with `root entry {\n        report {\"query\": self.query, \"limit\": self.limit, \"offset\": self.offset};\n    }\n}",
    "integration_error_handling_01": "walker SafeOperation {\n    has divisor: int;\n\n    can execute with `root entry {\n        try {\n            result: int = 100 / self.divisor;\n            report result;\n        } except ZeroDivisionError as e {\n            print(f\"Error: {e}\");\n            report \"fallback value\";\n        }\n    }\n}",
    "integration_external_api_01": "import requests;\n\nwalker ApiFetcher {\n    has url: str;\n\n    can fetch with `root entry {\n        try {\n            response = requests.get(self.url);\n            data = response.json();\n            report data;\n        } except Exception as e {\n            print(f\"API Error: {e}\");\n            report {\"error\": \"Failed to fetch\"};\n        }\n    }\n}",
    "integration_conditional_visit_01": "node DataNode {\n    has value: int;\n}\n\nwalker ConditionalTraverser {\n    can traverse with DataNode entry {\n        children: list = [here -->];\n        if children {\n            visit children;\n        } else {\n            report \"No children, stopping\";\n            disengage;\n        }\n    }\n}",
    "integration_multi_ability_01": "node ProcessNode {\n    has name: str;\n\n    can on_enter with Worker entry {\n        print(f\"Entering: {here.name}\");\n    }\n\n    can on_exit with Worker exit {\n        print(f\"Exiting: {here.name}\");\n    }\n}\n\nwalker Worker {}",
    "integration_batch_process_01": "node DataItem {\n    has value: int;\n}\n\nwalker BatchProcessor {\n    has items: list;\n\n    can process with `root entry {\n        for item_value in self.items {\n            item = DataItem(value=item_value);\n            root ++> item;\n            save(item);\n        }\n        commit();\n        report \"batch processed\";\n    }\n}",
    "integration_visitor_communication_01": "node Counter {\n    has count: int = 0;\n\n    can increment with Visitor entry {\n        here.count += 1;\n        visitor.total += 1;\n    }\n}\n\nwalker Visitor {\n    has total: int = 0;\n\n    can visit_counters with Counter entry {\n        report self.total;\n    }\n}",
    "integration_root_ability_01": "walker RootInitializer {\n    can setup with `root entry {\n        print(\"Initializing at root\");\n        report \"initialized\";\n    }\n}",
    "integration_edge_traversal_01": "node City {\n    has name: str;\n}\n\nedge Road {\n    has distance: float;\n}\n\nwalker EdgeExplorer {\n    has edge_info: list = [];\n\n    can explore with City entry {\n        edges: list = [here --->];\n        for edge in edges {\n            self.edge_info.append({\"type\": \"Road\", \"distance\": edge.distance});\n        }\n        report self.edge_info;\n    }\n}"
}