{
  "metadata": {
    "model": "claude-sonnet-4-5-20250929",
    "model_alias": "claude-sonnet",
    "variant": "mini_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n}",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#* This is a\nmulti-line comment\nin Jac *#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    message: str = f\"Hello, {name}!\";\n}",
    "basic_08": "with entry {\n    value: str | int = \"hello\";\n}",
    "basic_09": "with entry {\n    squares: list[int] = [i * i for i in range(1, 6)];\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"positive\");\n    } elif num < 0 {\n        print(\"negative\");\n    } else {\n        print(\"zero\");\n    }\n}",
    "control_01": "with entry {\n    count: int = 1;\n    while count <= 5 {\n        print(count);\n        count += 1;\n    }\n}",
    "control_02": "with entry {\n    value: int = 2;\n    match value {\n        case 1: print(\"one\");\n        case 2: print(\"two\");\n        case _: print(\"other\");\n    }\n}",
    "control_03": "with entry {\n    for i = 1 to i <= 10 by i += 1 {\n        if i == 5 {\n            break;\n        }\n        print(i);\n    }\n}",
    "control_04": "with entry {\n    for i = 1 to i <= 10 by i += 1 {\n        if i % 2 == 0 {\n            continue;\n        }\n        print(i);\n    }\n}",
    "collection_01": "with entry {\n    numbers: set[int] = {1, 2, 3};\n    numbers.add(4);\n}",
    "collection_02": "with entry {\n    person: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares: dict[int, int] = {i: i * i for i in range(1, 6)};\n}",
    "collection_04": "with entry {\n    names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n    for name in names {\n        print(name);\n    }\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n    age: int | None = ages.get(\"Alice\");\n}",
    "type_01": "with entry {\n    value: any = \"hello\";\n    if isinstance(value, str) {\n        print(\"It's a string\");\n    }\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n\n    def get_info() -> str {\n        return f\"{self.brand} ({self.year})\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    has value: int;\n\n    def postinit() {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square = lambda x: int: x * x;\n}",
    "obj_06": "obj MyClass {\n    has :priv: secret: str;\n}",
    "obj_07": "obj MyClass {\n    has :pub: name: str;\n}",
    "obj_08": "def my_decorator(func: callable) -> callable {\n    return func;\n}\n\n@my_decorator\ndef my_function() -> None {\n    print(\"Hello\");\n}",
    "obj_09": "def call_function(func: callable) -> None {\n    func();\n}\n\nwith entry {\n    call_function(lambda: None: print(\"Called\"));\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n    has population: int;\n}\n\nwith entry {\n    city1 = City(name=\"New York\", population=8000000);\n    city2 = City(name=\"Los Angeles\", population=4000000);\n    city1 <++> city2;\n}",
    "graph_03": "node City {\n    has name: str;\n    has population: int;\n}\n\nedge Road {\n    has distance: float;\n}\n\nwith entry {\n    city1 = City(name=\"New York\", population=8000000);\n    city2 = City(name=\"Boston\", population=700000);\n    city1 +>:Road:distance=215.0:+> city2;\n}",
    "graph_04": "node MyNode {\n    has value: int;\n\n    can process with entry {\n        print(\"Node entered\");\n    }\n}",
    "graph_05": "walker MyWalker {\n    has data: str;\n}\n\nnode MyNode {\n    has value: int;\n\n    can process with MyWalker entry {\n        print(visitor.data);\n    }\n}",
    "graph_06": "node City {\n    has name: str;\n}\n\nwith entry {\n    city1 = City(name=\"New York\");\n    city2 = City(name=\"Boston\");\n    city1 ++> city2;\n}",
    "graph_07": "node MyNode {\n    has value: int;\n}\n\nwith entry {\n    n = MyNode(value=42);\n    root ++> n;\n}",
    "graph_08": "walker MyWalker {\n    has data: str;\n}\n\nnode MyNode {\n    has value: int;\n\n    can process with MyWalker exit {\n        print(\"Walker leaving\");\n    }\n}",
    "graph_09": "edge MyEdge {\n    has weight: int;\n\n    can process {\n        print(\"Edge crossed\");\n    }\n}",
    "graph_10": "node City {\n    has name: str;\n}\n\nwith entry {\n    city1 = City(name=\"A\");\n    city2 = City(name=\"B\");\n    city3 = City(name=\"C\");\n    city1 ++> city2 ++> city3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker MyWalker {\n    has count: int = 0;\n\n    can explore with `root entry {\n        visit [-->];\n    }\n}",
    "walker_03": "node City {\n    has name: str;\n}\n\nwalker CityExplorer {\n    can explore with `root entry {\n        visit [-->(`?City)];\n    }\n}",
    "walker_04": "walker MyWalker {\n    has data: str;\n\n    can process with `root entry {\n        print(here);\n    }\n}",
    "walker_05": "walker MyWalker {\n    has value: int;\n\n    can process with `root entry {\n        report value;\n    }\n}",
    "walker_06": "node MyNode {}\n\nwalker MyWalker {}\n\nwith entry {\n    n = MyNode();\n    n spawn MyWalker();\n}",
    "walker_07": "walker MyWalker {}\n\nwith entry {\n    root spawn MyWalker();\n}",
    "walker_08": "node MyNode {}\n\nwalker MyWalker {\n    can traverse {\n        visit [<--];\n    }\n}",
    "walker_09": "walker MyWalker {\n    can exit_ability with `root exit {\n        print(\"Exiting\");\n    }\n}",
    "walker_10": "walker MyWalker {\n    can traverse {\n        report here;\n    }\n}",
    "advanced_01": "node Person {\n    has age: int;\n}\n\nwalker AgeFilter {\n    can traverse {\n        visit [-->(`?Person)](?age == 25);\n    }\n}",
    "advanced_02": "edge MyEdge {}\n\nwalker EdgeFilter {\n    can traverse {\n        visit [->:MyEdge:->];\n    }\n}",
    "advanced_03": "node MyNode {}\n\nwalker MultiHop {\n    can traverse {\n        visit [-->-->-->];\n    }\n}",
    "advanced_04": "walker EarlyExit {\n    can traverse {\n        if True {\n            disengage;\n        }\n    }\n}",
    "advanced_05": "edge MyEdge {\n    can ability with walker entry {\n        print(\"Walker entered edge\");\n    }\n}",
    "advanced_06": "walker DFSWalker {\n    can traverse {\n        visit :0: [-->];\n    }\n}",
    "advanced_07": "node MyNode {}\n\nwalker MultiVisit {\n    can traverse with `root entry {\n        n1 = MyNode();\n        n2 = MyNode();\n        visit [n1, n2];\n    }\n}",
    "advanced_08": "node Person {\n    has age: int;\n}\n\nwalker CombinedFilter {\n    can traverse {\n        visit [-->(`?Person)](?age > 18);\n    }\n}",
    "advanced_09": "edge Weighted {\n    has weight: int;\n}\n\nwalker EdgeAttrFilter {\n    can traverse {\n        visit [->:Weighted:weight>5:->];\n    }\n}",
    "advanced_10": "node N1 {}\nnode N2 {}\nedge E {}\n\nwith entry {\n    n1 = N1();\n    n2 = N2();\n    n1 +>:E:+> n2;\n    del n1 -->:E:--> n2;\n}",
    "ai_01": "import from byllm {Model}",
    "ai_02": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef greet(name: str) -> str by llm();",
    "ai_04": "obj Person {\n    has name: str = \"John\" sem \"The person's full name\";\n}",
    "ai_05": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\nenum Sentiment {\n    POSITIVE,\n    NEGATIVE,\n    NEUTRAL\n}\n\ndef analyze(text: str) -> Sentiment by llm();",
    "ai_06": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef solve(problem: str) -> str by llm(method='Reason');",
    "ai_07": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef search(query: str) -> str by llm(method='ReAct', tools=[]);",
    "ai_08": "import from byllm {Image}",
    "ai_09": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\nobj Assistant {\n    has context: str;\n    \n    def respond(query: str) -> str by llm();\n}",
    "ai_10": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\nobj Response {\n    has answer: str;\n    has confidence: float;\n}\n\ndef analyze(text: str) -> Response by llm();",
    "cloud_01": "walker MyWalker {\n    obj __specs__ {\n        static has methods: list = [\"get\", \"post\"];\n    }\n}",
    "cloud_02": "walker MyWalker {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n}",
    "cloud_03": "walker MyWalker {\n    obj __specs__ {\n        static has path: str = \"/api/custom\";\n    }\n}",
    "cloud_04": "walker MyWalker {\n    has param1: str;\n    has param2: int;\n    \n    obj __specs__ {\n        static has as_query: list = [\"*\"];\n    }\n}",
    "cloud_05": "walker MyWalker {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n}",
    "cloud_06": "async walker MyAsyncWalker {\n    can traverse {\n        print(\"Async walker\");\n    }\n}",
    "cloud_07": "walker MyWalker {}\n\nwith entry {\n    result = root spawn MyWalker();\n    task = &result;\n}",
    "cloud_08": "walker WebhookWalker {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/webhook\";\n    }\n}",
    "cloud_09": "node MyNode {}\n\nwith entry {\n    n = MyNode();\n    root ++> n;\n}",
    "cloud_10": "obj Response {\n    has message: str;\n    has status: int;\n}\n\nwalker MyWalker {\n    can traverse -> Response {\n        return Response(message=\"Success\", status=200);\n    }\n}",
    "import_01": "import json",
    "import_02": "import from json {loads, dumps}",
    "import_03": "include:jac mymodule",
    "import_04": "import json as js",
    "file_01": "with entry {\n    with open(\"file.txt\", \"r\") as f {\n        content = f.read();\n    }\n}",
    "file_02": "with entry {\n    with open(\"file.txt\", \"w\") as f {\n        f.write(\"Hello\");\n    }\n}",
    "file_03": "import json;\n\nwith entry {\n    with open(\"data.json\", \"r\") as f {\n        data = json.load(f);\n    }\n}",
    "impl_01": "obj MyClass {\n    def my_method() -> str;\n}\n\nimpl MyClass.my_method {\n    return \"Implementation\";\n}",
    "advanced_func_01": "def my_func(*args: any) -> int {\n    return len(args);\n}",
    "advanced_func_02": "def my_func(**kwargs: any) -> int {\n    return len(kwargs);\n}",
    "integration_01": "node Person {\n    has name: str;\n    has age: int;\n}\n\nedge Friendship {\n    has since: int;\n}\n\nwalker SocialTraverser {\n    has visited: set = set();\n\n    can traverse with Person entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            report here.name;\n            visit [-->];\n        }\n    }\n}\n\nwith entry {\n    p1 = Person(name=\"Alice\", age=30);\n    p2 = Person(name=\"Bob\", age=25);\n    p3 = Person(name=\"Charlie\", age=35);\n    p1 +>:Friendship(since=2020):+> p2;\n    p2 +>:Friendship(since=2021):+> p3;\n    root spawn SocialTraverser();\n}",
    "integration_02": "node State {\n    has name: str;\n    has is_final: bool = False;\n}\n\nwalker StateMachine {\n    has current_state: str;\n\n    can transition with State entry {\n        if here.name == self.current_state {\n            report f\"In state: {here.name}\";\n            if not here.is_final {\n                visit [-->];\n            } else {\n                report \"Final state reached\";\n                disengage;\n            }\n        } else {\n            skip;\n        }\n    }\n}\n\nwith entry {\n    s1 = State(name=\"start\");\n    s2 = State(name=\"processing\");\n    s3 = State(name=\"end\", is_final=True);\n    s1 ++> s2;\n    s2 ++> s3;\n    s1 spawn StateMachine(current_state=\"start\");\n}",
    "integration_03": "walker ErrorHandler {\n    has value: int;\n\n    can process with `root entry {\n        try {\n            if self.value == 0 {\n                raise ValueError(\"Value cannot be zero\");\n            }\n            result = 100 / self.value;\n            report result;\n        } except ValueError as e {\n            report f\"Error: {e}\";\n        } except Exception as e {\n            report f\"Unexpected error: {e}\";\n        }\n    }\n}\n\nwith entry {\n    root spawn ErrorHandler(value=0);\n}",
    "integration_04": "async def fetch_data(url: str) -> str {\n    await asyncio.sleep(1);\n    return f\"Data from {url}\";\n}\n\nasync walker AsyncProcessor {\n    has url: str;\n\n    can process with `root entry {\n        result = await fetch_data(self.url);\n        report result;\n    }\n}\n\nwith entry {\n    root spawn AsyncProcessor(url=\"https://example.com\");\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker CRUD {\n    has operation: str;\n    has item_name: str = \"\";\n    has item_value: int = 0;\n    has update_value: int = 0;\n\n    can execute with `root entry {\n        if self.operation == \"create\" {\n            new_item = Item(name=self.item_name, value=self.item_value);\n            here ++> new_item;\n            save(new_item);\n            commit();\n            report f\"Created: {self.item_name}\";\n        } elif self.operation == \"read\" {\n            items = [here-->(`?Item)];\n            for item in items {\n                report f\"{item.name}: {item.value}\";\n            }\n        } elif self.operation == \"update\" {\n            items = [here-->(`?Item)](?name==self.item_name);\n            if items {\n                items[0].value = self.update_value;\n                save(items[0]);\n                commit();\n                report f\"Updated: {self.item_name}\";\n            }\n        } elif self.operation == \"delete\" {\n            items = [here-->(`?Item)](?name==self.item_name);\n            if items {\n                del items[0];\n                commit();\n                report f\"Deleted: {self.item_name}\";\n            }\n        }\n    }\n}\n\nwith entry {\n    root spawn CRUD(operation=\"create\", item_name=\"test\", item_value=100);\n}",
    "integration_06": "node Document {\n    has content: str;\n    has summary: str = \"\";\n}\n\ndef summarize(text: str) -> str by llm();\n\nwalker AISummarizer {\n    has visited: set = set();\n\n    can summarize_docs with Document entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            here.summary = summarize(here.content);\n            report here.summary;\n            visit [-->];\n        }\n    }\n}\n\nwith entry {\n    doc1 = Document(content=\"Long text here\");\n    doc2 = Document(content=\"Another long text\");\n    doc1 ++> doc2;\n    doc1 spawn AISummarizer();\n}",
    "integration_07": "node DataNode {\n    has data: str;\n    has timestamp: int;\n}\n\nwalker APIWalker {\n    has data: str;\n\n    can save_data with `root entry {\n        new_node = DataNode(data=self.data, timestamp=1234567890);\n        here ++> new_node;\n        save(new_node);\n        commit();\n        report {\"status\": \"saved\", \"data\": self.data};\n    }\n}\n\nwith entry {\n    root spawn APIWalker(data=\"test data\");\n}",
    "integration_08": "node GraphNode {\n    has id: int;\n    has visited: bool = False;\n}\n\nwalker BFS {\n    has queue: list = [];\n    has visited: set = set();\n    has start_id: int;\n\n    can search with GraphNode entry {\n        if here.id == self.start_id and not self.queue {\n            self.queue.append(here);\n            self.visited.add(here);\n        }\n        \n        while self.queue {\n            current = self.queue.pop(0);\n            report current.id;\n            neighbors = [current-->(`?GraphNode)];\n            for neighbor in neighbors {\n                if neighbor not in self.visited {\n                    self.visited.add(neighbor);\n                    self.queue.append(neighbor);\n                }\n            }\n        }\n        disengage;\n    }\n}\n\nwith entry {\n    n1 = GraphNode(id=1);\n    n2 = GraphNode(id=2);\n    n3 = GraphNode(id=3);\n    n1 ++> n2;\n    n1 ++> n3;\n    n1 spawn BFS(start_id=1);\n}",
    "integration_09": "node Task {\n    has name: str;\n    has status: str = \"pending\";\n\n    can start with WorkflowWalker entry {\n        here.status = \"running\";\n        report f\"Starting: {here.name}\";\n    }\n\n    can complete with WorkflowWalker exit {\n        here.status = \"completed\";\n        report f\"Completed: {here.name}\";\n    }\n}\n\nwalker WorkflowWalker {\n    has step: int = 0;\n\n    can orchestrate with Task entry {\n        self.step += 1;\n        visit [-->];\n    }\n\n    can finalize with `root exit {\n        report f\"Workflow finished: {self.step} steps\";\n    }\n}\n\nwith entry {\n    t1 = Task(name=\"Step1\");\n    t2 = Task(name=\"Step2\");\n    t3 = Task(name=\"Step3\");\n    root ++> t1;\n    t1 ++> t2;\n    t2 ++> t3;\n    root spawn WorkflowWalker();\n}",
    "integration_10": "node User {\n    has name: str;\n    has interests: list[str];\n}\n\nedge Follows {}\n\nwalker RecommendFriends {\n    has user_name: str;\n    has recommendations: set = set();\n\n    can find_recommendations with User entry {\n        if here.name == self.user_name {\n            friends = [here-->(`?User)];\n            for friend in friends {\n                fof = [friend-->(`?User)];\n                for potential in fof {\n                    if potential.name != self.user_name and potential not in friends {\n                        self.recommendations.add(potential.name);\n                    }\n                }\n            }\n            report list(self.recommendations);\n            disengage;\n        }\n    }\n}\n\nwith entry {\n    u1 = User(name=\"Alice\", interests=[\"music\"]);\n    u2 = User(name=\"Bob\", interests=[\"sports\"]);\n    u3 = User(name=\"Charlie\", interests=[\"music\"]);\n    u1 +>:Follows:+> u2;\n    u2 +>:Follows:+> u3;\n    u1 spawn RecommendFriends(user_name=\"Alice\");\n}",
    "prod_websocket_01": "walker WebSocketWalker {\n    has message: str;\n\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can broadcast with `root entry {\n        socket.notify_channels([\"updates\"], {\"message\": self.message});\n        report {\"status\": \"broadcasted\"};\n    }\n}\n\nwith entry {\n    root spawn WebSocketWalker(message=\"Hello WebSocket\");\n}",
    "prod_permissions_01": "node SecureNode {\n    has owner_id: str;\n    has data: str;\n\n    def __jac_access__() -> int {\n        if visitor.user_id == here.owner_id {\n            return WritePerm;\n        } elif visitor.is_admin {\n            return ReadPerm;\n        } else {\n            return NoPerm;\n        }\n    }\n}\n\nwalker AccessChecker {\n    has user_id: str;\n    has is_admin: bool = False;\n\n    can check with SecureNode entry {\n        report f\"Accessing: {here.data}\";\n    }\n}\n\nwith entry {\n    node1 = SecureNode(owner_id=\"user123\", data=\"secret\");\n    node1 spawn AccessChecker(user_id=\"user123\");\n}",
    "prod_cache_01": "node CachedData {\n    has value: str;\n    has cached_at: int;\n    has ttl: int = 3600;\n}\n\nwalker CacheManager {\n    has current_time: int;\n\n    can check_cache with CachedData entry {\n        age = self.current_time - here.cached_at;\n        if age > here.ttl {\n            here.value = \"regenerated_value\";\n            here.cached_at = self.current_time;\n            report \"Cache refreshed\";\n        } else {\n            report f\"Cache valid: {here.value}\";\n        }\n    }\n}\n\nwith entry {\n    cached = CachedData(value=\"old_value\", cached_at=1000);\n    cached spawn CacheManager(current_time=5000);\n}",
    "prod_validation_01": "walker ValidatingWalker {\n    has email: str;\n    has age: int;\n\n    can validate with `root entry {\n        try {\n            if \"@\" not in self.email {\n                raise ValueError(\"Invalid email format\");\n            }\n            if self.age < 0 or self.age > 150 {\n                raise ValueError(\"Invalid age range\");\n            }\n            report {\"status\": \"valid\", \"email\": self.email, \"age\": self.age};\n        } except ValueError as e {\n            report {\"status\": \"error\", \"message\": str(e)};\n        }\n    }\n}\n\nwith entry {\n    root spawn ValidatingWalker(email=\"invalid\", age=200);\n}",
    "prod_pagination_01": "node Item {\n    has name: str;\n    has category: str;\n}\n\nwalker PaginatedQuery {\n    has page: int = 1;\n    has page_size: int = 10;\n    has filter_category: str = \"\";\n\n    can paginate with `root entry {\n        all_items = [here-->(`?Item)];\n        if self.filter_category {\n            all_items = [item for item in all_items if item.category == self.filter_category];\n        }\n        total = len(all_items);\n        start = (self.page - 1) * self.page_size;\n        end = start + self.page_size;\n        items = all_items[start:end];\n        report {\"total\": total, \"page\": self.page, \"items\": [i.name for i in items]};\n    }\n}\n\nwith entry {\n    root spawn PaginatedQuery(page=1, page_size=5, filter_category=\"books\");\n}",
    "prod_scheduler_01": "walker ScheduledTask {\n    has task_name: str;\n\n    obj __specs__ {\n        static has cron: str = \"0 0 * * *\";\n        static has save: bool = True;\n    }\n\n    can execute with `root entry {\n        report f\"Executing scheduled task: {self.task_name}\";\n    }\n}\n\nwith entry {\n    root spawn ScheduledTask(task_name=\"daily_backup\");\n}",
    "prod_versioning_01": "node Document {\n    has content: str;\n    has version: int = 1;\n}\n\nnode Version {\n    has version_num: int;\n    has content: str;\n    has timestamp: int;\n}\n\nwalker VersionManager {\n    has new_content: str;\n\n    can create_version with Document entry {\n        version_node = Version(version_num=here.version, content=here.content, timestamp=1234567890);\n        here ++> version_node;\n        here.content = self.new_content;\n        here.version += 1;\n        save(here);\n        save(version_node);\n        commit();\n        report f\"Version {here.version} created\";\n    }\n}\n\nwith entry {\n    doc = Document(content=\"original\");\n    doc spawn VersionManager(new_content=\"updated\");\n}",
    "prod_softdelete_01": "node Record {\n    has name: str;\n    has is_deleted: bool = False;\n}\n\nwalker QueryActive {\n    can get_active with `root entry {\n        active_records = [here-->(`?Record)](?is_deleted==False);\n        report [r.name for r in active_records];\n    }\n}\n\nwalker SoftDelete {\n    has record_name: str;\n\n    can mark_deleted with Record entry {\n        if here.name == self.record_name {\n            here.is_deleted = True;\n            save(here);\n            commit();\n            report f\"Soft deleted: {here.name}\";\n        }\n    }\n}\n\nwith entry {\n    rec = Record(name=\"test\");\n    root ++> rec;\n    root spawn SoftDelete(record_name=\"test\");\n}",
    "prod_audit_01": "node AuditLog {\n    has timestamp: int;\n    has user_id: str;\n    has action: str;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    has user_id: str;\n    has action: str;\n    has details: dict;\n\n    can log with `root entry {\n        log_entry = AuditLog(timestamp=1234567890, user_id=self.user_id, action=self.action, details=self.details);\n        here ++> log_entry;\n        save(log_entry);\n        commit();\n        report {\"logged\": True, \"action\": self.action};\n    }\n}\n\nwith entry {\n    root spawn AuditLogger(user_id=\"user123\", action=\"login\", details={\"ip\": \"192.168.1.1\"});\n}",
    "prod_ratelimit_01": "node RateLimit {\n    has user_id: str;\n    has request_count: int = 0;\n    has window_start: int;\n    has max_requests: int = 100;\n    has window_size: int = 3600;\n}\n\nwalker RateLimiter {\n    has user_id: str;\n    has current_time: int;\n\n    can check_limit with `root entry {\n        limits = [here-->(`?RateLimit)](?user_id==self.user_id);\n        if limits {\n            limit = limits[0];\n            if self.current_time - limit.window_start > limit.window_size {\n                limit.request_count = 1;\n                limit.window_start = self.current_time;\n            } else {\n                limit.request_count += 1;\n            }\n            if limit.request_count > limit.max_requests {\n                raise Exception(\"Rate limit exceeded\");\n            }\n            report {\"allowed\": True, \"remaining\": limit.max_requests - limit.request_count};\n        }\n    }\n}\n\nwith entry {\n    root spawn RateLimiter(user_id=\"user123\", current_time=1234567890);\n}",
    "advanced_ai_stream_01": "def generate_story(prompt: str) -> str by llm(stream=True);\n\nwalker StreamingWalker {\n    has prompt: str;\n\n    can stream with `root entry {\n        for token in generate_story(self.prompt) {\n            print(token, end=\"\");\n        }\n        report \"Streaming complete\";\n    }\n}\n\nwith entry {\n    root spawn StreamingWalker(prompt=\"Tell me a story\");\n}",
    "advanced_ai_multimodal_01": "import from byllm {Image};\n\ndef analyze_image(img: Image) -> str by llm();\n\nwalker ImageAnalyzer {\n    has image_path: str;\n\n    can analyze with `root entry {\n        img = Image(self.image_path);\n        result = analyze_image(img);\n        report result;\n    }\n}\n\nwith entry {\n    root spawn ImageAnalyzer(image_path=\"photo.jpg\");\n}",
    "advanced_ai_react_01": "def search_web(query: str) -> str {\n    return f\"Results for {query}\";\n}\n\ndef calculate(expr: str) -> float {\n    return 42.0;\n}\n\ndef solve_problem(question: str) -> str by llm(method='ReAct', tools=[search_web, calculate]);\n\nwalker ReActWalker {\n    has question: str;\n\n    can solve with `root entry {\n        answer = solve_problem(self.question);\n        report answer;\n    }\n}\n\nwith entry {\n    root spawn ReActWalker(question=\"What is 2+2?\");\n}",
    "advanced_ai_structured_01": "obj PersonInfo {\n    has name: str;\n    has age: int;\n    has occupation: str;\n}\n\ndef extract_person_info(text: str) -> PersonInfo by llm();\n\nwalker StructuredExtractor {\n    has text: str;\n\n    can extract with `root entry {\n        info = extract_person_info(self.text);\n        report {\"name\": info.name, \"age\": info.age, \"occupation\": info.occupation};\n    }\n}\n\nwith entry {\n    root spawn StructuredExtractor(text=\"John is 30 years old and works as an engineer\");\n}",
    "advanced_graph_complex_filter_01": "node Person {\n    has name: str;\n    has age: int;\n}\n\nedge Knows {\n    has since: int;\n}\n\nwalker ComplexQuery {\n    can query with `root entry {\n        results = [here->:Knows:since>2020:->(`?Person)](?age>25);\n        report [p.name for p in results];\n    }\n}\n\nwith entry {\n    p1 = Person(name=\"Alice\", age=30);\n    p2 = Person(name=\"Bob\", age=20);\n    root +>:Knows(since=2021):+> p1;\n    root +>:Knows(since=2019):+> p2;\n    root spawn ComplexQuery();\n}",
    "advanced_graph_pathfind_01": "node GraphNode {\n    has id: int;\n}\n\nedge WeightedEdge {\n    has weight: int;\n}\n\nwalker ShortestPath {\n    has start_id: int;\n    has end_id: int;\n    has distances: dict = {};\n    has unvisited: set = set();\n\n    can find_path with GraphNode entry {\n        if here.id == self.start_id {\n            self.distances[here] = 0;\n            self.unvisited.add(here);\n            while self.unvisited {\n                current = min(self.unvisited, key=lambda n: self.distances.get(n, float('inf')));\n                self.unvisited.remove(current);\n                if current.id == self.end_id {\n                    report self.distances[current];\n                    disengage;\n                }\n                edges = [current--->];\n                for edge in edges {\n                    neighbor = [current->:WeightedEdge:->][0];\n                    new_dist = self.distances[current] + edge.weight;\n                    if neighbor not in self.distances or new_dist < self.distances[neighbor] {\n                        self.distances[neighbor] = new_dist;\n                        self.unvisited.add(neighbor);\n                    }\n                }\n            }\n        }\n    }\n}\n\nwith entry {\n    n1 = GraphNode(id=1);\n    n2 = GraphNode(id=2);\n    n1 +>:WeightedEdge(weight=5):+> n2;\n    n1 spawn ShortestPath(start_id=1, end_id=2);\n}",
    "advanced_graph_cycle_01": "node GraphNode {\n    has id: int;\n}\n\nwalker CycleDetector {\n    has visited: set = set();\n    has rec_stack: set = set();\n    has cycle_found: bool = False;\n\n    can detect with GraphNode entry {\n        if here in self.rec_stack {\n            self.cycle_found = True;\n            report f\"Cycle detected at node {here.id}\";\n            disengage;\n        }\n        if here not in self.visited {\n            self.visited.add(here);\n            self.rec_stack.add(here);\n            visit [-->];\n            self.rec_stack.remove(here);\n        }\n    }\n}\n\nwith entry {\n    n1 = GraphNode(id=1);\n    n2 = GraphNode(id=2);\n    n1 ++> n2;\n    n2 ++> n1;\n    n1 spawn CycleDetector();\n}",
    "advanced_persist_transaction_01": "node DataNode {\n    has value: str;\n}\n\nwalker BatchSaver {\n    has items: list[str];\n\n    can save_batch with `root entry {\n        for item in self.items {\n            node = DataNode(value=item);\n            here ++> node;\n            save(node);\n        }\n        commit();\n        report f\"Saved {len(self.items)} items\";\n    }\n}\n\nwith entry {\n    root spawn BatchSaver(items=[\"item1\", \"item2\", \"item3\"]);\n}",
    "advanced_persist_reference_01": "node StoredNode {\n    has data: str;\n}\n\nwalker ReferenceManager {\n    has operation: str;\n    has node_id: str = \"\";\n\n    can manage with `root entry {\n        if self.operation == \"store\" {\n            node = StoredNode(data=\"test data\");\n            here ++> node;\n            save(node);\n            commit();\n            node_ref = f\"n::{node.__jac__.id}\";\n            report {\"stored_id\": node_ref};\n        } elif self.operation == \"retrieve\" {\n            retrieved = &self.node_id;\n            report {\"data\": retrieved.data};\n        }\n    }\n}\n\nwith entry {\n    root spawn ReferenceManager(operation=\"store\");\n}",
    "advanced_cloud_webhook_01": "walker WebhookReceiver {\n    has payload: dict;\n\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has auth: bool = True;\n    }\n\n    can process with `root entry {\n        if \"Authorization\" in visitor.headers {\n            report {\"status\": \"authenticated\", \"payload\": self.payload};\n        } else {\n            report {\"status\": \"unauthorized\"};\n        }\n    }\n}\n\nwith entry {\n    root spawn WebhookReceiver(payload={\"event\": \"test\"});\n}",
    "advanced_cloud_async_retrieve_01": "async walker LongRunningTask {\n    has duration: int;\n\n    can execute with `root entry {\n        await asyncio.sleep(self.duration);\n        report {\"completed\": True};\n    }\n}\n\nwalker TaskManager {\n    can manage with `root entry {\n        result = spawn LongRunningTask(duration=5);\n        task_id = result;\n        task = &task_id;\n        status = task.__jac__.status;\n        report {\"task_id\": task_id, \"status\": status};\n    }\n}\n\nwith entry {\n    root spawn TaskManager();\n}",
    "advanced_cloud_query_params_01": "walker QueryParamWalker {\n    has search: str;\n    has limit: int;\n    has offset: int;\n\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has as_query: list = [\"search\", \"limit\", \"offset\"];\n    }\n\n    can process with `root entry {\n        report {\"search\": self.search, \"limit\": self.limit, \"offset\": self.offset};\n    }\n}\n\nwith entry {\n    root spawn QueryParamWalker(search=\"test\", limit=10, offset=0);\n}",
    "integration_error_handling_01": "walker SafeProcessor {\n    has value: int;\n\n    can process with `root entry {\n        try {\n            result = 100 / self.value;\n            report {\"result\": result};\n        } except ZeroDivisionError as e {\n            print(f\"Error logged: {e}\");\n            report {\"result\": 0, \"error\": \"division by zero\"};\n        }\n    }\n}\n\nwith entry {\n    root spawn SafeProcessor(value=0);\n}",
    "integration_external_api_01": "import:py requests;\n\nwalker APIFetcher {\n    has url: str;\n\n    can fetch with `root entry {\n        try {\n            response = requests.get(self.url);\n            report {\"status\": response.status_code, \"data\": response.text};\n        } except Exception as e {\n            report {\"error\": str(e)};\n        }\n    }\n}\n\nwith entry {\n    root spawn APIFetcher(url=\"https://api.example.com/data\");\n}",
    "integration_conditional_visit_01": "node DataNode {\n    has value: int;\n}\n\nwalker ConditionalTraverser {\n    can traverse with `root entry {\n        visit [-->(`?DataNode)] else {\n            report \"No nodes to visit\";\n            disengage;\n        }\n    }\n\n    can process with DataNode entry {\n        report here.value;\n    }\n}\n\nwith entry {\n    root spawn ConditionalTraverser();\n}",
    "integration_multi_ability_01": "node ProcessNode {\n    has value: int;\n\n    can on_entry with ProcessWalker entry {\n        report f\"Entering node with value: {here.value}\";\n    }\n\n    can on_exit with ProcessWalker exit {\n        report f\"Exiting node with value: {here.value}\";\n    }\n}\n\nwalker ProcessWalker {\n    can traverse with ProcessNode entry {\n        visit [-->];\n    }\n}\n\nwith entry {\n    node = ProcessNode(value=42);\n    node spawn ProcessWalker();\n}",
    "integration_batch_process_01": "node Item {\n    has name: str;\n    has processed: bool = False;\n}\n\nwalker BatchProcessor {\n    has items: list[str];\n\n    can process with `root entry {\n        for item_name in self.items {\n            item = Item(name=item_name, processed=True);\n            here ++> item;\n            save(item);\n        }\n        commit();\n        report f\"Processed {len(self.items)} items\";\n    }\n}\n\nwith entry {\n    root spawn BatchProcessor(items=[\"a\", \"b\", \"c\"]);\n}",
    "integration_visitor_communication_01": "node MessageNode {\n    has message: str;\n\n    can modify_visitor with MessageWalker entry {\n        visitor.collected_messages.append(here.message);\n    }\n}\n\nwalker MessageWalker {\n    has collected_messages: list = [];\n\n    can traverse with MessageNode entry {\n        visit [-->];\n    }\n\n    can finalize with `root exit {\n        report self.collected_messages;\n    }\n}\n\nwith entry {\n    n1 = MessageNode(message=\"Hello\");\n    n2 = MessageNode(message=\"World\");\n    root ++> n1;\n    n1 ++> n2;\n    root spawn MessageWalker();\n}",
    "integration_root_ability_01": "walker RootSpecificWalker {\n    has initialized: bool = False;\n\n    can init with `root entry {\n        self.initialized = True;\n        report \"Initialized at root\";\n        visit [-->];\n    }\n\n    can process with node entry {\n        report f\"Processing node, initialized: {self.initialized}\";\n    }\n}\n\nwith entry {\n    root spawn RootSpecificWalker();\n}",
    "integration_edge_traversal_01": "node GraphNode {\n    has id: int;\n}\n\nedge LabeledEdge {\n    has label: str;\n}\n\nwalker EdgeInspector {\n    can inspect with GraphNode entry {\n        edges = [here--->];\n        for edge in edges {\n            report f\"Edge label: {edge.label}\";\n        }\n    }\n}\n\nwith entry {\n    n1 = GraphNode(id=1);\n    n2 = GraphNode(id=2);\n    n1 +>:LabeledEdge(label=\"connects_to\"):+> n2;\n    n1 spawn EdgeInspector();\n}"
  }
}