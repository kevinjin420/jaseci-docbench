{
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n}",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i=1 to i<=5 by i+=1 {\n        print(i);\n    }\n}",
    "basic_06": "#* This is a\nmulti-line comment *#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    message: str = f\"Hello, {name}!\";\n}",
    "basic_08": "with entry {\n    value: str | int = \"hello\";\n}",
    "basic_09": "with entry {\n    squares: list = [i * i for i in range(1, 6)];\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"positive\");\n    } elif num < 0 {\n        print(\"negative\");\n    } else {\n        print(\"zero\");\n    }\n}",
    "control_01": "with entry {\n    count: int = 1;\n    while count <= 5 {\n        print(count);\n        count += 1;\n    }\n}",
    "control_02": "with entry {\n    value: int = 2;\n    match value {\n        case 1: print(\"one\");\n        case 2: print(\"two\");\n        case _: print(\"other\");\n    }\n}",
    "control_03": "with entry {\n    for i=1 to i<=10 by i+=1 {\n        if i == 5 {\n            break;\n        }\n        print(i);\n    }\n}",
    "control_04": "with entry {\n    for i=1 to i<=10 by i+=1 {\n        if i % 2 == 0 {\n            continue;\n        }\n        print(i);\n    }\n}",
    "collection_01": "with entry {\n    numbers: set[int] = {1, 2, 3};\n    numbers.add(4);\n}",
    "collection_02": "with entry {\n    person: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares: dict = {i: i*i for i in range(1, 6)};\n}",
    "collection_04": "with entry {\n    names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n    for name in names {\n        print(name);\n    }\n}",
    "collection_05": "with entry {\n    scores: dict[str, int] = {\"Alice\": 90, \"Bob\": 85};\n    alice_score: int | None = scores.get(\"Alice\");\n}",
    "type_01": "with entry {\n    value: str = \"hello\";\n    if isinstance(value, str) {\n        print(\"It's a string\");\n    }\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n\n    def get_info() -> str {\n        return f\"{self.brand} ({self.year})\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    has value: int;\n\n    def postinit() {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square: callable = lambda x: int: return x * x;\n}",
    "obj_06": "obj SecureData {\n    has :priv: secret: str;\n}",
    "obj_07": "obj PublicData {\n    has :pub: info: str;\n}",
    "obj_08": "def my_decorator(func: callable) -> callable {\n    return func;\n}\n\n@my_decorator\ndef my_function() -> str {\n    return \"decorated\";\n}",
    "obj_09": "def execute_callback(callback: callable) -> any {\n    return callback();\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n}\n\nwith entry {\n    city1: City = City(name=\"NYC\");\n    city2: City = City(name=\"LA\");\n    city1 <++> city2;\n}",
    "graph_03": "edge Road {\n    has distance: float;\n}\n\nnode City {\n    has name: str;\n}\n\nwith entry {\n    city1: City = City(name=\"NYC\");\n    city2: City = City(name=\"LA\");\n    city1 +>:Road(distance=100.5):+> city2;\n}",
    "graph_04": "node MyNode {\n    has value: int;\n\n    can process with entry {\n        print(\"Node entered\");\n    }\n}",
    "graph_05": "walker MyWalker {\n    has data: str;\n}\n\nnode MyNode {\n    can greet with MyWalker entry {\n        print(visitor.data);\n    }\n}",
    "graph_06": "node Start {\n    has name: str;\n}\n\nnode End {\n    has name: str;\n}\n\nwith entry {\n    start: Start = Start(name=\"A\");\n    end: End = End(name=\"B\");\n    start ++> end;\n}",
    "graph_07": "node MyNode {\n    has value: int;\n}\n\nwith entry {\n    n: MyNode = MyNode(value=42);\n    root ++> n;\n}",
    "graph_08": "node MyNode {\n    has value: int;\n\n    can cleanup with exit {\n        print(\"Node exited\");\n    }\n}",
    "graph_09": "edge MyEdge {\n    has weight: int;\n\n    can log_cross with entry {\n        print(\"Edge crossed\");\n    }\n}",
    "graph_10": "node A {\n    has name: str;\n}\n\nwith entry {\n    n1: A = A(name=\"1\");\n    n2: A = A(name=\"2\");\n    n3: A = A(name=\"3\");\n    n1 ++> n2 ++> n3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker Navigator {\n    can explore {\n        visit [-->];\n    }\n}",
    "walker_03": "node Person {\n    has name: str;\n}\n\nwalker FindPerson {\n    can search {\n        visit [-->(`?Person)];\n    }\n}",
    "walker_04": "walker Logger {\n    can log with entry {\n        print(here);\n    }\n}",
    "walker_05": "walker DataCollector {\n    can collect {\n        report \"collected data\";\n    }\n}",
    "walker_06": "walker MyWalker {\n    has data: str;\n}\n\nnode MyNode {\n    has value: int;\n}\n\nwith entry {\n    n: MyNode = MyNode(value=42);\n    w: MyWalker = MyWalker(data=\"test\");\n    n spawn w;\n}",
    "walker_07": "walker InitWalker {\n    has name: str;\n}\n\nwith entry {\n    w: InitWalker = InitWalker(name=\"init\");\n    root spawn w;\n}",
    "walker_08": "walker BackTracker {\n    can go_back {\n        visit [<--];\n    }\n}",
    "walker_09": "walker LifecycleWalker {\n    can setup with entry {\n        print(\"Walker starting\");\n    }\n\n    can teardown with exit {\n        print(\"Walker ending\");\n    }\n}",
    "walker_10": "walker NodeReporter {\n    can report_location {\n        report here;\n    }\n}",
    "advanced_01": "node Person {\n    has name: str;\n    has age: int;\n}\n\nwalker FindAdults {\n    can search {\n        visit [-->(`?Person)](?age >= 18);\n    }\n}",
    "advanced_02": "edge Follow {\n    has since: int;\n}\n\nwalker FollowWalker {\n    can traverse {\n        visit [->:Follow:->];\n    }\n}",
    "advanced_03": "walker DeepTraverser {\n    can go_deep {\n        visit [-->-->-->];\n    }\n}",
    "advanced_04": "walker ConditionalWalker {\n    has should_stop: bool = False;\n\n    can check_and_stop {\n        if self.should_stop {\n            disengage;\n        }\n    }\n}",
    "advanced_05": "edge Connection {\n    has weight: float;\n\n    can log with entry {\n        print(\"Crossing edge\");\n    }\n}",
    "advanced_06": "walker DFSWalker {\n    can traverse {\n        visit :0: [-->];\n    }\n}",
    "advanced_07": "walker MultiVisitor {\n    can visit_multiple(nodes: list) {\n        visit nodes;\n    }\n}",
    "advanced_08": "node Person {\n    has name: str;\n    has age: int;\n}\n\nwalker FilterWalker {\n    can filter_visit {\n        visit [-->(`?Person: age > 18)];\n    }\n}",
    "advanced_09": "edge Weighted {\n    has weight: int;\n}\n\nwalker EdgeFilter {\n    can filter_edges {\n        visit [->:Weighted: weight > 5:->];\n    }\n}",
    "advanced_10": "node A {\n    has value: int;\n}\n\nwith entry {\n    n1: A = A(value=1);\n    n2: A = A(value=2);\n    n1 ++> n2;\n    del n1 --> n2;\n}",
    "ai_01": "import from byllm {Model};",
    "ai_02": "import from byllm {Model};\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "def generate_greeting(name: str) -> str by llm();",
    "ai_04": "obj Person {\n    has name: str;\n    has age: int = sem(\"Age in years\");\n}",
    "ai_05": "enum Sentiment {\n    POSITIVE,\n    NEGATIVE,\n    NEUTRAL\n}\n\ndef analyze_sentiment(text: str) -> Sentiment by llm();",
    "ai_06": "def solve_problem(question: str) -> str by llm(method='Reason');",
    "ai_07": "def process_with_tools(query: str) -> str by llm(tools=[]);",
    "ai_08": "import from byllm {Image};",
    "ai_09": "obj Assistant {\n    has context: str;\n\n    def respond(question: str) -> str by llm();\n}",
    "ai_10": "obj Response {\n    has answer: str;\n    has confidence: float;\n}\n\ndef get_structured_answer(query: str) -> Response by llm();",
    "cloud_01": "walker APIWalker {\n    obj __specs__ {\n        static has methods: list = [\"get\", \"post\"];\n    }\n}",
    "cloud_02": "walker PublicWalker {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n}",
    "cloud_03": "walker CustomEndpoint {\n    obj __specs__ {\n        static has path: str = \"/api/custom\";\n    }\n}",
    "cloud_04": "walker QueryWalker {\n    has param1: str;\n    has param2: int;\n\n    obj __specs__ {\n        static has as_query: list = [\"*\"];\n    }\n}",
    "cloud_05": "walker PrivateWalker {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n}",
    "cloud_06": "async walker BackgroundTask {\n    has job_id: str;\n}",
    "cloud_07": "with entry {\n    task_id: str = \"task123\";\n    task_ref = &task_id;\n}",
    "cloud_08": "walker WebhookHandler {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n    }\n}",
    "cloud_09": "node DataNode {\n    has data: str;\n}\n\nwith entry {\n    n: DataNode = DataNode(data=\"persistent\");\n    root ++> n;\n}",
    "cloud_10": "walker TypedResponse {\n    has result: str;\n\n    def process() -> str {\n        return self.result;\n    }\n}",
    "import_01": "import json;",
    "import_02": "import from datetime {datetime, timedelta};",
    "import_03": "include \"other_module.jac\";",
    "import_04": "import numpy as np;",
    "file_01": "with entry {\n    with open(\"file.txt\", \"r\") as f {\n        content: str = f.read();\n    }\n}",
    "file_02": "with entry {\n    f = open(\"output.txt\", \"w\");\n    f.write(\"Hello, World!\");\n    f.close();\n}",
    "file_03": "import json;\n\nwith entry {\n    with open(\"data.json\", \"r\") as f {\n        data: dict = json.load(f);\n    }\n}",
    "impl_01": "obj Calculator {\n    has value: int;\n\n    def add(n: int) -> int;\n}\n\nimpl Calculator.add {\n    return self.value + n;\n}",
    "advanced_func_01": "def sum_all(*args: int) -> int {\n    total: int = 0;\n    for arg in args {\n        total += arg;\n    }\n    return total;\n}",
    "advanced_func_02": "def configure(**kwargs: any) -> dict {\n    return kwargs;\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since: int;\n}\n\nwalker SocialExplorer {\n    can explore {\n        visit [-->];\n    }\n}\n\nwith entry {\n    p1: Person = Person(name=\"Alice\");\n    p2: Person = Person(name=\"Bob\");\n    p1 +>:Friendship(since=2020):+> p2;\n    p1 spawn SocialExplorer();\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nwalker StateMachine {\n    has current_state: str;\n\n    can transition {\n        if self.current_state == \"start\" {\n            visit [-->];\n        }\n    }\n}",
    "integration_03": "walker SafeWalker {\n    can process {\n        try {\n            result: int = 10 / 0;\n        } except Exception as e {\n            print(f\"Error: {e}\");\n        }\n    }\n}",
    "integration_04": "async def fetch_data(url: str) -> dict {\n    import requests;\n    response = await requests.get(url);\n    return response.json();\n}",
    "integration_05": "walker CRUDWalker {\n    has operation: str;\n\n    def create(data: dict) {\n        node: any = data;\n        save(node);\n        root ++> node;\n    }\n}",
    "integration_06": "import from byllm {Model};\n\nwalker AIGraphWalker {\n    def analyze(text: str) -> str by llm();\n\n    can traverse {\n        visit [-->];\n    }\n}",
    "integration_07": "walker PersistentAPI {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n    }\n\n    can save_data {\n        node: any = {};\n        root ++> node;\n    }\n}",
    "integration_08": "walker BFSWalker {\n    has visited: set = set();\n    has queue: list = [];\n\n    can traverse {\n        visit [-->];\n    }\n}",
    "integration_09": "node Task {\n    has name: str;\n\n    can execute with MyWalker entry {\n        print(f\"Executing {self.name} for {visitor.name}\");\n    }\n}\n\nwalker MyWalker {\n    has name: str;\n\n    can run {\n        visit [-->];\n    }\n}",
    "integration_10": "node User {\n    has name: str;\n}\n\nnode Item {\n    has title: str;\n}\n\nwalker RecommendationEngine {\n    can recommend {\n        visit [-->-->(`?Item)];\n    }\n}",
    "prod_websocket_01": "import from jaclang.jac.jac_cloud_sdk {WEBSOCKET_MANAGER};\n\nwalker WebSocketWalker {\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can broadcast(channel: str, message: str) {\n        socket: any = WEBSOCKET_MANAGER;\n        socket.notify_channels([channel], message);\n    }\n}",
    "prod_permissions_01": "import from jaclang.jac.jac_cloud_sdk {WritePerm, ReadPerm, NoPerm};\n\nnode SecureNode {\n    has owner_id: str;\n\n    def __jac_access__(user_id: str) -> any {\n        if user_id == self.owner_id {\n            return WritePerm;\n        } else {\n            return ReadPerm;\n        }\n    }\n}",
    "prod_cache_01": "import time;\n\nnode Cache {\n    has value: any;\n    has expires: float;\n}\n\nwalker CacheWalker {\n    can get_cached() {\n        cache: Cache = Cache(value=None, expires=0.0);\n        if time.time() > cache.expires {\n            cache.value = \"regenerated\";\n            cache.expires = time.time() + 3600;\n        }\n    }\n}",
    "prod_validation_01": "walker ValidationWalker {\n    has email: str;\n\n    can validate() {\n        if not \"@\" in self.email {\n            raise ValueError(\"Invalid email\");\n        }\n    }\n}",
    "prod_pagination_01": "walker PaginatedQuery {\n    has page: int = 1;\n    has per_page: int = 10;\n\n    can get_page() {\n        items: list = [-->](?True);\n        total: int = len(items);\n        start: int = (self.page - 1) * self.per_page;\n        end: int = start + self.per_page;\n        result: list = items[start:end];\n    }\n}",
    "prod_scheduler_01": "walker ScheduledTask {\n    obj __specs__ {\n        static has schedule: dict = {\n            \"trigger\": \"cron\",\n            \"hour\": 0,\n            \"save\": True\n        };\n    }\n}",
    "prod_versioning_01": "node Document {\n    has title: str;\n    has content: str;\n}\n\nnode DocumentVersion {\n    has version: int;\n    has content: str;\n}\n\nwith entry {\n    doc: Document = Document(title=\"Doc\", content=\"v1\");\n    ver: DocumentVersion = DocumentVersion(version=1, content=\"v1\");\n    doc ++> ver;\n}",
    "prod_softdelete_01": "node Item {\n    has name: str;\n    has is_deleted: bool = False;\n}\n\nwalker QueryActive {\n    can get_active() {\n        visit [-->(`?Item)](?not is_deleted);\n    }\n}",
    "prod_audit_01": "import time;\n\nnode AuditLog {\n    has timestamp: float;\n    has user_id: str;\n    has action: str;\n}\n\nwalker AuditWalker {\n    has user: str;\n\n    can log_action(action: str) {\n        log: AuditLog = AuditLog(\n            timestamp=time.time(),\n            user_id=self.user,\n            action=action\n        );\n        root ++> log;\n    }\n}",
    "prod_ratelimit_01": "import time;\n\nnode RateLimit {\n    has count: int;\n    has window_start: float;\n    has max_requests: int = 100;\n\n    def check() {\n        if self.count > self.max_requests {\n            raise Exception(\"Rate limit exceeded\");\n        }\n    }\n}",
    "advanced_ai_stream_01": "def stream_response(prompt: str) -> str by llm(stream=True);\n\nwith entry {\n    for token in stream_response(\"Hello\") {\n        print(token);\n    }\n}",
    "advanced_ai_multimodal_01": "import from byllm {Model, Image};\n\ndef analyze_image(img: Image) -> str by llm();\n\nwalker ImageAnalyzer {\n    can process(path: str) {\n        img: Image = Image(path);\n        result: str = analyze_image(img);\n    }\n}",
    "advanced_ai_react_01": "def solve_with_tools(question: str) -> str by llm(\n    method='ReAct',\n    tools=[]\n);",
    "advanced_ai_structured_01": "obj ExtractedData {\n    has title: str;\n    has summary: str;\n}\n\ndef extract_info(text: str) -> ExtractedData by llm();",
    "advanced_graph_complex_filter_01": "node Person {\n    has name: str;\n    has age: int;\n}\n\nedge Connection {\n    has strength: int;\n}\n\nwalker ComplexFilter {\n    can filter_traverse {\n        visit [->:Connection:->(`?Person)](?age > 25);\n    }\n}",
    "advanced_graph_pathfind_01": "walker ShortestPath {\n    has distances: dict = {};\n    has unvisited: set = set();\n\n    can find_path {\n        if len(self.unvisited) == 0 {\n            disengage;\n        }\n        visit [-->];\n    }\n}",
    "advanced_graph_cycle_01": "walker CycleDetector {\n    has visited: set = set();\n\n    can detect {\n        if here in self.visited {\n            report \"Cycle detected\";\n        }\n    }\n}",
    "advanced_persist_transaction_01": "with entry {\n    obj1: any = {};\n    obj2: any = {};\n    save(obj1);\n    save(obj2);\n    commit();\n}",
    "advanced_persist_reference_01": "node MyNode {\n    has value: int;\n}\n\nwith entry {\n    n: MyNode = MyNode(value=42);\n    node_id: str = str(n.id);\n    retrieved = &node_id;\n}",
    "advanced_cloud_webhook_01": "walker WebhookReceiver {\n    obj __specs__ {\n        static has webhook: dict = {\n            \"type\": \"header\",\n            \"name\": \"X-API-Key\"\n        };\n    }\n}",
    "advanced_cloud_async_retrieve_01": "async walker LongTask {\n    has data: str;\n}\n\nwith entry {\n    task_result = spawn LongTask(data=\"test\");\n    task_id: str = task_result;\n    task_ref = &task_id;\n    status: str = task_ref.__jac__.status;\n}",
    "advanced_cloud_query_params_01": "walker SelectiveQuery {\n    has filter: str;\n    has limit: int;\n\n    obj __specs__ {\n        static has as_query: list = [\"filter\", \"limit\"];\n    }\n}",
    "integration_error_handling_01": "walker RobustWalker {\n    can handle_errors {\n        try {\n            result: int = 10 / 0;\n        } except ZeroDivisionError as e {\n            print(f\"Caught error: {e}\");\n            report \"fallback\";\n        }\n    }\n}",
    "integration_external_api_01": "import requests;\n\nwalker APIFetcher {\n    can fetch(url: str) {\n        try {\n            response = requests.get(url);\n            data: dict = response.json();\n        } except Exception as e {\n            print(f\"Error: {e}\");\n        }\n    }\n}",
    "integration_conditional_visit_01": "walker ConditionalNavigator {\n    can navigate {\n        visit [-->] else {\n            disengage;\n        }\n    }\n}",
    "integration_multi_ability_01": "walker TestWalker {\n    has name: str;\n}\n\nnode DualAbility {\n    can on_enter with TestWalker entry {\n        print(\"Entering\");\n    }\n\n    can on_exit with TestWalker exit {\n        print(\"Exiting\");\n    }\n}",
    "integration_batch_process_01": "walker BatchProcessor {\n    can process(items: list) {\n        for item in items {\n            node: any = item;\n            save(node);\n        }\n        commit();\n    }\n}",
    "integration_visitor_communication_01": "walker StateWalker {\n    has counter: int = 0;\n}\n\nnode Counter {\n    can increment with StateWalker entry {\n        visitor.counter += 1;\n    }\n}",
    "integration_root_ability_01": "walker RootSpecific {\n    can initialize with `root entry {\n        print(\"Starting at root\");\n    }\n}",
    "integration_edge_traversal_01": "walker EdgeInspector {\n    can inspect_edges {\n        edges: list = [here --->];\n        for edge in edges {\n            print(edge);\n        }\n    }\n}"
}