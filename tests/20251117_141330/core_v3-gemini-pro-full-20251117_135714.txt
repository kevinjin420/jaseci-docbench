{
  "metadata": {
    "model": "gemini/gemini-2.5-pro-preview-03-25",
    "model_alias": "gemini-pro",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    };\n}",
    "basic_06": "#* \nThis is a multi-line comment.\n*#",
    "basic_07": "with entry {\n    name: str = \"World\";\n    greeting: str = f\"Hello, {name}!\";\n    print(greeting);\n}",
    "basic_08": "with entry {\n    my_var: str | int = \"a string value\";\n}",
    "basic_09": "with entry {\n    squares: list[int] = [x * x for x in range(1, 6)];\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"Positive\");\n    } elif num < 0 {\n        print(\"Negative\");\n    } else {\n        print(\"Zero\");\n    };\n}",
    "control_01": "with entry {\n    count: int = 1;\n    while count <= 5 {\n        print(count);\n        count += 1;\n    };\n}",
    "control_02": "with entry {\n    value: str = \"case2\";\n    match value {\n        case \"case1\":\n            print(\"First case\");\n        case \"case2\":\n            print(\"Second case\");\n        case _:\n            print(\"Default case\");\n    };\n}",
    "control_03": "with entry {\n    for i in range(10) {\n        if i == 5 {\n            break;\n        };\n        print(i);\n    };\n}",
    "control_04": "with entry {\n    for i in range(1, 11) {\n        if i % 2 == 0 {\n            continue;\n        };\n        print(i);\n    };\n}",
    "collection_01": "with entry {\n    numbers: set[int] = {1, 2, 3};\n    numbers.add(4);\n    numbers.add(1);\n}",
    "collection_02": "with entry {\n    person_data: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares_map: dict[int, int] = {i: i*i for i in range(1, 6)};\n}",
    "collection_04": "with entry {\n    items: list[str] = [\"apple\", \"banana\", \"cherry\"];\n    for item in items {\n        print(item);\n    };\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n    alice_age: int|None = ages.get(\"Alice\");\n}",
    "type_01": "with entry {\n    value: any = \"I am a string\";\n    if isinstance(value, str) {\n        print(\"The value is a string.\");\n    };\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n\n    def get_info(self) -> str {\n        return f\"{self.year} {self.brand}\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj InitializedObject {\n    has id: int;\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "square = lambda x: int: x * x;",
    "obj_06": "obj SecretContainer {\n    has _secret_value: str;\n}",
    "obj_07": "obj PublicContainer {\n    has public_value: str;\n}",
    "obj_08": "def simple_decorator(func: callable) -> callable {\n    def wrapper() {\n        print(\"Something is happening before the function is called.\");\n        func();\n        print(\"Something is happening after the function is called.\");\n    };\n    return wrapper;\n}\n\n@simple_decorator\ndef say_whee() {\n    print(\"Whee!\");\n}",
    "obj_09": "def apply_func(func: callable[[int], int], value: int) -> int {\n    return func(value);\n}",
    "obj_10": "def create_greeting(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n}\n\nwith entry {\n    city1: City = City(name=\"San Francisco\");\n    city2: City = City(name=\"Los Angeles\");\n    city1 <++> city2;\n}",
    "graph_03": "node City {\n    has name: str;\n}\n\nedge Road {\n    has distance: float;\n}\n\nwith entry {\n    city1: City = City(name=\"New York\");\n    city2: City = City(name=\"Boston\");\n    city1 +>:Road:distance=215.0:+> city2;\n}",
    "graph_04": "walker MyWalker {};\n\nnode Location {\n    has name: str;\n    can enter with MyWalker entry {\n        print(f\"Walker has entered {here.name}\");\n    }\n}",
    "graph_05": "walker LoggerWalker {\n    has log: list[str] = [];\n}\n\nnode DataPoint {\n    has data: str;\n    can log_data with LoggerWalker entry {\n        visitor.log.append(here.data);\n    }\n}",
    "graph_06": "node Point {};\n\nwith entry {\n    p1: Point = Point();\n    p2: Point = Point();\n    p1 ++> p2;\n}",
    "graph_07": "node User {\n    has name: str;\n}\n\nwith entry {\n    new_user: User = User(name=\"Alice\");\n    root ++> new_user;\n}",
    "graph_08": "walker MyWalker {};\n\nnode Gate {\n    has id: int;\n    can leave with MyWalker exit {\n        print(f\"Walker is leaving gate {here.id}\");\n    }\n}",
    "graph_09": "walker Traveler {};\nnode City {};\n\nedge Highway {\n    has speed_limit: int;\n    can travel with Traveler entry {\n        print(f\"Crossing highway with speed limit: {self.speed_limit}\");\n    }\n}",
    "graph_10": "node Step {};\n\nwith entry {\n    start: Step = Step();\n    middle: Step = Step();\n    end: Step = Step();\n    start ++> middle ++> end;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker SimpleCrawler {\n    can crawl with entry {\n        visit [here -->];\n    }\n}",
    "walker_03": "node User {};\nnode Post {};\n\nwalker PostFinder {\n    can find_posts with User entry {\n        visit [here --> (`?Post)];\n    }\n}",
    "walker_04": "walker Inspector {\n    can inspect with entry {\n        print(f\"Currently at node: {here}\");\n    }\n}",
    "walker_05": "node DataNode {\n    has data: any;\n}\n\nwalker DataFetcher {\n    can fetch with DataNode entry {\n        report here.data;\n    }\n}",
    "walker_06": "node MyNode {};\nwalker MyWalker {};\nwith entry {\n    n = MyNode();\n    n spawn MyWalker();\n}",
    "walker_07": "walker MyWalker {};\nwith entry {\n    root spawn MyWalker();\n}",
    "walker_08": "walker PredecessorVisitor {\n    can visit_preds with entry {\n        visit [<-- here];\n    }\n}",
    "walker_09": "walker ExitingWalker {\n    has log: list[str] = [];\n    can on_exit with exit {\n        visitor.log.append(f\"Exiting {here.id}\");\n    }\n}",
    "walker_10": "walker NodeReporter {\n    can report_self with entry {\n        report here;\n    }\n}",
    "advanced_01": "node Item { has price: int; }\nwalker PriceFilter {\n    can find_expensive with entry {\n        visit [here --> (`?Item)](?price > 100);\n    }\n}",
    "advanced_02": "edge Owns {}\nwalker OwnerFinder {\n    can find_owners with entry {\n        visit [here ->:Owns:->];\n    }\n}",
    "advanced_03": "walker DeepCrawler {\n    can crawl_deep with entry {\n        visit [here --> --> -->];\n    }\n}",
    "advanced_04": "node StopNode {}\nwalker EarlyStopper {\n    can stop_early with StopNode entry {\n        disengage;\n    }\n    can continue_walking with entry {\n        visit [here -->];\n    }\n}",
    "advanced_05": "walker MyWalker {}\nedge MyEdge {\n    has counter: int = 0;\n    can count_traversal with MyWalker entry {\n        self.counter += 1;\n    }\n}",
    "advanced_06": "walker DfsWalker {\n    has visited: set = set();\n    can search with entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            for child in [here -->] {\n                if child not in self.visited {\n                    visit [child];\n                }\n            }\n        }\n    }\n}",
    "advanced_07": "node TargetNode {}\nwalker MultiVisitor {\n    has targets: list[TargetNode];\n    can visit_targets with entry {\n        visit [self.targets];\n    }\n}",
    "advanced_08": "node User { has age: int; }\nwalker AdultFinder {\n    can find_adults with entry {\n        visit [here --> (`?User)](?age >= 18);\n    }\n}",
    "advanced_09": "edge Connection { has weight: float; }\nwalker StrongConnectionFinder {\n    can find_strong with entry {\n        visit [here ->:Connection:weight > 5.0:->];\n    }\n}",
    "advanced_10": "node Person {}\nwith entry {\n    alice = Person();\n    bob = Person();\n    alice ++> bob;\n    alice del --> bob;\n}",
    "ai_01": "import from byllm {Model};",
    "ai_02": "import from byllm {Model};\nglob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm {Model};\nglob llm = Model();\ndef generate_greeting(name: str) -> str by llm();",
    "ai_04": "obj User {\n    has name: str;\n}\nsem User.name = \"The full legal name of the user.\";",
    "ai_05": "import from byllm {Model};\nglob llm = Model();\nenum Category {\n    SPAM,\n    IMPORTANT,\n    PROMOTION\n}\ndef classify_email(content: str) -> Category by llm();",
    "ai_06": "import from byllm {Model};\nglob llm = Model();\ndef solve_riddle(riddle: str) -> str by llm(method='Reason');",
    "ai_07": "import from byllm {Model};\nglob llm = Model();\ndef get_weather(city: str) -> str {\n    return \"Sunny\";\n}\ndef weather_assistant(question: str) -> str by llm(method='ReAct', tools=[get_weather]);",
    "ai_08": "import from byllm {Image};",
    "ai_09": "import from byllm {Model};\nglob llm = Model();\nobj Document {\n    has text: str;\n    def summarize(self) -> str by llm();\n}",
    "ai_10": "import from byllm {Model};\nglob llm = Model();\nobj UserProfile {\n    has username: str;\n    has follower_count: int;\n}\ndef parse_profile(text: str) -> UserProfile by llm();",
    "cloud_01": "walker UserApi {\n    has name: str;\n    obj __specs__ {\n        static has methods: list = [\"get\", \"post\"];\n    }\n}",
    "cloud_02": "walker PublicApi {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n}",
    "cloud_03": "walker CustomPathWalker {\n    obj __specs__ {\n        static has path: str = \"/api/v2/users\";\n    }\n}",
    "cloud_04": "walker SearchApi {\n    has query: str;\n    has limit: int;\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has as_query: list = [\"*\"];\n    }\n}",
    "cloud_05": "walker InternalTask {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n}",
    "cloud_06": "async walker BackgroundJob {\n    has user_id: str;\n    can process with `root entry {\n        # long running task\n    }\n}",
    "cloud_07": "with entry {\n    task_id: str = \"wlk::some_id\";\n    task_walker = &task_id;\n}",
    "cloud_08": "walker GithubWebhook {\n    obj __specs__ {\n        static has webhook: dict = {\"type\": \"header\", \"name\": \"X-Hub-Signature-256\"};\n    }\n    can handle with `root entry {\n        report \"Webhook received\";\n    }\n}",
    "cloud_09": "node PersistentData {\n    has value: str;\n}\nwith entry {\n    data = PersistentData(value=\"important\");\n    root ++> data;\n}",
    "cloud_10": "obj UserInfo {\n    has id: str;\n    has name: str;\n}\nwalker GetUser {\n    has user_id: str;\n    can get_user with `root entry {\n        report UserInfo(id=self.user_id, name=\"Test User\");\n    }\n}",
    "import_01": "import math;",
    "import_02": "import from math {sqrt, pow};",
    "import_03": "import from \"./helpers.jac\" {util_func};",
    "import_04": "import numpy as np;",
    "file_01": "with entry {\n    with open(\"data.txt\", \"r\") as f {\n        content: str = f.read();\n    }\n}",
    "file_02": "with entry {\n    with open(\"output.txt\", \"w\") as f {\n        f.write(\"Hello, Jac!\");\n    }\n}",
    "file_03": "import json;\nwith entry {\n    with open(\"config.json\", \"r\") as f {\n        data: dict = json.load(f);\n    }\n}",
    "impl_01": "obj Counter {\n    has val: int = 0;\n    def increment(self) -> int;\n}\n\nimpl Counter.increment(self) -> int {\n    self.val += 1;\n    return self.val;\n}",
    "advanced_func_01": "def sum_all(*numbers: int) -> int {\n    total: int = 0;\n    for num in numbers {\n        total += num;\n    }\n    return total;\n}",
    "advanced_func_02": "def create_user(**details: any) -> dict {\n    return details;\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since: str;\n}\n\nwalker SocialGraphWalker {\n    has visited: set = set();\n    can traverse with Person entry {\n        if here not in visitor.visited {\n            visitor.visited.add(here);\n            report here;\n            visit [here -->(`?Person)];\n        }\n    }\n}\n\nwith entry {\n    alice = Person(name=\"Alice\");\n    bob = Person(name=\"Bob\");\n    charlie = Person(name=\"Charlie\");\n    alice +>:Friendship:since=\"2022\":+> bob;\n    bob +>:Friendship:since=\"2023\":+> charlie;\n    alice spawn SocialGraphWalker();\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nedge Transition {\n    has on_event: str;\n}\n\nwalker StateMachine {\n    has event: str;\n    can process with State entry {\n        report f\"Current state: {here.name}\";\n        transitions = [here ->:Transition:->](?on_event == visitor.event);\n        if transitions {\n            next_state = [transitions[0] -->][0];\n            visit [next_state];\n        } else {\n            report \"No transition for event, halting.\";\n            disengage;\n        }\n    }\n}\n\nwith entry {\n    locked = State(name=\"locked\");\n    unlocked = State(name=\"unlocked\");\n    locked +>:Transition:on_event=\"coin\":+> unlocked;\n    unlocked +>:Transition:on_event=\"push\":+> locked;\n    locked spawn StateMachine(event=\"coin\");\n}",
    "integration_03": "class CustomError(Exception) {\n    pass;\n}\n\nwalker ErrorHandlingWalker {\n    can execute with `root entry {\n        try {\n            print(\"Attempting risky operation...\");\n            raise CustomError(\"Something went wrong!\");\n        } except CustomError as e {\n            report f\"Caught expected error: {e}\";\n        } except Exception {\n            report \"Caught an unexpected error.\";\n        } finally {\n            report \"Executing cleanup actions.\";\n        }\n    }\n}",
    "integration_04": "import from asyncio {sleep, run};\n\nasync def fetch_remote_data(url: str) -> dict {\n    print(f\"Fetching from {url}...\");\n    await sleep(1);\n    return {\"data\": \"Sample response\"};\n}\n\nasync def main() {\n    result = await fetch_remote_data(\"https://example.com\");\n    print(f\"Received: {result}\");\n}\n\nwith entry {\n    run(main());\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n    has is_deleted: bool = False;\n}\n\nwalker CrudManager {\n    has action: str;\n    has item_id: str | None = None;\n    has name: str | None = None;\n    has value: int | None = None;\n\n    can manage with `root entry {\n        match visitor.action {\n            case \"create\": {\n                new_item = here ++> Item(name=visitor.name, value=visitor.value);\n                commit();\n                report new_item;\n            }\n            case \"read\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    report items[0];\n                }\n            }\n            case \"update\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    item = items[0];\n                    if visitor.name is not None { item.name = visitor.name; }\n                    if visitor.value is not None { item.value = visitor.value; }\n                    commit(item);\n                    report item;\n                }\n            }\n            case \"delete\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    item = items[0];\n                    item.is_deleted = True;\n                    commit(item);\n                    report {\"status\": \"deleted\", \"id\": item.id};\n                }\n            }\n        }\n    }\n}",
    "integration_06": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nnode NewsArticle {\n    has headline: str;\n    has content: str;\n}\n\ndef summarize(text: str) -> str by llm(\"Summarize this article content in one sentence.\");\n\nwalker ArticleSummarizer {\n    can process with NewsArticle entry {\n        summary = summarize(here.content);\n        report {\"headline\": here.headline, \"summary\": summary};\n        visit [here -->];\n    }\n}",
    "integration_07": "node User {\n    has name: str;\n    has email: str;\n}\n\nwalker create_user {\n    has name: str;\n    has email: str;\n\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has auth: bool = False;\n    }\n\n    can create with `root entry {\n        new_user = here ++> User(name=visitor.name, email=visitor.email);\n        report {\"id\": new_user.id, \"name\": new_user.name};\n    }\n}",
    "integration_08": "node Node {\n    has name: str;\n}\n\nwalker BFS {\n    has queue: list;\n    has visited: set = set();\n\n    can search with Node entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            report here;\n            self.queue.extend([here -->]);\n        }\n        if self.queue {\n            visit [self.queue.pop(0)];\n        } else {\n            disengage;\n        }\n    }\n}",
    "integration_09": "walker WorkflowProcessor {\n    has steps_completed: list = [];\n}\n\nnode Step {\n    has name: str;\n    has status: str = \"pending\";\n\n    can execute with WorkflowProcessor entry {\n        print(f\"Executing step: {here.name}\");\n        here.status = \"completed\";\n        visitor.steps_completed.append(here.name);\n    }\n}\n\nwith entry {\n    start = Step(name=\"Start\");\n    middle = Step(name=\"Process\");\n    end = Step(name=\"Finish\");\n    start ++> middle ++> end;\n\n    processor = WorkflowProcessor();\n    start spawn processor;\n    visit [start, middle, end] with processor;\n    print(f\"Workflow complete. Steps: {processor.steps_completed}\");\n}",
    "integration_10": "node User { has name: str; }\nnode Movie { has title: str; has genre: str; }\nedge Watched { has rating: int; }\n\nwalker Recommender {\n    has recommendations: set = set();\n\n    can recommend with User entry {\n        # Find movies watched by friends (users one hop away)\n        friends_movies = [here --> (`?User) -->:Watched:-> (`?Movie)];\n        \n        # Find movies this user has already watched\n        my_movies = [here -->:Watched:-> (`?Movie)];\n        my_movie_set = set(my_movies);\n\n        for movie in friends_movies {\n            if movie not in my_movie_set {\n                visitor.recommendations.add(movie.title);\n            }\n        }\n        report visitor.recommendations;\n    }\n}",
    "prod_websocket_01": "import from jac_cloud.plugin {WEBSOCKET_MANAGER as socket};\n\nwalker ChatBroadcaster {\n    has channel_name: str;\n    has message: str;\n\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can broadcast with `root entry {\n        socket.notify_channels([visitor.channel_name], {\"text\": visitor.message});\n        report {\"status\": \"broadcasted\"};\n    }\n}",
    "prod_permissions_01": "from jaclang.core.utils import NoPerm, ReadPerm, WritePerm, AccessLevel, _Jac;\n\nnode Document {\n    has owner_id: str;\n    has is_public: bool = False;\n\n    def __jac_access__(self) -> AccessLevel {\n        if self.is_public {\n            return ReadPerm;\n        }\n        current_user_root = _Jac.get_root();\n        if current_user_root and current_user_root.id == self.owner_id {\n            return WritePerm;\n        }\n        return NoPerm;\n    }\n}",
    "prod_cache_01": "import from time {time};\n\nnode CacheItem {\n    has key: str;\n    has value: any;\n    has expires_at: float;\n}\n\ndef expensive_computation(key: str) -> str {\n    return f\"Computed value for {key} at {time()}\";\n}\n\nwalker CachedDataFetcher {\n    has key: str;\n    can fetch with `root entry {\n        cache_hits = [here --> (`?CacheItem)](?key == visitor.key);\n        if cache_hits and cache_hits[0].expires_at > time() {\n            report {\"source\": \"cache\", \"value\": cache_hits[0].value};\n        } else {\n            if cache_hits {\n                # In a real scenario, you'd delete the edge to the old cache node\n            }\n            new_value = expensive_computation(visitor.key);\n            here ++> CacheItem(\n                key=visitor.key, \n                value=new_value, \n                expires_at=time() + 3600\n            );\n            commit();\n            report {\"source\": \"computed\", \"value\": new_value};\n        }\n    }\n}",
    "prod_validation_01": "class ValidationError(Exception) { pass; }\n\nwalker CreateProduct {\n    has name: str;\n    has price: float;\n    has stock: int;\n\n    can create with `root entry {\n        if len(visitor.name) < 3 {\n            raise ValidationError(\"Product name must be at least 3 characters long.\");\n        }\n        if visitor.price <= 0.0 {\n            raise ValidationError(\"Price must be positive.\");\n        }\n        if visitor.stock < 0 {\n            raise ValidationError(\"Stock cannot be negative.\");\n        }\n        report {\"status\": \"validation passed\"};\n    }\n}",
    "prod_pagination_01": "node Product { has name: str; has category: str; }\n\nwalker ListProducts {\n    has page: int = 1;\n    has per_page: int = 10;\n    has category_filter: str | None = None;\n\n    can list with `root entry {\n        all_products = [here --> (`?Product)];\n        \n        filtered_products: list;\n        if visitor.category_filter {\n            filtered_products = [p for p in all_products if p.category == visitor.category_filter];\n        } else {\n            filtered_products = all_products;\n        }\n\n        start_index = (visitor.page - 1) * visitor.per_page;\n        end_index = start_index + visitor.per_page;\n        page_items = filtered_products[start_index:end_index];\n\n        report {\n            \"items\": page_items,\n            \"page\": visitor.page,\n            \"per_page\": visitor.per_page,\n            \"total_items\": len(filtered_products)\n        };\n    }\n}",
    "prod_scheduler_01": "walker DailyReportGenerator {\n    obj __specs__ {\n        static has private: bool = True;\n        static has schedule: dict = {\n            \"trigger\": \"cron\",\n            \"hour\": \"9\",\n            \"minute\": \"0\",\n            \"save\": True\n        };\n    }\n\n    can generate with `root entry {\n        # Logic to generate a daily report\n        report {\"status\": \"Daily report generated successfully.\"};\n    }\n}",
    "prod_versioning_01": "import from time {time};\n\nnode Document {\n    has title: str;\n    has content: str;\n    has current_version: int = 1;\n}\n\nnode DocumentVersion {\n    has version: int;\n    has content: str;\n    has created_at: float;\n}\n\nwalker UpdateDocument {\n    has doc_id: str;\n    has new_content: str;\n\n    can update with `root entry {\n        doc = &visitor.doc_id;\n        doc ++> DocumentVersion(\n            version=doc.current_version,\n            content=doc.content,\n            created_at=time()\n        );\n        doc.current_version += 1;\n        doc.content = visitor.new_content;\n        commit();\n        report doc;\n    }\n}",
    "prod_softdelete_01": "import from time {time};\n\nnode Item {\n    has name: str;\n    has is_deleted: bool = False;\n    has deleted_at: float | None = None;\n}\n\nwith entry {\n    # Create some items\n    root ++> Item(name=\"Active Item\");\n    deleted_item = root ++> Item(name=\"Deleted Item\");\n    deleted_item.is_deleted = True;\n    deleted_item.deleted_at = time();\n    commit();\n\n    # Query for non-deleted items\n    active_items = [root --> (`?Item)](?not is_deleted);\n    print(f\"Found {len(active_items)} active item(s).\");\n    for item in active_items {\n        print(f\"- {item.name}\");\n    }\n}",
    "prod_audit_01": "import from time {time};\n\nnode AuditLog {\n    has action: str;\n    has user_id: str;\n    has timestamp: float;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    has action: str;\n    has user_id: str;\n    has details: dict;\n\n    can log with `root entry {\n        log_entry = here ++> AuditLog(\n            action=visitor.action,\n            user_id=visitor.user_id,\n            details=visitor.details,\n            timestamp=time()\n        );\n        commit();\n        report log_entry;\n    }\n}",
    "prod_ratelimit_01": "import from time {time};\n\nclass RateLimitExceeded(Exception) { pass; }\n\nnode RateLimitInfo {\n    has user_id: str;\n    has count: int = 0;\n    has window_start: float = 0.0;\n}\n\nglob MAX_REQUESTS_PER_MINUTE: int = 100;\n\nwalker RateLimiter {\n    has user_id: str;\n    can check with `root entry {\n        now = time();\n        limit_nodes = [here --> (`?RateLimitInfo)](?user_id == visitor.user_id);\n        limit_info: RateLimitInfo;\n        if not limit_nodes {\n            limit_info = here ++> RateLimitInfo(user_id=visitor.user_id, window_start=now);\n        } else {\n            limit_info = limit_nodes[0];\n        }\n\n        if now - limit_info.window_start > 60 {\n            limit_info.window_start = now;\n            limit_info.count = 1;\n        } else {\n            limit_info.count += 1;\n        }\n\n        commit(limit_info);\n        if limit_info.count > :g:MAX_REQUESTS_PER_MINUTE {\n            raise RateLimitExceeded(\"Rate limit exceeded\");\n        }\n        report {\"status\": \"allowed\", \"count\": limit_info.count};\n    }\n}",
    "advanced_ai_stream_01": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef generate_poem(topic: str) -> str by llm(stream=True);\n\nwith entry {\n    print(f\"Generating a poem about 'the ocean':\");\n    full_response: str = \"\";\n    for token in generate_poem(\"the ocean\") {\n        print(token, end=\"\");\n        full_response += token;\n    }\n    print(\"\\n--- End of Stream ---\");\n}",
    "advanced_ai_multimodal_01": "import from byllm {Model, Image};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef describe_image(image: Image, context: str) -> str by llm();\n\nwalker ImageProcessor {\n    has image_path: str;\n    can process with `root entry {\n        try {\n            img = Image(visitor.image_path);\n            description = describe_image(img, \"Describe this image for a visually impaired user.\");\n            report {\"description\": description};\n        } except Exception as e {\n            report {\"error\": str(e)};\n        }\n    }\n}",
    "advanced_ai_react_01": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef get_stock_price(symbol: str) -> float {\n    # Mock function for a tool\n    if symbol == \"JAC\" { return 123.45; }\n    return 0.0;\n}\n\ndef execute_trade(symbol: str, quantity: int, action: str) -> str {\n    # Mock function for another tool\n    return f\"Successfully executed {action} of {quantity} shares of {symbol}.\";\n}\n\ndef trading_assistant(query: str) -> str by llm(method='ReAct', tools=[get_stock_price, execute_trade]);\n\nwith entry {\n    response = trading_assistant(\"What is the price of JAC stock, and then buy 10 shares?\");\n    print(response);\n}",
    "advanced_ai_structured_01": "import from byllm {Model};\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nobj InvoiceData {\n    has invoice_id: str;\n    has total_amount: float;\n    has currency: str;\n}\n\ndef extract_invoice_data(text: str) -> InvoiceData by llm();\n\nwith entry {\n    invoice_text = \"Invoice #INV-2024-001 is due. The total is 599.99 USD.\";\n    data = extract_invoice_data(invoice_text);\n    print(f\"ID: {data.invoice_id}, Amount: {data.total_amount} {data.currency}\");\n}",
    "advanced_graph_complex_filter_01": "node User { has name: str; has is_active: bool; }\nnode Post { has content: str; has likes: int; }\nedge Authored { has created_at: str; }\n\nwith entry {\n    # This query finds posts with more than 100 likes\n    # authored by active users.\n    results = [root --> (`?User)](?is_active) ->:Authored:-> (`?Post)](?likes > 100);\n    \n    print(f\"Found {len(results)} posts matching complex criteria.\");\n    for post in results {\n        print(f\"- Post with {post.likes} likes: {post.content[:30]}...\");\n    }\n}",
    "advanced_graph_pathfind_01": "node City { has name: str; }\nedge Route { has distance: int; }\n\nwalker Dijkstra {\n    has distances: dict;\n    has target: City;\n    has unvisited: set;\n\n    can find_shortest_path with City entry {\n        if here not in visitor.unvisited { disengage; };\n        visitor.unvisited.remove(here);\n\n        if here == visitor.target {\n            report {\"path_found\": True, \"distance\": visitor.distances[here.id]};\n            disengage;\n        }\n\n        for edge in [here --->:Route:->] {\n            neighbor = [edge -->][0];\n            new_dist = visitor.distances[here.id] + edge.distance;\n            if new_dist < visitor.distances.get(neighbor.id, 999999) {\n                visitor.distances[neighbor.id] = new_dist;\n            }\n        }\n        \n        next_node: City | None = None;\n        min_dist = 999999;\n        for node in visitor.unvisited {\n            if visitor.distances.get(node.id, 999999) < min_dist {\n                min_dist = visitor.distances[node.id];\n                next_node = node;\n            }\n        }\n\n        if next_node {\n            visit [next_node];\n        } else {\n            report {\"path_found\": False};\n            disengage;\n        }\n    }\n}",
    "advanced_graph_cycle_01": "node Node { has name: str; }\n\nwalker CycleDetector {\n    has visited: set = set();\n    has recursion_stack: list = [];\n    has cycle_found: bool = False;\n\n    can detect with Node entry {\n        if visitor.cycle_found { disengage; };\n\n        visitor.visited.add(here);\n        visitor.recursion_stack.append(here);\n\n        for neighbor in [here -->] {\n            if neighbor in visitor.recursion_stack {\n                report f\"Cycle detected involving node {neighbor.name}\";\n                visitor.cycle_found = True;\n                disengage;\n            }\n            if neighbor not in visitor.visited {\n                visit [neighbor];\n            }\n        }\n        visitor.recursion_stack.pop();\n    }\n}",
    "advanced_persist_transaction_01": "node Account {\n    has name: str;\n    has balance: float;\n}\n\nwith entry {\n    account_a = Account(name=\"A\", balance=100.0);\n    account_b = Account(name=\"B\", balance=50.0);\n    save(account_a);\n    save(account_b);\n    commit();\n\n    # Transfer 30 from A to B\n    account_a.balance -= 30.0;\n    account_b.balance += 30.0;\n\n    save(account_a);\n    save(account_b);\n    commit();\n\n    print(f\"Final balances: A={account_a.balance}, B={account_b.balance}\");\n}",
    "advanced_persist_reference_01": "node User {\n    has name: str;\n}\n\nobj Session {\n    has user_id: str;\n}\n\nwith entry {\n    # Create and persist a user\n    user = User(name=\"Zoe\");\n    save(user);\n    commit();\n\n    # Store the user's ID in another object\n    session = Session(user_id=user.id);\n    user_id_ref = session.user_id;\n\n    # Later, retrieve the user node using the stored ID reference\n    retrieved_user = &user_id_ref;\n\n    print(f\"Retrieved user: {retrieved_user.name}\");\n    assert retrieved_user.id == user.id;\n}",
    "advanced_cloud_webhook_01": "walker StripeWebhookHandler {\n    has event_data: dict;\n\n    obj __specs__ {\n        static has webhook: dict = {\n            \"type\": \"header\",\n            \"name\": \"Stripe-Signature\"\n        };\n        static has path: str = \"/webhooks/stripe\";\n    }\n\n    can handle with `root entry {\n        print(\"Received a validated webhook from Stripe.\");\n        # Process event_data here\n        report {\"status\": \"received\"};\n    }\n}",
    "advanced_cloud_async_retrieve_01": "async walker ReportGenerator {\n    has user_id: str;\n    can generate with `root entry {\n        # Simulate a long-running task\n        import from asyncio {sleep};\n        await sleep(5);\n        report {\"report_url\": f\"/reports/{visitor.user_id}.pdf\"};\n    }\n}\n\nwith entry {\n    task_id = root spawn ReportGenerator(user_id=\"user123\");\n    print(f\"Spawned async task with ID: {task_id}\");\n\n    # Later, you can check the status\n    task = &task_id;\n    status = task.__jac__.status;\n    reports = task.__jac__.reports;\n    print(f\"Task status: {status}\");\n    print(f\"Task reports: {reports}\");\n}",
    "advanced_cloud_query_params_01": "walker SearchAPI {\n    has query: str;\n    has limit: int = 20;\n    has offset: int = 0;\n    has sort_by: str = \"relevance\"; // This will be in the JSON body\n\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has auth: bool = False;\n        static has as_query: list = [\"query\", \"limit\", \"offset\"];\n    }\n\n    can search with `root entry {\n        report {\n            \"searching_with_query\": visitor.query,\n            \"limit\": visitor.limit,\n            \"offset\": visitor.offset,\n            \"sorting_by_body_param\": visitor.sort_by\n        };\n    }\n}",
    "integration_error_handling_01": "class DivisionByZeroError(Exception) { pass; }\n\ndef safe_divide(a: int, b: int) -> float {\n    if b == 0 {\n        raise DivisionByZeroError(\"Cannot divide by zero\");\n    }\n    return a / b;\n}\n\nwalker Calculator {\n    has a: int;\n    has b: int;\n    can calculate with `root entry {\n        try {\n            result = safe_divide(visitor.a, visitor.b);\n            report {\"result\": result};\n        } except DivisionByZeroError as e {\n            print(f\"Error during calculation: {e}\");\n            report {\"error\": str(e), \"result\": None};\n        }\n    }\n}",
    "integration_external_api_01": "import requests;\n\nwalker ApiFetcher {\n    has url: str;\n    can fetch with `root entry {\n        try {\n            response = requests.get(visitor.url);\n            response.raise_for_status(); // Raises an exception for 4xx/5xx errors\n            report response.json();\n        } except requests.exceptions.RequestException as e {\n            report {\"error\": f\"API request failed: {e}\"};\n        }\n    }\n}",
    "integration_conditional_visit_01": "node WebPage { has name: str; }\n\nwalker LimitedCrawler {\n    has visited_count: int = 0;\n    has max_visits: int = 5;\n\n    can crawl with WebPage entry {\n        visitor.visited_count += 1;\n        report f\"Visiting page {visitor.visited_count}: {here.name}\";\n        \n        if visitor.visited_count >= visitor.max_visits {\n            disengage;\n        }\n\n        successors = [here -->];\n        visit [successors] else {\n            report \"No more pages to visit. Disengaging.\";\n            disengage;\n        };\n    }\n}",
    "integration_multi_ability_01": "walker ProcessMonitor {\n    has log: list = [];\n}\n\nnode Task {\n    has name: str;\n\n    can monitor with ProcessMonitor entry {\n        visitor.log.append(f\"STARTED: {here.name} at {here.id}\");\n        print(f\"Entering task {here.name}\");\n    }\n\n    can monitor with ProcessMonitor exit {\n        visitor.log.append(f\"COMPLETED: {here.name} at {here.id}\");\n        print(f\"Exiting task {here.name}\");\n    }\n}",
    "integration_batch_process_01": "node Invoice {\n    has amount: float;\n    has is_paid: bool = False;\n}\n\nwalker PaymentProcessor {\n    can process_payments with `root entry {\n        unpaid_invoices = [here --> (`?Invoice)](?not is_paid);\n        processed_count = 0;\n        for invoice in unpaid_invoices {\n            # Simulate payment processing\n            invoice.is_paid = True;\n            save(invoice);\n            processed_count += 1;\n        }\n        if processed_count > 0 {\n            commit();\n        }\n        report f\"Processed {processed_count} invoices.\";\n    }\n}",
    "integration_visitor_communication_01": "walker DataCollector {\n    has collected_data: list = [];\n}\n\nnode Sensor {\n    has reading: float;\n\n    can collect with DataCollector entry {\n        visitor.collected_data.append(here.reading);\n    }\n}\n\nwith entry {\n    s1 = Sensor(reading=10.5);\n    s2 = Sensor(reading=12.1);\n    s3 = Sensor(reading=9.8);\n    s1 ++> s2 ++> s3;\n\n    collector = DataCollector();\n    s1 spawn collector;\n    print(f\"Collected data: {collector.collected_data}\");\n}",
    "integration_root_ability_01": "node SystemConfig { has version: str; }\n\nwalker SystemInitializer {\n    can initialize with `root entry {\n        configs = [here --> (`?SystemConfig)];\n        if not configs {\n            print(\"No config found, creating one.\");\n            here ++> SystemConfig(version=\"1.0\");\n            commit();\n            report \"System initialized.\";\n        } else {\n            report f\"System already initialized with version {configs[0].version}.\";\n        }\n    }\n}",
    "integration_edge_traversal_01": "node User { has name: str; }\nedge Follows { has since: str; }\nedge Blocks {}\n\nwalker ConnectionInspector {\n    can inspect with User entry {\n        report f\"Inspecting connections for {here.name}:\";\n        outgoing_edges = [here --->];\n        for edge in outgoing_edges {\n            if type(edge) is Follows {\n                target_user = [edge -->][0];\n                report f\"  - Follows {target_user.name} since {edge.since}\";\n            }\n            if type(edge) is Blocks {\n                target_user = [edge -->][0];\n                report f\"  - Blocks {target_user.name}\";\n            }\n        }\n    }\n}"
  }
}