{
  "metadata": {
    "model": "gemini/gemini-2.5-pro-preview-03-25",
    "model_alias": "gemini-pro",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    };\n}",
    "basic_06": "#* \nThis is a multi-line comment.\n*#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    message: str = f\"Hello, {name}!\";\n    print(message);\n}",
    "basic_08": "with entry {\n    my_var: str|int = \"hello\";\n}",
    "basic_09": "with entry {\n    squares: list[int] = [x * x for x in range(1, 6)];\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"Positive\");\n    } elif num < 0 {\n        print(\"Negative\");\n    } else {\n        print(\"Zero\");\n    };\n}",
    "control_01": "with entry {\n    count: int = 1;\n    while count <= 5 {\n        print(count);\n        count += 1;\n    };\n}",
    "control_02": "with entry {\n    status: str = \"active\";\n    match status {\n        case \"active\": print(\"Processing\");\n        case \"pending\": print(\"Waiting\");\n        case _: print(\"Unknown\");\n    };\n}",
    "control_03": "with entry {\n    for i in range(10) {\n        if i == 5 {\n            break;\n        };\n        print(i);\n    };\n}",
    "control_04": "with entry {\n    for i in range(10) {\n        if i % 2 == 0 {\n            continue;\n        };\n        print(i);\n    };\n}",
    "collection_01": "with entry {\n    my_set: set[int] = {1, 2, 3};\n    my_set.add(4);\n}",
    "collection_02": "with entry {\n    person: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares: dict[int, int] = {x: x*x for x in range(1, 6)};\n}",
    "collection_04": "with entry {\n    names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n    for name in names {\n        print(name);\n    };\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n    age: int|None = ages.get(\"Alice\");\n}",
    "type_01": "with entry {\n    value: any = \"hello world\";\n    if isinstance(value, str) {\n        print(\"It is a string.\");\n    };\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.year} {self.brand}\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square = lambda x: int: x * x;\n}",
    "obj_06": "obj SecretContainer {\n    has _secret_value: str;\n}",
    "obj_07": "obj PublicContainer {\n    has public_value: str;\n}",
    "obj_08": "def my_decorator(func: callable) -> callable {\n    def wrapper() {\n        print(\"Before function call\");\n        func();\n        print(\"After function call\");\n    };\n    return wrapper;\n}\n\n@my_decorator\ndef say_hello() {\n    print(\"Hello!\");\n}",
    "obj_09": "def execute(op: callable[[int], int], val: int) -> int {\n    return op(val);\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n}\n\nwith entry {\n    sf: City = City(name=\"SF\");\n    la: City = City(name=\"LA\");\n    sf <++> la;\n}",
    "graph_03": "node City {\n    has name: str;\n}\n\nedge Road {\n    has distance: float;\n}\n\nwith entry {\n    sf: City = City(name=\"SF\");\n    la: City = City(name=\"LA\");\n    sf +>:Road:distance=383.1:+> la;\n}",
    "graph_04": "walker MyWalker {};\n\nnode MyNode {\n    can do_something with MyWalker entry {\n        print(\"Walker has arrived!\");\n    }\n}",
    "graph_05": "walker MyWalker {\n    has data: str = \"some data\";\n}\n\nnode MyNode {\n    can process with MyWalker entry {\n        print(visitor.data);\n    }\n}",
    "graph_06": "node Item {};\n\nwith entry {\n    item1: Item = Item();\n    item2: Item = Item();\n    item1 ++> item2;\n}",
    "graph_07": "node MyData {\n    has value: int;\n}\n\nwith entry {\n    root ++> MyData(value=42);\n}",
    "graph_08": "walker MyWalker {};\n\nnode MyNode {\n    can cleanup with MyWalker exit {\n        print(\"Walker is leaving.\");\n    }\n}",
    "graph_09": "walker Traveler {};\n\nedge Path {\n    has length: int;\n    can cross with Traveler entry {\n        print(\"Crossing path!\");\n    }\n}",
    "graph_10": "node Step {};\n\nwith entry {\n    s1: Step = Step();\n    s2: Step = Step();\n    s3: Step = Step();\n    s1 ++> s2 ++> s3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker Explorer {\n    can explore with entry {\n        visit [here -->];\n    }\n}",
    "walker_03": "node Page {};\n\nwalker Bot {\n    can crawl with entry {\n        visit [here --> (`?Page)];\n    }\n}",
    "walker_04": "walker Inspector {\n    can inspect with entry {\n        print(f\"Inspecting node: {here}\");\n    }\n}",
    "walker_05": "walker Reporter {\n    can report_data with entry {\n        report \"some data\";\n    }\n}",
    "walker_06": "node MyNode {};\nwalker MyWalker {};\nwith entry {\n    n = MyNode();\n    n spawn MyWalker();\n}",
    "walker_07": "walker MyWalker {};\nwith entry {\n    root spawn MyWalker();\n}",
    "walker_08": "walker PredecessorVisitor {\n    can visit_preds with entry {\n        visit [<-- here];\n    }\n}",
    "walker_09": "walker Finisher {\n    can finish with exit {\n        print(\"Exiting node.\");\n    }\n}",
    "walker_10": "walker NodeReporter {\n    can report_self with entry {\n        report here;\n    }\n}",
    "advanced_01": "node Item { has price: int; }\nwalker PriceChecker {\n    can find_expensive with entry {\n        visit [here --> (`?Item)](?price > 100);\n    }\n}",
    "advanced_02": "edge Owns {};\nwalker OwnershipWalker {\n    can find_owned with entry {\n        visit [here ->:Owns:->];\n    }\n}",
    "advanced_03": "walker DeepCrawler {\n    can crawl_deep with entry {\n        results = [here --> --> -->];\n    }\n}",
    "advanced_04": "walker Stopper {\n    has stop_at: str;\n    can find_and_stop with entry {\n        if here.name == self.stop_at {\n            report here;\n            disengage;\n        }\n        visit [here -->];\n    }\n}",
    "advanced_05": "walker Traveler { has wallet: float = 100.0; }\nedge TollRoad {\n    has fee: float;\n    can charge with Traveler entry {\n        visitor.wallet -= self.fee;\n    }\n}",
    "advanced_06": "walker DFSWalker {\n    has visited: set = set();\n    can search with entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            report here;\n            for child in [here -->] {\n                if child not in self.visited {\n                    visit [child];\n                }\n            }\n        }\n    }\n}",
    "advanced_07": "node TargetNode {};\nwalker MultiVisitor {\n    has targets: list[TargetNode];\n    can visit_all with `root entry {\n        visit self.targets;\n    }\n}",
    "advanced_08": "node Person { has age: int; }\nwalker AdultFinder {\n    can find_adults with entry {\n        adults = [here --> (`?Person)](?age > 18);\n    }\n}",
    "advanced_09": "edge Connection { has weight: float; }\nwalker StrongConnectionFinder {\n    can find_strong with entry {\n        strong_connections = [here ->:Connection:weight > 5.0:->];\n    }\n}",
    "advanced_10": "node Node {};\nwith entry {\n    node1 = Node();\n    node2 = Node();\n    node1 ++> node2;\n    node1 del --> node2;\n}",
    "ai_01": "import from byllm { Model };",
    "ai_02": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");\ndef generate_greeting(name: str) -> str by llm();",
    "ai_04": "obj User {\n    has email: str;\n}\nsem User.email = \"The user's primary email address for contact.\";",
    "ai_05": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");\nenum Category {\n    SPAM,\n    IMPORTANT,\n    PROMOTION\n}\ndef classify_email(content: str) -> Category by llm();",
    "ai_06": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");\ndef solve_riddle(riddle: str) -> str by llm(method='Reason');",
    "ai_07": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");\ndef get_stock_price(ticker: str) -> float {\n    return 150.0;\n}\ndef financial_assistant(query: str) -> str by llm(method='ReAct', tools=[get_stock_price]);",
    "ai_08": "import from byllm { Image };",
    "ai_09": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");\nobj Document {\n    has text: str;\n    def summarize(self) -> str by llm();\n}",
    "ai_10": "import from byllm { Model };\nglob llm = Model(model_name=\"gpt-4o-mini\");\nobj UserProfile {\n    has username: str;\n    has location: str;\n}\ndef parse_bio(bio_text: str) -> UserProfile by llm();",
    "cloud_01": "walker UserApi {\n    has user_id: str;\n    obj __specs__ {\n        static has methods: list = [\"get\", \"post\"];\n    }\n}",
    "cloud_02": "walker PublicInfo {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n}",
    "cloud_03": "walker CustomEndpoint {\n    obj __specs__ {\n        static has path: str = \"/v1/data\";\n    }\n}",
    "cloud_04": "walker Searcher {\n    has query: str;\n    has category: str;\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has as_query: list = [\"*\"];\n    }\n}",
    "cloud_05": "walker InternalTask {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n}",
    "cloud_06": "async walker BackgroundJob {\n    has job_id: str;\n    can run with `root entry {\n        # long running task\n    }\n}",
    "cloud_07": "with entry {\n    task_id: str = \"w::some_walker_id\";\n    task_handle = &task_id;\n}",
    "cloud_08": "walker GithubWebhook {\n    obj __specs__ {\n        static has webhook: dict = {\"type\": \"header\", \"name\": \"X-Hub-Signature-256\"};\n    }\n    can handle with `root entry {\n        report \"Webhook received\";\n    }\n}",
    "cloud_09": "node PersistentData { has data: str; }\nwith entry {\n    p_data = PersistentData(data=\"important\");\n    root ++> p_data;\n}",
    "cloud_10": "obj ApiResponse {\n    has status: str;\n    has message: str;\n}\nwalker StatusChecker {\n    can check with `root entry {\n        report ApiResponse(status=\"ok\", message=\"System is running.\");\n    }\n}",
    "import_01": "import requests;",
    "import_02": "import from datetime { datetime, timedelta };",
    "import_03": "import from my_module { my_function };",
    "import_04": "import numpy as np;",
    "file_01": "with entry {\n    with open(\"data.txt\", \"r\") as f {\n        content: str = f.read();\n        print(content);\n    }\n}",
    "file_02": "with entry {\n    with open(\"output.txt\", \"w\") as f {\n        f.write(\"Hello, Jac file!\");\n    }\n}",
    "file_03": "import json;\nwith entry {\n    with open(\"config.json\", \"r\") as f {\n        config: dict = json.load(f);\n        print(config);\n    }\n}",
    "impl_01": "impl Greeter.say_hello() -> str {\n    return f\"Hello, {self.name}\";\n}",
    "advanced_func_01": "def multiply_all(*numbers: float) -> float {\n    result: float = 1.0;\n    for num in numbers {\n        result *= num;\n    }\n    return result;\n}",
    "advanced_func_02": "def create_user(**details: any) -> dict {\n    return details;\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since: str;\n}\n\nwalker SocialGraphWalker {\n    has visited: set = set();\n    can traverse with Person entry {\n        if here not in visitor.visited {\n            visitor.visited.add(here);\n            report here;\n            visit [here -->(`?Person)];\n        }\n    }\n}\n\nwith entry {\n    alice = Person(name=\"Alice\");\n    bob = Person(name=\"Bob\");\n    charlie = Person(name=\"Charlie\");\n\n    alice +>:Friendship:since=\"2022\":+> bob;\n    bob +>:Friendship:since=\"2023\":+> charlie;\n\n    alice spawn SocialGraphWalker();\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nedge Transition {\n    has on_event: str;\n}\n\nwalker StateMachine {\n    has event: str;\n    can process with State entry {\n        report f\"Current state: {here.name}\";\n        transitions = [here ->:Transition:->](?on_event == visitor.event);\n        if transitions {\n            next_state = [transitions[0] -->][0];\n            visit [next_state];\n        } else {\n            report \"No transition for event, machine halted.\";\n            disengage;\n        }\n    }\n}",
    "integration_03": "class CustomError(Exception) {\n    pass;\n}\n\nwalker ErrorHandlerWalker {\n    can process with `root entry {\n        try {\n            raise CustomError(\"Something went wrong during operation.\");\n        } except CustomError as e {\n            report f\"Caught expected error: {e}\";\n        } except Exception {\n            report \"Caught an unexpected error.\";\n        } finally {\n            report \"Cleanup operations are complete.\";\n        }\n    }\n}",
    "integration_04": "import from asyncio {run, sleep};\n\nasync def fetch_remote_data(url: str) -> dict {\n    print(f\"Fetching from {url}...\");\n    await sleep(1);\n    return {\"data\": \"Sample response\"};\n}\n\nwith entry {\n    async def main() {\n        result = await fetch_remote_data(\"https://example.com\");\n        print(result);\n    };\n    run(main());\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n    has is_deleted: bool = False;\n}\n\nwalker CrudManager {\n    has action: str;\n    has item_id: str | None = None;\n    has data: dict | None = None;\n\n    can manage with `root entry {\n        match visitor.action {\n            case \"create\": {\n                item = here ++> Item(name=visitor.data[\"name\"], value=visitor.data[\"value\"]);\n                report item;\n            }\n            case \"read\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items { report items[0]; }\n            }\n            case \"update\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    items[0].name = visitor.data[\"name\"];\n                    report items[0];\n                }\n            }\n            case \"delete\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    items[0].is_deleted = True;\n                    report f\"Item {items[0].id} soft deleted\";\n                }\n            }\n        }\n        commit();\n    }\n}",
    "integration_06": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nnode Document {\n    has content: str;\n}\n\ndef summarize(text: str) -> str by llm();\n\nwalker DocSummarizer {\n    can summarize_docs with `root entry {\n        visit [here --> (`?Document)];\n    }\n    can process_doc with Document entry {\n        summary = summarize(here.content);\n        report {\"id\": here.id, \"summary\": summary};\n    }\n}",
    "integration_07": "node User {\n    has name: str;\n    has email: str;\n}\n\nwalker create_user {\n    has name: str;\n    has email: str;\n\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has auth: bool = False;\n    }\n\n    can create with `root entry {\n        new_user = here ++> User(name=visitor.name, email=visitor.email);\n        report new_user;\n    }\n}",
    "integration_08": "node Node {\n    has value: int;\n}\n\nwalker BfsWalker {\n    has queue: list = [];\n    has visited: set = set();\n\n    can search with Node entry {\n        if here not in visitor.visited {\n            visitor.visited.add(here);\n            report here;\n            visitor.queue.extend([here -->]);\n        }\n        if visitor.queue {\n            visit [visitor.queue.pop(0)];\n        }\n    }\n}",
    "integration_09": "node Step {\n    has name: str;\n    has status: str = \"pending\";\n    can execute with Processor entry {\n        if visitor.can_process(here) {\n            here.status = \"running\";\n            visitor.log.append(f\"Executing {here.name}\");\n            here.status = \"done\";\n        }\n    }\n}\n\nedge DependsOn {}\n\nwalker Processor {\n    has log: list = [];\n    def can_process(self, step: Step) -> bool {\n        dependencies = [<--:DependsOn:-- step];\n        return all(d.status == \"done\" for d in dependencies);\n    };\n    can start with `root entry {\n        visit [here --> (`?Step)];\n    }\n}",
    "integration_10": "node User { has name: str; }\nnode Item { has name: str; }\nedge Likes {}\nedge Friend {}\n\nwalker Recommender {\n    has recommendations: set = set();\n    can find_recommendations with User entry {\n        my_likes = [here -->:Likes:-> (`?Item)];\n        friends_likes = [here -->:Friend:-> (`?User) -->:Likes:-> (`?Item)];\n        \n        my_likes_set = set(my_likes);\n        for item in friends_likes {\n            if item not in my_likes_set {\n                visitor.recommendations.add(item);\n            }\n        }\n        report list(visitor.recommendations);\n    }\n}",
    "prod_websocket_01": "import from jac_cloud.plugin { WEBSOCKET_MANAGER as socket };\n\nwalker ChannelBroadcaster {\n    has channel_name: str;\n    has message: str;\n\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can broadcast with `root entry {\n        socket.notify_channels([visitor.channel_name], {\"text\": visitor.message});\n        report {\"status\": \"broadcasted\"};\n    }\n}",
    "prod_permissions_01": "node Document {\n    has owner_id: str;\n    has is_public: bool = False;\n\n    def __jac_access__(self) -> AccessLevel {\n        if here.is_public {\n            return ReadPerm;\n        }\n        if _Jac.get_root().id == here.owner_id {\n            return WritePerm;\n        }\n        return NoPerm;\n    }\n}",
    "prod_cache_01": "import from time { time };\n\nnode CacheItem {\n    has key: str;\n    has value: any;\n    has expires_at: float;\n}\n\ndef expensive_computation(key: str) -> str {\n    return f\"Computed value for {key} at {time()}\";\n}\n\nwalker CachingWalker {\n    has key: str;\n    can get_value with `root entry {\n        cached_items = [here --> (`?CacheItem)](?key == visitor.key);\n        if cached_items and cached_items[0].expires_at > time() {\n            report cached_items[0].value;\n        } else {\n            new_value = expensive_computation(visitor.key);\n            if cached_items {\n                del cached_items[0];\n            }\n            here ++> CacheItem(key=visitor.key, value=new_value, expires_at=time() + 3600);\n            report new_value;\n        }\n    }\n}",
    "prod_validation_01": "class ValidationError(Exception) { pass; }\n\nwalker UserCreator {\n    has email: str;\n    has age: int;\n\n    can create with `root entry {\n        try {\n            if \"@\" not in visitor.email or \".\" not in visitor.email {\n                raise ValidationError(\"Invalid email format.\");\n            }\n            if visitor.age < 18 {\n                raise ValidationError(\"User must be at least 18 years old.\");\n            }\n            report {\"status\": \"success\", \"message\": \"User data is valid.\"};\n        } except ValidationError as e {\n            report {\"status\": \"error\", \"message\": f\"{e}\"};\n        }\n    }\n}",
    "prod_pagination_01": "node Item { has name: str; has category: str; }\n\nwalker ItemPaginator {\n    has page: int = 1;\n    has per_page: int = 10;\n    has category_filter: str;\n\n    can list_items with `root entry {\n        all_items = [here --> (`?Item)](?category == visitor.category_filter);\n        total_items = len(all_items);\n        start_index = (visitor.page - 1) * visitor.per_page;\n        end_index = start_index + visitor.per_page;\n        \n        paginated_items = all_items[start_index:end_index];\n\n        report {\n            \"items\": paginated_items,\n            \"total\": total_items,\n            \"page\": visitor.page,\n            \"per_page\": visitor.per_page\n        };\n    }\n}",
    "prod_scheduler_01": "walker DailyReportGenerator {\n    obj __specs__ {\n        static has private: bool = True;\n        static has schedule: dict = {\n            \"trigger\": \"cron\",\n            \"hour\": \"9\",\n            \"minute\": \"0\",\n            \"save\": True\n        };\n    }\n\n    can generate with `root entry {\n        report \"Generating daily report...\";\n        # Report generation logic here\n        report \"Daily report complete.\";\n    }\n}",
    "prod_versioning_01": "import from time { time };\n\nnode Document {\n    has content: str;\n    has version: int = 1;\n}\n\nnode DocumentVersion {\n    has version: int;\n    has content: str;\n    has created_at: float;\n}\n\nwalker DocumentUpdater {\n    has doc_id: str;\n    has new_content: str;\n\n    can update with `root entry {\n        doc = &visitor.doc_id;\n        if doc {\n            doc ++> DocumentVersion(\n                version=doc.version,\n                content=doc.content,\n                created_at=time()\n            );\n            doc.version += 1;\n            doc.content = visitor.new_content;\n            commit();\n            report doc;\n        }\n    }\n}",
    "prod_softdelete_01": "import from time { time };\n\nnode Item {\n    has name: str;\n    has is_deleted: bool = False;\n    has deleted_at: float | None = None;\n}\n\nwalker ItemManager {\n    has item_id: str;\n    can soft_delete with `root entry {\n        item = &visitor.item_id;\n        if item {\n            item.is_deleted = True;\n            item.deleted_at = time();\n            commit(item);\n            report {\"status\": \"success\"};\n        }\n    }\n    can list_active_items with `root entry {\n        active_items = [here --> (`?Item)](?is_deleted == False);\n        report active_items;\n    }\n}",
    "prod_audit_01": "import from time { time };\n\nnode AuditLog {\n    has user_id: str;\n    has action: str;\n    has timestamp: float;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    has user_id: str;\n    has action: str;\n    has details: dict;\n\n    can log_action with `root entry {\n        log_entry = here ++> AuditLog(\n            user_id=visitor.user_id,\n            action=visitor.action,\n            timestamp=time(),\n            details=visitor.details\n        );\n        commit(log_entry);\n        report {\"log_id\": log_entry.id};\n    }\n}",
    "prod_ratelimit_01": "import from time { time };\n\nclass RateLimitExceeded(Exception) { pass; }\n\nnode RateLimitInfo {\n    has user_id: str;\n    has count: int = 0;\n    has window_start: float = 0.0;\n}\n\nglob MAX_REQUESTS_PER_MINUTE: int = 100;\n\nwalker RateLimiter {\n    has user_id: str;\n    can check with `root entry {\n        trackers = [here --> (`?RateLimitInfo)](?user_id == visitor.user_id);\n        tracker: RateLimitInfo;\n        if not trackers {\n            tracker = here ++> RateLimitInfo(user_id=visitor.user_id);\n        } else {\n            tracker = trackers[0];\n        }\n\n        now = time();\n        if now - tracker.window_start > 60 {\n            tracker.window_start = now;\n            tracker.count = 1;\n        } else {\n            tracker.count += 1;\n        }\n\n        commit(tracker);\n\n        if tracker.count > :g:MAX_REQUESTS_PER_MINUTE {\n            raise RateLimitExceeded(\"Rate limit exceeded\");\n        }\n        report {\"status\": \"allowed\"};\n    }\n}",
    "advanced_ai_stream_01": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef generate_poem(topic: str) -> str by llm(stream=True);\n\nwith entry {\n    full_poem: str = \"\";\n    for token in generate_poem(\"the ocean\") {\n        print(token, end=\"\");\n        full_poem += token;\n    }\n    print(\"\\n--- End of Poem ---\");\n}",
    "advanced_ai_multimodal_01": "import from byllm { Model, Image };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef analyze_image_content(image: Image) -> str by llm();\n\nwalker ImageProcessor {\n    has image_path: str;\n\n    can process with `root entry {\n        try {\n            img = Image(visitor.image_path);\n            description = analyze_image_content(img);\n            report description;\n        } except Exception as e {\n            report f\"Error processing image: {e}\";\n        }\n    }\n}",
    "advanced_ai_react_01": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef get_stock_price(symbol: str) -> float {\n    # Mock API call\n    if symbol == \"JAC\" { return 123.45; }\n    return 0.0;\n}\n\ndef execute_trade(symbol: str, quantity: int, action: str) -> str {\n    return f\"Executed {action} of {quantity} shares of {symbol}\";\n}\n\ndef trading_assistant(query: str) -> str by llm(\n    method='ReAct',\n    tools=[get_stock_price, execute_trade]\n);\n\nwith entry {\n    result = trading_assistant(\"What is the price of JAC stock, and then buy 10 shares?\");\n    print(result);\n}",
    "advanced_ai_structured_01": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nobj ContactInfo {\n    has name: str;\n    has email: str;\n    has phone: str | None;\n}\n\ndef extract_contact(text: str) -> ContactInfo by llm();\n\nwith entry {\n    bio = \"Meet Jane Doe. You can reach her at jane.doe@example.com.\";\n    contact = extract_contact(bio);\n    print(f\"Extracted Name: {contact.name}, Email: {contact.email}\");\n}",
    "advanced_graph_complex_filter_01": "node User { has name: str; has is_active: bool; }\nnode Post { has content: str; has likes: int; }\nedge Authored { has created_at: str; }\n\nwith entry {\n    # Assuming graph is populated\n    cutoff_date: str = \"2023-01-01\";\n    \n    results = [\n        `root --> (`?User)](?is_active == True) \n        ->:Authored:->(?created_at > cutoff_date)\n        (`?Post)](?likes > 100)\n    ];\n\n    for post in results {\n        print(f\"Found popular post: {post.id} with {post.likes} likes.\");\n    }\n}",
    "advanced_graph_pathfind_01": "import from math { inf };\n\nnode City { has name: str; }\nedge Road { has distance: int; }\n\nwalker ShortestPath {\n    has start_node: City;\n    has end_node: City;\n    has distances: dict = {};\n    has unvisited: set = set();\n\n    can find with City entry {\n        if here == visitor.start_node { visitor.distances[here] = 0; }\n\n        for edge in [here --->] {\n            neighbor = [edge -->][0];\n            if neighbor in visitor.unvisited {\n                new_dist = visitor.distances[here] + edge.distance;\n                if new_dist < visitor.distances.get(neighbor, inf) {\n                    visitor.distances[neighbor] = new_dist;\n                }\n            }\n        }\n        visitor.unvisited.remove(here);\n\n        if here == visitor.end_node {\n            report {\"path_found\": True, \"distance\": visitor.distances[here]};\n            disengage;\n        }\n\n        if visitor.unvisited {\n            next_node = min(visitor.unvisited, key=lambda n: visitor.distances.get(n, inf));\n            visit [next_node];\n        }\n    }\n}",
    "advanced_graph_cycle_01": "node Node { has name: str; }\n\nwalker CycleDetector {\n    has recursion_stack: list = [];\n    has visited: set = set();\n    has cycle_found: bool = False;\n\n    can detect with Node entry {\n        if visitor.cycle_found { disengage; }\n\n        visitor.recursion_stack.append(here);\n        visitor.visited.add(here);\n\n        for neighbor in [here -->] {\n            if neighbor in visitor.recursion_stack {\n                report f\"Cycle detected involving node {neighbor.name}\";\n                visitor.cycle_found = True;\n                disengage;\n            }\n            if neighbor not in visitor.visited {\n                visit [neighbor];\n            }\n        }\n        visitor.recursion_stack.pop();\n    }\n}",
    "advanced_persist_transaction_01": "node Account {\n    has name: str;\n    has balance: float;\n}\n\ndef transfer(from_acc: Account, to_acc: Account, amount: float) {\n    if from_acc.balance >= amount {\n        from_acc.balance -= amount;\n        to_acc.balance += amount;\n        save(from_acc);\n        save(to_acc);\n        commit();\n        print(\"Transfer successful.\");\n    } else {\n        print(\"Insufficient funds.\");\n    }\n}\n\nwith entry {\n    acc1 = Account(name=\"Alice\", balance=100.0);\n    acc2 = Account(name=\"Bob\", balance=50.0);\n    transfer(acc1, acc2, 25.0);\n}",
    "advanced_persist_reference_01": "node User {\n    has name: str;\n}\n\nwalker ProfileUpdater {\n    has user_id: str;\n    has new_name: str;\n\n    can update with `root entry {\n        user_ref = &visitor.user_id;\n        if user_ref {\n            user_ref.name = visitor.new_name;\n            commit(user_ref);\n            report user_ref;\n        }\n    }\n}\n\nwith entry {\n    user = `root ++> User(name=\"Initial Name\");\n    commit();\n    `root spawn ProfileUpdater(user_id=user.id, new_name=\"Updated Name\");\n}",
    "advanced_cloud_webhook_01": "walker GithubWebhookHandler {\n    obj __specs__ {\n        static has webhook: dict = {\n            \"type\": \"header\",\n            \"name\": \"X-Hub-Signature-256\"\n        };\n    }\n\n    can handle_push with `root entry {\n        # 'here' contains the webhook payload\n        commits = here.body[\"commits\"];\n        report f\"Received push with {len(commits)} commits.\";\n    }\n}",
    "advanced_cloud_async_retrieve_01": "async walker DataProcessor {\n    has data: list;\n    can process with `root entry {\n        # Simulate heavy processing\n        processed_data = [item * 2 for item in visitor.data];\n        report processed_data;\n    }\n}\n\nwith entry {\n    task_id = `root spawn DataProcessor(data=[1, 2, 3, 4, 5]);\n    task = &task_id;\n    \n    # In a real scenario, you would poll this status\n    print(f\"Task {task.id} status: {task.__jac__.status}\");\n    # To get results when done:\n    # print(f\"Task results: {task.__jac__.reports}\");\n}",
    "advanced_cloud_query_params_01": "walker ProductSearch {\n    has query: str;\n    has category: str | None = None;\n    has limit: int = 20;\n\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has auth: bool = False;\n        static has as_query: list = [\"query\", \"category\", \"limit\"];\n    }\n\n    can search with `root entry {\n        report f\"Searching for '{visitor.query}' in category '{visitor.category}' with limit {visitor.limit}\";\n    }\n}",
    "integration_error_handling_01": "class DivisionByZeroError(Exception) { pass; }\n\ndef safe_divide(a: int, b: int) -> float {\n    if b == 0 {\n        raise DivisionByZeroError(\"Cannot divide by zero\");\n    }\n    return a / b;\n}\n\nwalker Calculator {\n    has num1: int;\n    has num2: int;\n    can calculate with `root entry {\n        try {\n            result = safe_divide(visitor.num1, visitor.num2);\n            report {\"result\": result};\n        } except DivisionByZeroError as e {\n            print(f\"Logging error: {e}\");\n            report {\"error\": f\"{e}\", \"fallback_value\": -1.0};\n        }\n    }\n}",
    "integration_external_api_01": "import requests;\n\nwalker ApiFetcher {\n    has url: str;\n    can fetch with `root entry {\n        try {\n            response = requests.get(visitor.url);\n            response.raise_for_status(); // Raises an exception for 4xx/5xx errors\n            report response.json();\n        } except requests.exceptions.HTTPError as http_err {\n            report {\"error\": \"HTTP error occurred\", \"details\": f\"{http_err}\"};\n        } except Exception as err {\n            report {\"error\": \"An unexpected error occurred\", \"details\": f\"{err}\"};\n        }\n    }\n}",
    "integration_conditional_visit_01": "node Directory { has name: str; }\n\nwalker FileSystemCrawler {\n    has path: list = [];\n    can crawl with Directory entry {\n        visitor.path.append(here.name);\n        print(f\"Entering: {'/'.join(visitor.path)}\");\n        \n        visit [here -->] else {\n            print(f\"Leaf directory reached: {'/'.join(visitor.path)}\");\n            disengage;\n        };\n    }\n}",
    "integration_multi_ability_01": "walker LoggerWalker {\n    has log: list = [];\n}\n\nnode MonitoredResource {\n    has name: str;\n\n    can on_enter with LoggerWalker entry {\n        visitor.log.append(f\"[ENTRY] Walker arrived at {here.name}\");\n        print(f\"Processing {here.name}...\");\n    }\n\n    can on_exit with LoggerWalker exit {\n        visitor.log.append(f\"[EXIT] Walker is leaving {here.name}\");\n    }\n}",
    "integration_batch_process_01": "node DataRecord {\n    has data: str;\n    has is_processed: bool = False;\n}\n\nwalker BatchProcessor {\n    can process_all with `root entry {\n        records_to_process = [here --> (`?DataRecord)](?is_processed == False);\n        if not records_to_process {\n            report \"No records to process.\";\n            return;\n        }\n        for record in records_to_process {\n            record.is_processed = True;\n            save(record);\n        }\n        commit();\n        report f\"Successfully processed {len(records_to_process)} records.\";\n    }\n}",
    "integration_visitor_communication_01": "walker PathTracer {\n    has path_taken: list = [];\n}\n\nnode Waypoint {\n    has name: str;\n    can trace with PathTracer entry {\n        visitor.path_taken.append(here.name);\n    }\n}\n\nwith entry {\n    start = Waypoint(name=\"Start\");\n    middle = Waypoint(name=\"Middle\");\n    end = Waypoint(name=\"End\");\n    start ++> middle ++> end;\n\n    tracer = PathTracer();\n    start spawn tracer;\n    visit [start-->-->];\n    print(tracer.path_taken);\n}",
    "integration_root_ability_01": "node Config { has settings: dict; }\n\nwalker ConfigInitializer {\n    can setup with `root entry {\n        configs = [here --> (`?Config)];\n        if not configs {\n            print(\"No config found, creating default.\");\n            default_settings = {\"theme\": \"dark\", \"notifications\": True};\n            config = here ++> Config(settings=default_settings);\n            report config;\n        } else {\n            report configs[0];\n        }\n    }\n}",
    "integration_edge_traversal_01": "node User { has name: str; }\nedge Follows { has strength: float; }\n\nwalker FollowsAnalyzer {\n    can analyze with User entry {\n        total_strength: float = 0.0;\n        outgoing_follows = [here ---> (`?Follows)];\n        \n        for follow_edge in outgoing_follows {\n            total_strength += follow_edge.strength;\n        }\n        \n        report {\n            \"user\": here.name,\n            \"following_count\": len(outgoing_follows),\n            \"total_strength\": total_strength\n        };\n    }\n}"
  }
}