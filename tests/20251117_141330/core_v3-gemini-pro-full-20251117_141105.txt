{
  "metadata": {
    "model": "gemini/gemini-2.5-pro-preview-03-25",
    "model_alias": "gemini-pro",
    "variant": "core_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {PENDING, ACTIVE, COMPLETED};",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    };\n}",
    "basic_06": "#* This is a\nmulti-line comment. *#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    greeting: str = f\"Hello, {name}!\";\n    print(greeting);\n}",
    "basic_08": "has value: str | int = \"hello\";",
    "basic_09": "with entry {\n    squares: list[int] = [x*x for x in range(1, 6)];\n    print(squares);\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"Positive\");\n    } elif num < 0 {\n        print(\"Negative\");\n    } else {\n        print(\"Zero\");\n    };\n}",
    "control_01": "with entry {\n    count: int = 1;\n    while count <= 5 {\n        print(count);\n        count += 1;\n    };\n}",
    "control_02": "with entry {\n    status: str = \"active\";\n    match status {\n        case \"active\": print(\"Processing\");\n        case \"pending\": print(\"Waiting\");\n        case _: print(\"Unknown status\");\n    };\n}",
    "control_03": "with entry {\n    for i in range(10) {\n        if i == 5 {\n            break;\n        };\n        print(i);\n    };\n}",
    "control_04": "with entry {\n    for i in range(10) {\n        if i % 2 == 0 {\n            continue;\n        };\n        print(i);\n    };\n}",
    "collection_01": "with entry {\n    numbers: set[int] = {1, 2, 3};\n    numbers.add(4);\n    print(numbers);\n}",
    "collection_02": "person: tuple[str, int] = (\"Alice\", 30);",
    "collection_03": "with entry {\n    squares: dict[int, int] = {x: x*x for x in range(1, 6)};\n    print(squares);\n}",
    "collection_04": "with entry {\n    items: list[str] = [\"apple\", \"banana\", \"cherry\"];\n    for item in items {\n        print(item);\n    };\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n    bob_age: int|None = ages.get(\"Bob\");\n    print(bob_age);\n}",
    "type_01": "with entry {\n    value: any = \"hello\";\n    if isinstance(value, str) {\n        print(\"It is a string.\");\n    };\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.year} {self.brand}\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    def postinit {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "square = lambda x: int: x * x;",
    "obj_06": "obj SecretContainer {\n    has _secret_key: str;\n}",
    "obj_07": "obj PublicData {\n    has public_info: str;\n}",
    "obj_08": "def simple_decorator(func: callable) -> callable {\n    def wrapper() {\n        print(\"Before function call\");\n        func();\n        print(\"After function call\");\n    }\n    return wrapper;\n}\n\n@simple_decorator\ndef say_hello() {\n    print(\"Hello!\");\n}",
    "obj_09": "def execute_callback(callback: callable[[], None]) {\n    callback();\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City { has name: str; }\nwith entry {\n    sf: City = City(name=\"San Francisco\");\n    la: City = City(name=\"Los Angeles\");\n    sf <++> la;\n}",
    "graph_03": "node City { has name: str; }\nedge Road { has distance: float; }\nwith entry {\n    nyc: City = City(name=\"New York\");\n    boston: City = City(name=\"Boston\");\n    nyc +>:Road:distance=215.0:+> boston;\n}",
    "graph_04": "walker BasicWalker {}\nnode Checkpoint {\n    can check with BasicWalker entry {\n        print(\"Checkpoint reached!\");\n    }\n}",
    "graph_05": "walker Inspector { has id: int; }\nnode DataPoint {\n    has value: str;\n    can inspect with Inspector entry {\n        print(f\"Walker {visitor.id} is inspecting {here.value}\");\n    }\n}",
    "graph_06": "node Person { has name: str; }\nwith entry {\n    alice: Person = Person(name=\"Alice\");\n    bob: Person = Person(name=\"Bob\");\n    alice ++> bob;\n}",
    "graph_07": "node User { has name: str; }\nwith entry {\n    new_user: User = User(name=\"Genesis\");\n    root ++> new_user;\n}",
    "graph_08": "walker Traveler {}\nnode Station {\n    can depart with Traveler exit {\n        print(\"Traveler is leaving the station.\");\n    }\n}",
    "graph_09": "walker Patroller {}\nedge TollBridge {\n    can cross with Patroller entry {\n        print(\"Patroller is crossing the bridge.\");\n    }\n}",
    "graph_10": "node Step { has name: str; }\nwith entry {\n    step1: Step = Step(name=\"A\");\n    step2: Step = Step(name=\"B\");\n    step3: Step = Step(name=\"C\");\n    step1 ++> step2 ++> step3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "walker SimpleCrawler {\n    can crawl with entry {\n        visit [here -->];\n    }\n}",
    "walker_03": "node User {}\nwalker UserFinder {\n    can find_users with entry {\n        visit [here --> (`?User)];\n    }\n}",
    "walker_04": "walker Inspector {\n    can inspect with entry {\n        print(here);\n    }\n}",
    "walker_05": "node Item { has name: str; }\nwalker ItemReporter {\n    can report_item with Item entry {\n        report here.name;\n    }\n}",
    "walker_06": "node MyNode {};\nwalker MyWalker {};\nwith entry {\n    my_node = MyNode();\n    my_node spawn MyWalker();\n}",
    "walker_07": "walker MyWalker {};\nwith entry {\n    root spawn MyWalker();\n}",
    "walker_08": "walker InwardWalker {\n    can traverse with entry {\n        visit [<-- here];\n    }\n}",
    "walker_09": "walker ExitingWalker {\n    has log: list = [];\n    can leave with exit {\n        self.log.append(\"Exited node\");\n    }\n}",
    "walker_10": "walker NodeReporter {\n    can report_location with entry {\n        report here;\n    }\n}",
    "advanced_01": "node Item {\n    has price: int;\n}\nwalker PriceChecker {\n    can find_cheap with entry {\n        visit [here --> (`?Item)](?price < 10);\n    }\n}",
    "advanced_02": "edge Follows {};\nwalker FollowerFinder {\n    can find_follows with entry {\n        visit [here ->:Follows:->];\n    }\n}",
    "advanced_03": "walker DeepDiver {\n    can dive with entry {\n        visit [here --> --> -->];\n    }\n}",
    "advanced_04": "node DataNode {\n    has is_done: bool;\n};\n\nwalker EarlyExit {\n    can check with DataNode entry {\n        if here.is_done {\n            disengage;\n        };\n    }\n}",
    "advanced_05": "walker Traveler {\n    has balance: float = 100.0;\n    def pay(self, amount: float) {\n        self.balance -= amount;\n    }\n}\n\nedge TollRoad {\n    has toll: float = 5.0;\n    can charge with Traveler entry {\n        visitor.pay(self.toll);\n    }\n}",
    "advanced_06": "walker DFS {\n    has visited: set = set();\n    can search with Node entry {\n        if here not in self.visited {\n            self.visited.add(here);\n            for child in [here -->] {\n                visit [child];\n            }\n        }\n    }\n}",
    "advanced_07": "walker MultiVisitor {\n    has targets: list;\n    can visit_all with entry {\n        visit [self.targets];\n    }\n}",
    "advanced_08": "node Person {\n    has age: int;\n};\n\nwalker AdultFinder {\n    can find_adults with entry {\n        visit [here --> (`?Person)](?age > 18);\n    }\n}",
    "advanced_09": "edge Connection {\n    has weight: int;\n};\n\nwalker StrongLinkFinder {\n    can find_strong with entry {\n        visit [here ->:Connection:weight > 5:->];\n    }\n}",
    "advanced_10": "node Node {};\nwith entry {\n    node1 = Node();\n    node2 = Node();\n    node1 ++> node2;\n    node1 del --> node2;\n}",
    "ai_01": "import from byllm { Model };",
    "ai_02": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm { Model };\nglob llm: Model = Model();\ndef generate_greeting(name: str) -> str by llm();",
    "ai_04": "obj User {\n    has name: str;\n};\nsem User.name = \"The full name of the user.\";",
    "ai_05": "import from byllm { Model };\nglob llm: Model = Model();\nenum Sentiment { POSITIVE, NEGATIVE, NEUTRAL };\ndef analyze(text: str) -> Sentiment by llm();",
    "ai_06": "import from byllm { Model };\nglob llm: Model = Model();\ndef solve_math(problem: str) -> str by llm(method='Reason');",
    "ai_07": "import from byllm { Model };\nglob llm: Model = Model();\ndef get_weather(city: str) -> str {\n    return \"Sunny\";\n}\ndef assistant(question: str) -> str by llm(method='ReAct', tools=[get_weather]);",
    "ai_08": "import from byllm { Image };",
    "ai_09": "import from byllm { Model };\nglob llm: Model = Model();\nobj Document {\n    has content: str;\n    def summarize(self) -> str by llm();\n}",
    "ai_10": "import from byllm { Model };\nglob llm: Model = Model();\nobj UserInfo {\n    has name: str;\n    has city: str;\n}\ndef extract_user(text: str) -> UserInfo by llm();",
    "cloud_01": "walker UserCreator {\n    has name: str;\n    obj __specs__ {\n        static has methods: list = [\"get\", \"post\"];\n    }\n}",
    "cloud_02": "walker PublicInfo {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n}",
    "cloud_03": "walker CustomEndpoint {\n    obj __specs__ {\n        static has path: str = \"/api/v1/custom\";\n    }\n}",
    "cloud_04": "walker Searcher {\n    has query: str;\n    has category: str;\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has as_query: list = [\"*\"];\n    }\n}",
    "cloud_05": "walker InternalTask {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n}",
    "cloud_06": "async walker HeavyComputation {\n    has data: list;\n    can process with `root entry {\n        for item in self.data {\n            compute(item);\n        };\n    }\n}",
    "cloud_07": "with entry {\n    task_id: str = \"wlk::123abc\";\n    task_ref = &task_id;\n}",
    "cloud_08": "walker WebhookReceiver {\n    obj __specs__ {\n        static has webhook: dict = {\"type\": \"header\", \"name\": \"X-Webhook-Signature\"};\n    };\n    can handle with `root entry {\n        report here;\n    };\n}",
    "cloud_09": "node PersistentData {\n    has value: str;\n};\nwith entry {\n    data = PersistentData(value=\"important\");\n    root ++> data;\n}",
    "cloud_10": "obj User {\n    has name: str;\n};\n\nwalker GetUser {\n    has user_id: str;\n    can find with `root entry {\n        user = &self.user_id;\n        report user;\n    };\n}",
    "import_01": "import math;",
    "import_02": "import from math { sqrt, pow };",
    "import_03": "import my_module;",
    "import_04": "import math as m;",
    "file_01": "with entry {\n    with open(\"data.txt\", \"r\") as f {\n        content: str = f.read();\n    };\n}",
    "file_02": "with entry {\n    with open(\"output.txt\", \"w\") as f {\n        f.write(\"Hello, Jac!\");\n    };\n}",
    "file_03": "import json;\nwith entry {\n    with open(\"config.json\", \"r\") as f {\n        data: dict = json.load(f);\n    };\n}",
    "impl_01": "obj Calculator {\n    def add(self, a: int, b: int) -> int;\n};\n\nimpl Calculator.add(self, a: int, b: int) -> int {\n    return a + b;\n}",
    "advanced_func_01": "def sum_all(*nums: int) -> int {\n    return sum(nums);\n}",
    "advanced_func_02": "def create_user(**details: any) -> dict {\n    return details;\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since: str;\n}\n\nwalker SocialGraphWalker {\n    has visited: set = set();\n    can traverse with Person entry {\n        if here not in visitor.visited {\n            visitor.visited.add(here);\n            report here;\n            visit [here -->(`?Person)];\n        }\n    }\n}\n\nwith entry {\n    alice = Person(name=\"Alice\");\n    bob = Person(name=\"Bob\");\n    charlie = Person(name=\"Charlie\");\n\n    alice +>:Friendship:since=\"2022\":+> bob;\n    bob +>:Friendship:since=\"2023\":+> charlie;\n\n    alice spawn SocialGraphWalker();\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nedge Transition {\n    has on_event: str;\n}\n\nwalker StateMachine {\n    has event: str;\n    can process with State entry {\n        report f\"Current state: {here.name}\";\n        transitions = [here ->:Transition:->](?on_event == visitor.event);\n        if transitions {\n            next_state = [transitions[0] -->][0];\n            visit [next_state];\n        } else {\n            report \"End of transition\";\n            disengage;\n        }\n    }\n}\n\nwith entry {\n    pending = State(name=\"PENDING\");\n    active = State(name=\"ACTIVE\");\n    done = State(name=\"DONE\");\n\n    pending +>:Transition:on_event=\"start\":+> active;\n    active +>:Transition:on_event=\"finish\":+> done;\n\n    pending spawn StateMachine(event=\"start\");\n}",
    "integration_03": "walker SafeDivider {\n    has a: int;\n    has b: int;\n\n    can divide with `root entry {\n        try {\n            result = visitor.a / visitor.b;\n            report result;\n        } except ZeroDivisionError {\n            report \"Error: Cannot divide by zero.\";\n        }\n    }\n}\n\nwith entry {\n    root spawn SafeDivider(a=10, b=0);\n}",
    "integration_04": "import from asyncio;\n\nasync def fetch_data() -> str {\n    await asyncio.sleep(0.1);\n    return \"Data fetched asynchronously\";\n}\n\nwith entry {\n    result = asyncio.run(fetch_data());\n    print(result);\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker CrudManager {\n    has action: str;\n    has item_id: str | None = None;\n    has name: str | None = None;\n    has value: int | None = None;\n\n    can manage with `root entry {\n        match visitor.action {\n            case \"create\": {\n                new_item = here ++> Item(name=visitor.name, value=visitor.value);\n                commit();\n                report new_item;\n            }\n            case \"read\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items { report items[0]; }\n            }\n            case \"update\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    items[0].name = visitor.name;\n                    commit(items[0]);\n                    report items[0];\n                }\n            }\n            case \"delete\": {\n                items = [here --> (`?Item)](?id == visitor.item_id);\n                if items {\n                    del items[0];\n                    commit();\n                    report \"Deleted\";\n                }\n            }\n        }\n    }\n}",
    "integration_06": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nnode Document {\n    has content: str;\n}\n\ndef summarize(text: str) -> str by llm();\n\nwalker SummarizeGraph {\n    can process with Document entry {\n        summary = summarize(here.content);\n        report {\"id\": here.id, \"summary\": summary};\n        visit [here -->];\n    }\n}\n\nwith entry {\n    doc1 = Document(content=\"Jac is a new programming language.\");\n    doc2 = Document(content=\"It is a superset of Python.\");\n    root ++> doc1 ++> doc2;\n    root spawn SummarizeGraph();\n}",
    "integration_07": "node User {\n    has name: str;\n    has email: str;\n}\n\nwalker create_user {\n    has name: str;\n    has email: str;\n\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has auth: bool = False;\n    }\n\n    can create with `root entry {\n        new_user = here ++> User(name=visitor.name, email=visitor.email);\n        report new_user;\n    }\n}",
    "integration_08": "node Node {}\n\nwalker BFS {\n    has queue: list = [];\n    has visited: set = set();\n\n    can search with Node entry {\n        if here not in visitor.visited {\n            visitor.visited.add(here);\n            report here;\n            visitor.queue.extend([here -->]);\n        }\n        if visitor.queue {\n            visit [visitor.queue.pop(0)];\n        } else {\n            disengage;\n        }\n    }\n}",
    "integration_09": "walker Processor {\n    has log: list = [];\n}\n\nnode Step {\n    has name: str;\n    has status: str = \"pending\";\n\n    can start with Processor entry {\n        here.status = \"running\";\n        visitor.log.append(f\"Started {here.name}\");\n    }\n\n    can complete with Processor exit {\n        here.status = \"done\";\n        visitor.log.append(f\"Completed {here.name}\");\n    }\n}\n\nwith entry {\n    step1 = Step(name=\"Step 1\");\n    step2 = Step(name=\"Step 2\");\n    root ++> step1 ++> step2;\n    p = root spawn Processor();\n    visit [root --> (`?Step)];\n    print(p.log);\n}",
    "integration_10": "node User { has name: str; }\nnode Movie { has title: str; }\nedge Watched { has rating: int; }\nedge Friend {}\n\nwalker Recommender {\n    has user_id: str;\n    can recommend with `root entry {\n        user = &visitor.user_id;\n        watched_movies = [user -->:Watched:-> (`?Movie)];\n        friends_watched = [user -->:Friend:-> (`?User) -->:Watched:-> (`?Movie)];\n        recommendations = [m for m in friends_watched if m not in watched_movies];\n        report recommendations;\n    }\n}",
    "prod_websocket_01": "import from jac_cloud.plugin { WEBSOCKET_MANAGER as socket };\n\nwalker Broadcaster {\n    has channel_name: str;\n    has message: str;\n\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can broadcast with `root entry {\n        socket.notify_channels([visitor.channel_name], {\"text\": visitor.message});\n        report \"Message sent to channel\";\n    }\n}",
    "prod_permissions_01": "node Document {\n    has owner_id: str;\n    has is_public: bool = False;\n\n    def __jac_access__(self) -> AccessLevel {\n        if here.is_public {\n            return ReadPerm;\n        }\n        if _Jac.get_root().id == here.owner_id {\n            return WritePerm;\n        }\n        return NoPerm;\n    }\n}",
    "prod_cache_01": "import from time { time };\n\nnode CacheEntry {\n    has key: str;\n    has value: any;\n    has expires_at: float;\n}\n\ndef expensive_computation(key: str) -> str {\n    return f\"Computed value for {key} at {time()}\";\n}\n\nwalker CacheManager {\n    has key: str;\n    can get with `root entry {\n        cached_items = [here --> (`?CacheEntry)](?key == visitor.key);\n        if cached_items and cached_items[0].expires_at > time() {\n            report cached_items[0].value;\n        } else {\n            if cached_items {\n                del cached_items[0];\n            }\n            new_value = expensive_computation(visitor.key);\n            here ++> CacheEntry(key=visitor.key, value=new_value, expires_at=time() + 3600);\n            report new_value;\n        }\n    }\n}",
    "prod_validation_01": "walker UserCreator {\n    has username: str;\n    has age: int;\n\n    can create with `root entry {\n        if len(visitor.username) < 3 {\n            raise ValueError(\"Username must be at least 3 characters.\");\n        }\n        if visitor.age < 18 {\n            raise ValueError(\"User must be 18 or older.\");\n        }\n        report {\"status\": \"valid\", \"username\": visitor.username};\n    }\n}",
    "prod_pagination_01": "node Item { has name: str; has category: str; }\n\nwalker ListItems {\n    has page: int = 1;\n    has per_page: int = 10;\n    has category_filter: str | None = None;\n\n    can list with `root entry {\n        all_items = [here --> (`?Item)];\n        if visitor.category_filter {\n            all_items = [i for i in all_items if i.category == visitor.category_filter];\n        }\n        total = len(all_items);\n        start = (visitor.page - 1) * visitor.per_page;\n        end = start + visitor.per_page;\n        report {\"items\": all_items[start:end], \"total\": total, \"page\": visitor.page};\n    }\n}",
    "prod_scheduler_01": "walker DailyReportGenerator {\n    obj __specs__ {\n        static has private: bool = True;\n        static has schedule: dict = {\n            \"trigger\": \"cron\",\n            \"hour\": \"9\",\n            \"minute\": \"0\",\n            \"save\": True\n        };\n    }\n\n    can generate with `root entry {\n        report \"Generating daily report...\";\n    }\n}",
    "prod_versioning_01": "import from time { time };\n\nnode Document {\n    has content: str;\n    has version: int = 1;\n}\n\nnode DocumentVersion {\n    has content: str;\n    has version: int;\n    has created_at: float;\n}\n\nwalker UpdateDocument {\n    has doc_id: str;\n    has new_content: str;\n\n    can update with `root entry {\n        doc = &visitor.doc_id;\n        if doc {\n            doc ++> DocumentVersion(content=doc.content, version=doc.version, created_at=time());\n            doc.version += 1;\n            doc.content = visitor.new_content;\n            commit();\n            report doc;\n        }\n    }\n}",
    "prod_softdelete_01": "import from time { time };\n\nnode Post {\n    has title: str;\n    has is_deleted: bool = False;\n    has deleted_at: float | None = None;\n}\n\nwalker PostManager {\n    has action: str;\n    has post_id: str | None = None;\n\n    can manage with `root entry {\n        if visitor.action == \"delete\" {\n            post = &visitor.post_id;\n            post.is_deleted = True;\n            post.deleted_at = time();\n            commit(post);\n            report \"Post soft deleted\";\n        } elif visitor.action == \"list\" {\n            active_posts = [here --> (`?Post)](?is_deleted == False);\n            report active_posts;\n        }\n    }\n}",
    "prod_audit_01": "import from time { time };\n\nnode AuditLog {\n    has user_id: str;\n    has action: str;\n    has timestamp: float;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    has user_id: str;\n    has action: str;\n    has details: dict;\n\n    can log with `root entry {\n        log_entry = here ++> AuditLog(\n            user_id=visitor.user_id,\n            action=visitor.action,\n            timestamp=time(),\n            details=visitor.details\n        );\n        report log_entry;\n    }\n}",
    "prod_ratelimit_01": "import from time { time };\n\nglob MAX_REQUESTS: int = 100;\nglob WINDOW_SECONDS: int = 60;\n\nnode RateLimitInfo {\n    has user_id: str;\n    has count: int = 0;\n    has window_start: float = 0.0;\n}\n\nwalker RateLimiter {\n    has user_id: str;\n    can check with `root entry {\n        limit_infos = [here --> (`?RateLimitInfo)](?user_id == visitor.user_id);\n        limit_info: RateLimitInfo;\n        if not limit_infos {\n            limit_info = here ++> RateLimitInfo(user_id=visitor.user_id, window_start=time());\n        } else {\n            limit_info = limit_infos[0];\n        }\n\n        if time() - limit_info.window_start > :g:WINDOW_SECONDS {\n            limit_info.window_start = time();\n            limit_info.count = 1;\n        } else {\n            limit_info.count += 1;\n        }\n\n        if limit_info.count > :g:MAX_REQUESTS {\n            raise Exception(\"Rate limit exceeded\");\n        }\n        commit(limit_info);\n        report \"Request permitted\";\n    }\n}",
    "advanced_ai_stream_01": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef generate_story(prompt: str) -> str by llm(stream=True);\n\nwith entry {\n    full_story: str = \"\";\n    for token in generate_story(\"Write a short story about a robot.\") {\n        full_story += token;\n    }\n    print(full_story);\n}",
    "advanced_ai_multimodal_01": "import from byllm { Model, Image };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef describe_image(image: Image) -> str by llm();\n\nwalker ImageAnalyzer {\n    has image_path: str;\n    can analyze with `root entry {\n        img = Image(visitor.image_path);\n        description = describe_image(img);\n        report description;\n    }\n}",
    "advanced_ai_react_01": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\ndef get_stock_price(symbol: str) -> float {\n    # Mock function\n    if symbol == \"JAC\" { return 100.0; }\n    return 0.0;\n}\n\ndef execute_trade(symbol: str, quantity: int, action: str) -> str {\n    # Mock function\n    return f\"Executed {action} of {quantity} shares of {symbol}\";\n}\n\ndef trading_assistant(query: str) -> str by llm(method='ReAct', tools=[get_stock_price, execute_trade]);\n\nwith entry {\n    response = trading_assistant(\"What is the price of JAC and then buy 10 shares?\");\n    print(response);\n}",
    "advanced_ai_structured_01": "import from byllm { Model };\n\nglob llm = Model(model_name=\"gpt-4o\");\n\nobj EventDetails {\n    has title: str;\n    has date: str;\n    has location: str;\n}\n\ndef extract_event(text: str) -> EventDetails by llm();\n\nwith entry {\n    text = \"The annual Jac conference is on 2024-10-26 in San Francisco.\";\n    event = extract_event(text);\n    report event;\n}",
    "advanced_graph_complex_filter_01": "node User { has name: str; has is_active: bool; }\nnode Post { has likes: int; }\nedge Authored { has created_at: str; }\n\nwith entry {\n    # Assume graph is populated\n    active_users_popular_posts = [\n        root --> (`?User)](?is_active == True)\n             ->:Authored:-> (`?Post)](?likes > 100);\n    report active_users_popular_posts;\n}",
    "advanced_graph_pathfind_01": "node City { has name: str; }\nedge Road { has weight: int; }\n\nwalker Dijkstra {\n    has distances: dict;\n    has unvisited: set;\n    has target: node;\n\n    can find_path with Node entry {\n        for edge in [here --->] {\n            neighbor = [edge -->][0];\n            if neighbor in visitor.unvisited {\n                new_dist = visitor.distances[here] + edge.weight;\n                if new_dist < visitor.distances.get(neighbor, 999999) {\n                    visitor.distances[neighbor] = new_dist;\n                }\n            }\n        }\n        visitor.unvisited.remove(here);\n\n        if here == visitor.target {\n            report visitor.distances[visitor.target];\n            disengage;\n        }\n\n        if visitor.unvisited {\n            next_node = min(visitor.unvisited, key=lambda n: visitor.distances.get(n, 999999));\n            visit [next_node];\n        }\n    }\n}",
    "advanced_graph_cycle_01": "node Node {}\n\nwalker CycleDetector {\n    has visited: set = set();\n    has recursion_stack: list = [];\n    has cycle_found: bool = False;\n\n    can detect with Node entry {\n        if here in visitor.recursion_stack {\n            visitor.cycle_found = True;\n            report f\"Cycle detected involving {here}\";\n            disengage;\n            return;\n        }\n        if here in visitor.visited { return; }\n\n        visitor.visited.add(here);\n        visitor.recursion_stack.append(here);\n        visit [here -->];\n        visitor.recursion_stack.pop();\n    }\n}",
    "advanced_persist_transaction_01": "node Account {\n    has name: str;\n    has balance: float;\n}\n\nwith entry {\n    account1 = Account(name=\"Alice\", balance=1000.0);\n    account2 = Account(name=\"Bob\", balance=500.0);\n\n    # Transfer 100 from Alice to Bob\n    account1.balance -= 100.0;\n    account2.balance += 100.0;\n\n    save(account1);\n    save(account2);\n    commit();\n\n    report \"Transaction committed\";\n}",
    "advanced_persist_reference_01": "node User {\n    has name: str;\n}\n\nwith entry {\n    user = User(name=\"John\");\n    save(user);\n    commit();\n\n    user_id_str = user.id;\n\n    # In a different context, retrieve and update\n    retrieved_user = &user_id_str;\n    retrieved_user.name = \"John Doe\";\n    commit(retrieved_user);\n\n    report retrieved_user.name;\n}",
    "advanced_cloud_webhook_01": "walker GithubWebhookHandler {\n    obj __specs__ {\n        static has webhook: dict = {\n            \"type\": \"header\",\n            \"name\": \"X-Hub-Signature-256\"\n        };\n    }\n\n    can handle with `root entry {\n        # Process webhook payload from visitor context\n        report \"Webhook received and authenticated.\";\n    }\n}",
    "advanced_cloud_async_retrieve_01": "async walker DataProcessor {\n    has data: list;\n    can process with `root entry {\n        # Simulate heavy work\n        processed_data = [i * 2 for i in visitor.data];\n        report processed_data;\n    }\n}\n\nwith entry {\n    task_id = root spawn DataProcessor(data=[1, 2, 3, 4, 5]);\n\n    # Later, check the status\n    task = &task_id;\n    status = task.__jac__.status;\n    reports = task.__jac__.reports;\n\n    report {\"status\": status, \"reports\": reports};\n}",
    "advanced_cloud_query_params_01": "walker ProductSearch {\n    has query: str;\n    has brand: str;\n    has limit: int = 20;\n\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has auth: bool = False;\n        static has as_query: list = [\"query\", \"limit\"];\n    }\n\n    can search with `root entry {\n        # 'brand' will be in the JSON body\n        # 'query' and 'limit' will be from URL query params\n        report f\"Searching for {visitor.query} from {visitor.brand}, limit {visitor.limit}\";\n    }\n}",
    "integration_error_handling_01": "class InvalidDataError(Exception) { pass; }\n\ndef process_data(data: dict) -> bool {\n    if \"id\" not in data {\n        raise InvalidDataError(\"Missing 'id' field\");\n    }\n    return True;\n}\n\nwalker SafeProcessor {\n    has data: dict;\n    can process with `root entry {\n        try {\n            result = process_data(visitor.data);\n            report {\"status\": \"success\", \"result\": result};\n        } except InvalidDataError as e {\n            print(f\"Caught error: {e}\");\n            report {\"status\": \"error\", \"message\": str(e)};\n        }\n    }\n}",
    "integration_external_api_01": "import from requests;\n\nwalker ApiClient {\n    has url: str;\n    can fetch with `root entry {\n        try {\n            response = requests.get(visitor.url);\n            response.raise_for_status(); // Raises HTTPError for bad responses\n            report response.json();\n        } except requests.exceptions.RequestException as e {\n            report {\"error\": f\"API request failed: {e}\"};\n        }\n    }\n}",
    "integration_conditional_visit_01": "node FileNode { has name: str; }\n\nwalker FileFinder {\n    has target_name: str;\n    can find with FileNode entry {\n        if here.name == visitor.target_name {\n            report here;\n            disengage;\n        }\n        visit [here -->] else {\n            report \"Target not found in this branch\";\n            disengage;\n        };\n    }\n}",
    "integration_multi_ability_01": "walker Auditor {\n    has log: list = [];\n}\n\nnode MonitoredResource {\n    has name: str;\n\n    can on_access with Auditor entry {\n        visitor.log.append(f\"ACCESS_START: {here.name}\");\n    }\n\n    can on_leave with Auditor exit {\n        visitor.log.append(f\"ACCESS_END: {here.name}\");\n    }\n}",
    "integration_batch_process_01": "node Invoice {\n    has amount: float;\n    has is_paid: bool = False;\n}\n\nwalker PaymentProcessor {\n    can process_payments with `root entry {\n        unpaid_invoices = [here --> (`?Invoice)](?is_paid == False);\n        for invoice in unpaid_invoices {\n            invoice.is_paid = True;\n            save(invoice);\n        }\n        if unpaid_invoices {\n            commit();\n            report f\"Processed {len(unpaid_invoices)} invoices.\";\n        } else {\n            report \"No invoices to process.\";\n        }\n    }\n}",
    "integration_visitor_communication_01": "walker PathTracer {\n    has path_taken: list = [];\n}\n\nnode Waypoint {\n    has name: str;\n    can record_visit with PathTracer entry {\n        visitor.path_taken.append(here.name);\n    }\n}\n\nwith entry {\n    a = Waypoint(name=\"A\");\n    b = Waypoint(name=\"B\");\n    c = Waypoint(name=\"C\");\n    root ++> a ++> b ++> c;\n\n    tracer = root spawn PathTracer();\n    visit [root --> (`?Waypoint)];\n    report tracer.path_taken;\n}",
    "integration_root_ability_01": "walker Initializer {\n    has config: dict;\n    can setup with `root entry {\n        report \"Initializing application at root.\";\n        here.config = visitor.config;\n        commit(here);\n    }\n    can operate with Node entry {\n        skip;\n    }\n}\n\nwith entry {\n    root spawn Initializer(config={\"version\": \"1.0\"});\n}",
    "integration_edge_traversal_01": "node User { has name: str; }\nedge Follows { has since: str; }\n\nwalker FollowsInspector {\n    has user_id: str;\n    can inspect with `root entry {\n        user = &visitor.user_id;\n        if user {\n            outgoing_follows = [user --->:Follows:->];\n            report f\"{user.name} follows {len(outgoing_follows)} users.\";\n            for edge in [user --->] {\n                if isinstance(edge, Follows) {\n                    followed_user = [edge -->][0];\n                    report f\"- Follows {followed_user.name} since {edge.since}\";\n                }\n            }\n        }\n    }\n}"
  }
}