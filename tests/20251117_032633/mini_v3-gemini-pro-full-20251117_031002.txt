{
  "metadata": {
    "model": "gemini/gemini-2.5-pro-preview-03-25",
    "model_alias": "gemini-pro",
    "variant": "mini_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n}",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#* \nThis is a multi-line comment.\nIt can span several lines.\n*#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    message: str = f\"Hello, {name}!\";\n    print(message);\n}",
    "basic_08": "with entry {\n    value: str | int = \"hello\";\n}",
    "basic_09": "with entry {\n    squares: list[int] = [i*i for i in [1, 2, 3, 4, 5]];\n    print(squares);\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"Positive\");\n    } elif num < 0 {\n        print(\"Negative\");\n    } else {\n        print(\"Zero\");\n    }\n}",
    "control_01": "with entry {\n    i: int = 1;\n    while i <= 5 {\n        print(i);\n        i += 1;\n    }\n}",
    "control_02": "with entry {\n    value: int = 2;\n    match value {\n        case 1: { print(\"One\"); };\n        case 2: { print(\"Two\"); };\n        case _: { print(\"Other\"); };\n    }\n}",
    "control_03": "with entry {\n    for i = 0 to i < 10 by i += 1 {\n        if i == 5 {\n            break;\n        }\n        print(i);\n    }\n}",
    "control_04": "with entry {\n    for i = 1 to i <= 10 by i += 1 {\n        if i % 2 == 0 {\n            continue;\n        }\n        print(i);\n    }\n}",
    "collection_01": "with entry {\n    my_set: set[int] = {1, 2};\n    my_set.add(3);\n    print(my_set);\n}",
    "collection_02": "with entry {\n    person: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares_map: dict[int, int] = {i: i*i for i in [1, 2, 3, 4, 5]};\n    print(squares_map);\n}",
    "collection_04": "with entry {\n    fruits: list[str] = [\"apple\", \"banana\", \"cherry\"];\n    for fruit in fruits {\n        print(fruit);\n    }\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n    age: int|None = ages.get(\"Alice\");\n    print(age);\n}",
    "type_01": "with entry {\n    value: any = \"hello\";\n    if isinstance(value, str) {\n        print(\"It is a string.\");\n    }\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n\n    def get_info(self) -> str {\n        return f\"{self.year} {self.brand}\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    has value: int;\n\n    def postinit(self) {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square = lambda x: int: x * x;\n    print(square(5));\n}",
    "obj_06": "obj Secret {\n    :priv: has secret_key: str = \"12345\";\n}",
    "obj_07": "obj PublicInfo {\n    :pub: has info: str = \"This is public\";\n}",
    "obj_08": "def my_decorator(func) {\n    def wrapper() {\n        print(\"Something is happening before the function is called.\");\n        func();\n        print(\"Something is happening after the function is called.\");\n    }\n    return wrapper;\n}\n\n@my_decorator\ndef say_hello() {\n    print(\"Hello!\");\n}",
    "obj_09": "def execute_callback(callback: any) {\n    callback();\n}\n\ndef my_func() {\n    print(\"Callback executed!\");\n}\n\nwith entry {\n    execute_callback(my_func);\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n}\n\nwith entry {\n    sf: City = City(name=\"San Francisco\");\n    la: City = City(name=\"Los Angeles\");\n    sf <++> la;\n}",
    "graph_03": "node City {\n    has name: str;\n}\n\nedge Road {\n    has distance: float;\n}\n\nwith entry {\n    sf: City = City(name=\"San Francisco\");\n    la: City = City(name=\"Los Angeles\");\n    sf +>:Road(distance=380.0):+> la;\n}",
    "graph_04": "walker BasicWalker;\n\nnode Location {\n    has name: str;\n    can greet with BasicWalker entry {\n        print(f\"Welcome to {self.name}!\");\n    }\n}",
    "graph_05": "walker Explorer {\n    has name: str;\n}\n\nnode Landmark {\n    has name: str;\n    can identify_visitor with Explorer entry {\n        print(f\"{visitor.name} is visiting {self.name}.\");\n    }\n}",
    "graph_06": "node Page {\n    has url: str;\n}\n\nwith entry {\n    page1: Page = Page(url=\"/home\");\n    page2: Page = Page(url=\"/about\");\n    page1 ++> page2;\n}",
    "graph_07": "node MyData {\n    has value: int;\n}\n\nwith entry {\n    data_node: MyData = MyData(value=42);\n    `root` ++> data_node;\n}",
    "graph_08": "walker BasicWalker;\n\nnode Room {\n    has name: str;\n    can say_goodbye with BasicWalker exit {\n        print(f\"Leaving {self.name}.\");\n    }\n}",
    "graph_09": "walker Traveler;\n\nedge Path {\n    has length: int;\n    can cross_path with Traveler {\n        print(f\"Crossing a path of length {self.length}.\");\n    }\n}",
    "graph_10": "node Step;\n\nwith entry {\n    s1: Step = Step();\n    s2: Step = Step();\n    s3: Step = Step();\n    s1 ++> s2 ++> s3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "node Place;\n\nwalker SimpleWalker {\n    can walk with Place entry {\n        visit [-->];\n    }\n}",
    "walker_03": "node City;\nnode Town;\n\nwalker CityVisitor {\n    can visit_cities with Town entry {\n        visit [-->(`?City`)];\n    }\n}",
    "walker_04": "node Location {\n    has name: str;\n}\n\nwalker Tourist {\n    can announce with Location entry {\n        print(f\"Starting tour at {here.name}\");\n    }\n}",
    "walker_05": "node Item {\n    has value: int;\n}\n\nwalker ValueCollector {\n    can collect with Item entry {\n        report here.value;\n        visit [-->];\n    }\n}",
    "walker_06": "node MyNode;\nwalker MyWalker;\nwith entry {\n    n = spawn MyNode();\n    n spawn MyWalker();\n}",
    "walker_07": "walker MyWalker;\nwith entry {\n    `root spawn MyWalker();\n}",
    "walker_08": "walker IncomingVisitor {\n    can traverse {\n        visit [<--];\n    }\n}",
    "walker_09": "walker ExitingWalker {\n    can exit_action with exit {\n        print(\"Walker is exiting.\");\n    }\n}",
    "walker_10": "walker ReportNodeWalker {\n    can report_current {\n        visit -->;\n        report here;\n    }\n}",
    "advanced_01": "node Person {\n    has name: str;\n}\nwalker FindJohn {\n    can find {\n        visit [-->](?name==\"John\");\n    }\n}",
    "advanced_02": "edge Knows;\nwalker FriendFinder {\n    can find_friends {\n        visit [->:Knows:->];\n    }\n}",
    "advanced_03": "walker ThreeHops {\n    can traverse {\n        visit [-->-->-->];\n    }\n}",
    "advanced_04": "node Item { has found: bool; }\nwalker EarlyExit {\n    can find_first {\n        visit --> (`?Item) {\n            if(here.found) {\n                report here;\n                disengage;\n            }\n        }\n    }\n}",
    "advanced_05": "walker MyWalker;\nedge MyEdge {\n    can on_visit with MyWalker entry {\n        print(\"Walker visiting edge!\");\n    }\n}",
    "advanced_06": "walker DfsWalker {\n    can traverse {\n        visit [-->:0:];\n    }\n}",
    "advanced_07": "node MyNode;\nwalker MultiNodeVisitor {\n    can visit_list(nodes_to_visit: list[MyNode]) {\n        for n in nodes_to_visit {\n            visit n;\n        }\n    }\n}",
    "advanced_08": "node Person {\n    has age: int;\n}\nwalker AdultFinder {\n    can find_adults {\n        visit [-->(`?Person)](?age > 18);\n    }\n}",
    "advanced_09": "edge Connection {\n    has weight: float;\n}\nwalker StrongConnectionFinder {\n    can find_strong {\n        visit [->:Connection:weight > 5.0:->];\n    }\n}",
    "advanced_10": "node A;\nnode B;\nwith entry {\n    n1 = spawn A();\n    n2 = spawn B();\n    edge_ref = n1 ++> n2;\n    del edge_ref;\n}",
    "ai_01": "import from byllm { Model };",
    "ai_02": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\ndef generate_greeting(topic: str)->str by llm(\"Generate a short greeting about {topic}.\");",
    "ai_04": "obj Product {\n    has name: str;\n    has description: str sem \"A detailed description of the product for the LLM to understand.\";\n}",
    "ai_05": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\nenum Sentiment {\n    POSITIVE;\n    NEGATIVE;\n    NEUTRAL;\n}\ndef analyze_sentiment(text: str)->Sentiment by llm(\"Analyze the sentiment of the following text: {text}\");",
    "ai_06": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\ndef solve_problem(problem: str)->str by llm(method='Reason');",
    "ai_07": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\ndef get_weather(city: str)->str {\n    return \"Sunny\";\n}\ndef plan_trip(destination: str)->str by llm(method='ReAct', tools=[get_weather]);",
    "ai_08": "import from byllm { Image };",
    "ai_09": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\nobj Document {\n    has content: str;\n    def summarize(self)->str by llm(\"Summarize the following document: {self.content}\");\n}",
    "ai_10": "import from byllm { Model };\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\nobj Person {\n    has name: str;\n    has age: int;\n}\ndef extract_person(text: str)->Person by llm(\"Extract the person's name and age from: {text}\");",
    "cloud_01": "walker api_walker {\n    obj __specs__ {\n        static has methods: list[str] = [\"GET\", \"POST\"];\n    }\n    can do_something {}\n}",
    "cloud_02": "walker public_api {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n    can do_something {}\n}",
    "cloud_03": "walker custom_path_walker {\n    obj __specs__ {\n        static has path: str = \"/api/v1/custom\";\n    }\n    can do_something {}\n}",
    "cloud_04": "walker query_param_walker {\n    has param1: str;\n    has param2: int;\n    obj __specs__ {\n        static has as_query: str = \"*\";\n    }\n    can do_something {}\n}",
    "cloud_05": "walker private_worker {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n    can do_internal_work {}\n}",
    "cloud_06": "async walker background_task {\n    can long_running_process {}\n}",
    "cloud_07": "with entry {\n    task_id: str = \"some_walker_uuid\";\n    task_ref = &task_id;\n    status = task_ref.__jac__.status;\n}",
    "cloud_08": "walker webhook_receiver {\n    obj __specs__ {\n        static has methods: list[str] = [\"POST\"];\n        static has auth: bool = False;\n        static has path: str = \"/webhook/github\";\n    }\n    can process_payload {}\n}",
    "cloud_09": "node PersistentData {\n    has value: str;\n}\nwith entry {\n    my_data = spawn PersistentData(value=\"important\");\n    `root ++> my_data;\n}",
    "cloud_10": "obj MyResponse {\n    has message: str;\n    has success: bool;\n}\nwalker typed_response_walker {\n    can get_data(self) -> MyResponse {\n        return MyResponse(message=\"Data retrieved\", success=True);\n    }\n}",
    "import_01": "import math;",
    "import_02": "import from math { sqrt, pow };",
    "import_03": "include \"my_module.jac\";",
    "import_04": "import math as m;",
    "file_01": "with entry {\n    with open(\"data.txt\", \"r\") as f {\n        content: str = f.read();\n        print(content);\n    }\n}",
    "file_02": "with entry {\n    with open(\"output.txt\", \"w\") as f {\n        f.write(\"Hello, Jac file!\");\n    }\n}",
    "file_03": "import json;\nwith entry {\n    with open(\"data.json\", \"r\") as f {\n        data: dict = json.load(f);\n        print(data);\n    }\n}",
    "impl_01": "obj Calculator {\n    def add(self, a: int, b: int) -> int;\n}\nimpl Calculator.add {\n    return a + b;\n}",
    "advanced_func_01": "def sum_all(*args: int) -> int {\n    total: int = 0;\n    for num in args {\n        total += num;\n    }\n    return total;\n}",
    "advanced_func_02": "def print_kwargs(**kwargs: any) {\n    for key, value in kwargs.items() {\n        print(f\"{key}: {value}\");\n    }\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since: str;\n}\n\nwalker SocialGrapher {\n    can traverse;\n}\n\nwith entry {\n    p1 = spawn node::Person(name=\"Alice\");\n    p2 = spawn node::Person(name=\"Bob\");\n    p3 = spawn node::Person(name=\"Charlie\");\n\n    p1 +>:Friendship(since=\"2022\"):+> p2;\n    p2 +>:Friendship(since=\"2023\"):+> p3;\n    p1 +>:Friendship(since=\"2021\"):+> p3;\n\n    walker::SocialGrapher(visitor_type='traverse') spawn p1;\n}\n\nimpl SocialGrapher.traverse {\n    visit [-->] {\n        report here.name;\n    }\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nedge Transition {\n    has event: str;\n}\n\nwalker StateMachine {\n    has current_event: str;\n    can run;\n}\n\nwith entry {\n    s1 = spawn node::State(name=\"idle\");\n    s2 = spawn node::State(name=\"running\");\n    s3 = spawn node::State(name=\"stopped\");\n\n    s1 +>:Transition(event=\"start\"):+> s2;\n    s2 +>:Transition(event=\"stop\"):+> s3;\n    s3 +>:Transition(event=\"reset\"):+> s1;\n\n    w = spawn walker::StateMachine(current_event=\"start\");\n    s1 spawn w;\n    report w.current_state;\n}\n\nimpl StateMachine.run {\n    visit [->:Transition:->(?event==visitor.current_event)] {\n        visitor.current_state = here.name;\n        report f\"Transitioned to {here.name}\";\n        disengage;\n    }\n}",
    "integration_03": "walker ErrorHandler {\n    has a: int;\n    has b: int;\n    can divide;\n}\n\nwith entry {\n    w_ok = spawn walker::ErrorHandler(a=10, b=2);\n    w_err = spawn walker::ErrorHandler(a=10, b=0);\n    \n    root spawn w_ok;\n    root spawn w_err;\n\n    report w_ok.result;\n    report w_err.result;\n}\n\nimpl ErrorHandler.divide {\n    can divide with `root entry {\n        try {\n            visitor.result = visitor.a / visitor.b;\n        } except Exception as e {\n            report f\"Error: Cannot divide by zero.\";\n            visitor.result = -1;\n        }\n    }\n}",
    "integration_04": "async def fetch_data(url: str) -> str {\n    # In a real scenario, this would perform an async network request.\n    await some_async_operation(); # Placeholder for actual async work\n    return f\"Data from {url}\";\n}\n\nwith entry {\n    async def main() {\n        result = await fetch_data(\"http://example.com\");\n        print(result);\n    }\n    main();\n}",
    "integration_05": "node Item {\n    has name: str;\n    has price: float;\n}\n\nwalker CrudManager {\n    can create_item(name: str, price: float);\n    can read_item;\n    can update_item(new_price: float);\n    can delete_item;\n}\n\nwith entry {\n    manager = spawn walker::CrudManager();\n    \n    # Create\n    new_item = manager.create_item(name=\"Laptop\", price=1200.0);\n    \n    # Read\n    new_item spawn manager(visitor_type='read_item');\n    \n    # Update\n    new_item spawn manager(visitor_type='update_item', new_price=1150.0);\n    \n    # Delete\n    new_item spawn manager(visitor_type='delete_item');\n}\n\nimpl CrudManager.create_item {\n    item = spawn node::Item(name=name, price=price);\n    root ++> item;\n    commit();\n    report item;\n    return item;\n}\n\nimpl CrudManager.read_item {\n    report here.context;\n}\n\nimpl CrudManager.update_item {\n    here.price = new_price;\n    save(here);\n    commit();\n    report f\"Updated {here.name} price to {here.price}\";\n}\n\nimpl CrudManager.delete_item {\n    del here;\n    commit();\n    report \"Item deleted\";\n}",
    "integration_06": "import from byllm { Model };\n\nnode Character {\n    has name: str;\n    has description: str;\n}\n\nwalker StoryTeller {\n    has llm: Model = Model(model_name=\"gpt-4o\");\n    can generate_dialogue;\n}\n\nwith entry {\n    c1 = spawn node::Character(name=\"Gandalf\", description=\"A wise old wizard\");\n    c2 = spawn node::Character(name=\"Frodo\", description=\"A young hobbit on a quest\");\n    c1 ++> c2;\n\n    w = spawn walker::StoryTeller();\n    c1 spawn w;\n}\n\ndef generate(description: str) -> str by :g:w.llm(\"Generate a single line of dialogue for this character.\");\n\nimpl StoryTeller.generate_dialogue {\n    visit [-->] {\n        dialogue = generate(here.description);\n        report f\"{here.name}: {dialogue}\";\n    }\n}",
    "integration_07": "node User {\n    has name: str;\n    has email: str;\n}\n\nwalker UserApi {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/api/user\";\n        static has auth: bool = False;\n    }\n    can create_user(name: str, email: str);\n}\n\nimpl UserApi.create_user {\n    new_user = spawn node::User(name=name, email=email);\n    root ++> new_user;\n    # Data is auto-persisted because new_user is connected to root\n    report {\"status\": \"success\", \"user_id\": new_user.jid};\n}",
    "integration_08": "node City {\n    has name: str;\n}\n\nwalker BfsWalker {\n    has visited: set[node] = {};\n    has queue: list[node] = [];\n    can traverse;\n}\n\nwith entry {\n    # Setup graph\n    a = spawn node::City(name=\"A\");\n    b = spawn node::City(name=\"B\");\n    c = spawn node::City(name=\"C\");\n    d = spawn node::City(name=\"D\");\n    a ++> b; a ++> c; b ++> d;\n\n    w = spawn walker::BfsWalker();\n    a spawn w;\n}\n\nimpl BfsWalker.traverse {\n    can traverse with `root entry {\n        visitor.queue.append(here);\n        visitor.visited.add(here);\n        while visitor.queue {\n            current = visitor.queue.pop(0);\n            report current.name;\n            for neighbor in [current-->] {\n                if neighbor not in visitor.visited {\n                    visitor.visited.add(neighbor);\n                    visitor.queue.append(neighbor);\n                }\n            }\n        }\n    }\n}",
    "integration_09": "node Task {\n    has name: str;\n    has status: str = \"pending\"; # pending, in_progress, completed\n}\n\nwalker WorkflowManager {\n    has current_action: str;\n    can process_task;\n}\n\nwith entry {\n    task1 = spawn node::Task(name=\"Step 1\");\n    task2 = spawn node::Task(name=\"Step 2\");\n    task1 ++> task2;\n\n    w = spawn walker::WorkflowManager(current_action=\"start\");\n    task1 spawn w;\n}\n\nimpl Task {\n    can process_task with WorkflowManager entry {\n        if visitor.current_action == \"start\" and self.status == \"pending\" {\n            self.status = \"in_progress\";\n            report f\"{self.name} is now in_progress.\";\n            visitor.current_action = \"complete\";\n        } elif visitor.current_action == \"complete\" and self.status == \"in_progress\" {\n            self.status = \"completed\";\n            report f\"{self.name} is completed.\";\n            visitor.current_action = \"start\"; # Prepare for next task\n        }\n    }\n}\n\nimpl WorkflowManager.process_task {\n    visit [-->] where here.status == \"pending\";\n}",
    "integration_10": "node User { has name: str; }\nnode Movie { has title: str; }\nedge Follows {}\nedge Likes {}\n\nwalker Recommender {\n    has recommendations: set[str] = {};\n    can find_recommendations;\n}\n\nwith entry {\n    u1 = spawn node::User(name=\"Alice\");\n    u2 = spawn node::User(name=\"Bob\");\n    u3 = spawn node::User(name=\"Charlie\");\n    m1 = spawn node::Movie(title=\"Inception\");\n    m2 = spawn node::Movie(title=\"The Matrix\");\n    m3 = spawn node::Movie(title=\"Parasite\");\n\n    u1 +>:Follows:+> u2;\n    u1 +>:Follows:+> u3;\n    u1 +>:Likes:+> m1;\n    u2 +>:Likes:+> m2;\n    u3 +>:Likes:+> m3;\n\n    w = spawn walker::Recommender();\n    u1 spawn w;\n    report w.recommendations;\n}\n\nimpl Recommender.find_recommendations {\n    liked_by_user = [here-->:Likes:->];\n    friends_likes = [here-->:Follows:-->:Likes:->];\n    \n    for movie in friends_likes {\n        if movie not in liked_by_user {\n            visitor.recommendations.add(movie.title);\n        }\n    }\n}",
    "prod_websocket_01": "walker Broadcaster {\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n        static has events: dict = {\"type\": \"walker\", \"walker\": \"broadcast\", \"context\": {}};\n    }\n    can broadcast(channel: str, message: str);\n}\n\nimpl Broadcaster.broadcast {\n    # socket object is injected by the Jac runtime for websockets\n    # The existence of socket.notify_channels is assumed from the prompt\n    if visitor.socket {\n        visitor.socket.notify_channels([channel], {\"message\": message});\n        report f\"Message sent to channel {channel}\";\n    } else {\n        report \"Socket not available.\";\n    }\n}",
    "prod_permissions_01": "enum PermLevel { NO, READ, WRITE };\n\nnode Document {\n    has owner_id: str;\n    has content: str;\n\n    def __jac_access__(user_id: str) -> PermLevel {\n        if self.owner_id == user_id {\n            return PermLevel.WRITE;\n        } else {\n            return PermLevel.READ;\n        }\n    }\n}\n\nwith entry {\n    doc = spawn node::Document(owner_id=\"user123\", content=\"secret\");\n    \n    # In a real app, user_id would come from the request context\n    owner_perm = doc.__jac_access__(user_id=\"user123\");\n    other_perm = doc.__jac_access__(user_id=\"user456\");\n\n    assert owner_perm == PermLevel.WRITE;\n    assert other_perm == PermLevel.READ;\n}",
    "prod_cache_01": "import from time { time };\n\nwalker CachingWalker {\n    has cache: dict[str, any] = {};\n    has cache_expiry: dict[str, float] = {};\n    has ttl: int = 60; # Time to live in seconds\n\n    def get_data(key: str) -> str {\n        current_time = time();\n        if key in visitor.cache and current_time < visitor.cache_expiry.get(key, 0.0) {\n            report \"Returning from cache\";\n            return visitor.cache[key];\n        }\n        \n        # Simulate expensive data generation\n        report \"Generating new data\";\n        new_data = f\"Data for {key} generated at {current_time}\";\n        visitor.cache[key] = new_data;\n        visitor.cache_expiry[key] = current_time + visitor.ttl;\n        return new_data;\n    }\n}\n\nwith entry {\n    w = spawn walker::CachingWalker();\n    w.get_data(\"my_key\"); # Generates\n    w.get_data(\"my_key\"); # From cache\n}",
    "prod_validation_01": "obj ValidationError {\n    has field: str;\n    has message: str;\n}\n\nwalker UserCreator {\n    can create_user(username: str, age: int);\n}\n\nimpl UserCreator.create_user {\n    if len(username) < 3 {\n        report spawn obj::ValidationError(field=\"username\", message=\"Username must be at least 3 characters long.\");\n        disengage;\n    }\n    if age < 18 {\n        report spawn obj::ValidationError(field=\"age\", message=\"User must be at least 18 years old.\");\n        disengage;\n    }\n    report f\"User {username} created successfully.\";\n}",
    "prod_pagination_01": "node Product { has name: str; }\n\nwalker ProductFinder {\n    can find_products(page: int=1, limit: int=10);\n}\n\nimpl ProductFinder.find_products {\n    all_products = [root-->:Product:->];\n    total = len(all_products);\n\n    start = (page - 1) * limit;\n    end = start + limit;\n    items_slice = all_products[start:end];\n\n    report {\n        \"total\": total,\n        \"page\": page,\n        \"limit\": limit,\n        \"items\": [p.context for p in items_slice]\n    };\n}",
    "prod_scheduler_01": "walker DailyReport {\n    obj __schedule__ {\n        static has cron: str = \"0 0 * * *\"; # Run daily at midnight\n        static has save: bool = True;\n    }\n    can run_report;\n}\n\nimpl DailyReport.run_report {\n    # This code will be executed automatically based on the cron schedule\n    report \"Generating daily report...\";\n    # Logic for the report goes here\n    report \"Daily report finished.\";\n}",
    "prod_versioning_01": "node Document {\n    has current_content: str;\n}\n\nnode Version {\n    has content: str;\n    has timestamp: float;\n}\n\nedge IsVersionOf {}\n\nwalker DocManager {\n    can update_doc(new_content: str);\n}\n\nimpl DocManager.update_doc {\n    # here is the Document node\n    import from time { time };\n\n    old_version = spawn node::Version(\n        content=here.current_content,\n        timestamp=time()\n    );\n    here +>:IsVersionOf:+> old_version;\n\n    here.current_content = new_content;\n    save(here);\n    save(old_version);\n    commit();\n    report f\"Document updated to new version.\";\n}",
    "prod_softdelete_01": "node Item {\n    has name: str;\n    has is_deleted: bool = False;\n}\n\nwalker ItemManager {\n    can soft_delete;\n    can get_active_items;\n}\n\nimpl ItemManager.soft_delete {\n    here.is_deleted = True;\n    save(here);\n    commit();\n    report f\"Item {here.name} soft deleted.\";\n}\n\nimpl ItemManager.get_active_items {\n    active_items = [root-->:Item:->(?is_deleted==False)];\n    report [item.name for item in active_items];\n}",
    "prod_audit_01": "import from time { time };\n\nnode AuditLog {\n    has user_id: str;\n    has action: str;\n    has timestamp: float;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    can log_action(user_id: str, action: str, details: dict);\n}\n\nimpl AuditLogger.log_action {\n    log_entry = spawn node::AuditLog(\n        user_id=user_id,\n        action=action,\n        details=details,\n        timestamp=time()\n    );\n    root ++> log_entry;\n    commit();\n    report \"Action logged.\";\n}",
    "prod_ratelimit_01": "import from time { time };\n\nglob requests: dict[str, list[float]] = {};\nglob limit: int = 100; # requests\nglob window: int = 60; # seconds\n\nwalker RateLimiter {\n    can check_request(user_id: str) -> bool {\n        current_time = time();\n        user_requests = :g:requests.get(user_id, []);\n        \n        valid_requests = [t for t in user_requests if t > current_time - :g:window];\n        \n        if len(valid_requests) >= :g:limit {\n            report \"Rate limit exceeded.\";\n            return False;\n        }\n        \n        valid_requests.append(current_time);\n        :g:requests[user_id] = valid_requests;\n        return True;\n    }\n}",
    "advanced_ai_stream_01": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o\");\n\ndef stream_story(prompt: str) by llm(stream=True);\n\nwith entry {\n    print(\"Story: \");\n    for token in stream_story(\"Tell me a short story about a robot.\") {\n        print(token, end=\"\");\n    }\n    print();\n}",
    "advanced_ai_multimodal_01": "import from byllm { Model, Image };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef analyze_image(img: Image, query: str) -> str by llm;\n\nwalker ImageAnalyzer {\n    can process_image(image_path: str, query: str);\n}\n\nimpl ImageAnalyzer.process_image {\n    img_obj = Image(image_path);\n    analysis = analyze_image(img_obj, query);\n    report analysis;\n}\n\nwith entry {\n    # Assuming a file 'test.jpg' exists\n    w = spawn walker::ImageAnalyzer();\n    w.process_image(image_path=\"test.jpg\", query=\"What is in this image?\");\n}",
    "advanced_ai_react_01": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o\");\n\ndef get_stock_price(symbol: str) -> float {\n    # Mock implementation\n    if symbol == \"JAC\" { return 123.45; }\n    return 0.0;\n}\n\ndef get_news(topic: str) -> list[str] {\n    # Mock implementation\n    return [f\"News about {topic}: It's going great!\"];\n}\n\ndef financial_assistant(query: str) -> str by llm(\n    method='ReAct',\n    tools=[get_stock_price, get_news]\n);\n\nwith entry {\n    response = financial_assistant(\"What is the stock price of JAC and any recent news?\");\n    print(response);\n}",
    "advanced_ai_structured_01": "import from byllm { Model };\n\nobj UserInfo {\n    has name: str;\n    has email: str|None;\n}\n\nglob llm: Model = Model(model_name=\"gpt-4o\");\n\ndef extract_user_info(text: str) -> UserInfo by llm;\n\nwith entry {\n    document = \"The user's name is John Doe and his email is john.doe@example.com.\";\n    user = extract_user_info(document);\n    report f\"Name: {user.name}, Email: {user.email}\";\n    assert user.name == \"John Doe\";\n}",
    "advanced_graph_complex_filter_01": "node Person { has name: str; has age: int; }\nnode Company { has name: str; }\nedge WorksAt { has role: str; }\n\nwith entry {\n    p1 = spawn node::Person(name=\"Alice\", age=35);\n    p2 = spawn node::Person(name=\"Bob\", age=28);\n    c1 = spawn node::Company(name=\"JacCorp\");\n\n    p1 +>:WorksAt(role=\"Engineer\"):+> c1;\n    p2 +>:WorksAt(role=\"Manager\"):+> c1;\n\n    # Find engineers older than 30 working at JacCorp\n    engineers = [c1<--:WorksAt(role==\"Engineer\"):--(`?Person)(?age>30)];\n    \n    for eng in engineers {\n        report eng.name;\n    }\n}",
    "advanced_graph_pathfind_01": "node City { has name: str; }\nedge Road { has distance: int; }\n\nwalker PathFinder {\n    has distances: dict[node, int] = {};\n    has previous: dict[node, node|None] = {};\n    has unvisited: set[node] = {};\n\n    can find_shortest_path(start_node: node, end_node: node) {\n        visitor.distances[start_node] = 0;\n        visitor.unvisited.add(start_node);\n\n        while visitor.unvisited {\n            current = min(visitor.unvisited, key=lambda n: visitor.distances.get(n, 1000000));\n            visitor.unvisited.remove(current);\n\n            if current == end_node { break; }\n\n            for edge in [current --->] {\n                neighbor = edge.target;\n                alt_dist = visitor.distances[current] + edge.distance;\n                if alt_dist < visitor.distances.get(neighbor, 1000000) {\n                    visitor.distances[neighbor] = alt_dist;\n                    visitor.previous[neighbor] = current;\n                    visitor.unvisited.add(neighbor);\n                }\n            }\n        }\n        report visitor.distances.get(end_node);\n    }\n}",
    "advanced_graph_cycle_01": "node Step { has name: str; }\n\nwalker CycleDetector {\n    has visited: set[node] = {};\n    has recursion_stack: set[node] = {};\n    has cycle_found: bool = False;\n\n    can detect_cycle(current: node) {\n        visitor.visited.add(current);\n        visitor.recursion_stack.add(current);\n\n        for neighbor in [current-->] {\n            if neighbor not in visitor.visited {\n                if visitor.detect_cycle(neighbor) {\n                    return True;\n                }\n            } elif neighbor in visitor.recursion_stack {\n                report f\"Cycle detected at {neighbor.name}\";\n                visitor.cycle_found = True;\n                return True;\n            }\n        }\n        visitor.recursion_stack.remove(current);\n        return False;\n    }\n}",
    "advanced_persist_transaction_01": "obj Data { has value: int; }\n\nwith entry {\n    items_to_create = [1, 2, 3, 4, 5];\n    for i in items_to_create {\n        new_obj = spawn obj::Data(value=i);\n        save(new_obj); # Queue for saving\n    }\n    \n    # All objects are saved in a single database transaction\n    commit();\n    report \"Batch save complete.\";\n}",
    "advanced_persist_reference_01": "node User { has name: str; }\n\nwith entry {\n    # Create and persist a node\n    user = spawn node::User(name=\"Zane\");\n    root ++> user;\n    commit();\n    user_id_str = user.jid;\n    \n    # Later, retrieve the node using its ID string\n    retrieved_user = &user_id_str;\n    \n    report f\"Retrieved user: {retrieved_user.name}\";\n    assert retrieved_user.name == \"Zane\";\n}",
    "advanced_cloud_webhook_01": "walker WebhookReceiver {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/webhook/github\";\n        static has auth: bool = True; # Enables Jac's auth system\n    }\n\n    can process_payload(payload: dict);\n}\n\nimpl WebhookReceiver.process_payload {\n    # This walker will only be executed if authentication succeeds.\n    # The specific auth mechanism (e.g., checking a header) would be\n    # configured in the Jac server environment.\n    report f\"Received payload from {payload.get('sender', {}).get('login')}\";\n}",
    "advanced_cloud_async_retrieve_01": "async walker LongTask {\n    can run_job;\n}\n\nimpl LongTask.run_job {\n    # Simulate a long-running process\n    report \"Job started...\";\n    # await some_long_operation();\n    report \"Job finished.\";\n}\n\nwith entry {\n    async def main() {\n        result = spawn walker::LongTask();\n        task_id = result;\n        \n        task_ref = &task_id;\n        \n        # Poll for status (in a real app, you might loop)\n        status = task_ref.__jac__.status;\n        report f\"Task {task_id} status: {status}\";\n        \n        # Wait for completion and get reports\n        # reports = await task_ref.__jac__.reports;\n    }\n    main();\n}",
    "advanced_cloud_query_params_01": "walker SearchApi {\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has path: str = \"/search\";\n        static has as_query: list = [\"query\", \"category\"];\n    }\n\n    can search(query: str, category: str, limit: int = 10);\n}\n\nimpl SearchApi.search {\n    # 'query' and 'category' are expected from URL query string\n    # 'limit' would be in the request body unless also in as_query\n    report f\"Searching for '{query}' in category '{category}' with limit {limit}.\";\n}",
    "integration_error_handling_01": "obj ConfigError {\n    has message: str;\n}\n\nwalker ConfigLoader {\n    can load_config(config: dict) {\n        try {\n            if \"api_key\" not in config {\n                raise spawn obj::ConfigError(message=\"API key is missing\");\n            }\n            report \"Config loaded successfully.\";\n            return config[\"api_key\"];\n        } except ConfigError as e {\n            print(f\"Error loading config: {e.message}\");\n            report \"default_key\"; # Report a fallback value\n            return \"default_key\";\n        }\n    }\n}",
    "integration_external_api_01": "import requests;\n\nwalker ApiFetcher {\n    can fetch(url: str) -> dict|None {\n        try {\n            response = requests.get(url);\n            response.raise_for_status(); # Raise HTTPError for bad responses (4xx or 5xx)\n            return response.json();\n        } except requests.exceptions.RequestException as e {\n            report f\"API request failed: {e}\";\n            return None;\n        }\n    }\n}\n\nwith entry {\n    w = spawn walker::ApiFetcher();\n    data = w.fetch(\"https://api.example.com/data\");\n    if data {\n        print(\"Data fetched successfully\");\n    }\n}",
    "integration_conditional_visit_01": "node PathNode { has name: str; }\n\nwalker Explorer {\n    can explore;\n}\n\nwith entry {\n    start = spawn node::PathNode(name=\"start\");\n    middle = spawn node::PathNode(name=\"middle\");\n    end = spawn node::PathNode(name=\"end\");\n    dead_end = spawn node::PathNode(name=\"dead_end\");\n\n    start ++> middle ++> end;\n    start ++> dead_end;\n\n    w = spawn walker::Explorer();\n    start spawn w;\n}\n\nimpl Explorer.explore {\n    report f\"Visiting {here.name}\";\n    visit [-->] else {\n        report f\"No further path from {here.name}. Disengaging.\";\n        disengage;\n    }\n}",
    "integration_multi_ability_01": "node ProcessStep {\n    has name: str;\n}\n\nwalker LifecycleWalker {\n    can track;\n}\n\nimpl ProcessStep {\n    can track with LifecycleWalker entry {\n        report f\"Entering step: {self.name} with walker {visitor.jid}\";\n    }\n    can track with LifecycleWalker exit {\n        report f\"Exiting step: {self.name} with walker {visitor.jid}\";\n    }\n}\n\nwith entry {\n    step1 = spawn node::ProcessStep(name=\"Step 1\");\n    w = spawn walker::LifecycleWalker();\n    step1 spawn w;\n}",
    "integration_batch_process_01": "node Record { has data: str; }\n\nwalker BatchProcessor {\n    can process(items: list[str]) {\n        for item_data in items {\n            new_record = spawn node::Record(data=item_data);\n            root ++> new_record;\n            save(new_record); # Queue each new record for saving\n        }\n        commit(); # Commit all queued saves in one transaction\n        report f\"Processed and committed {len(items)} items.\";\n    }\n}\n\nwith entry {\n    w = spawn walker::BatchProcessor();\n    w.process([\"data1\", \"data2\", \"data3\"]);\n}",
    "integration_visitor_communication_01": "node StateChanger { has increment: int; }\n\nwalker StatefulWalker {\n    has counter: int = 0;\n    can accumulate;\n}\n\nimpl StateChanger {\n    can accumulate with StatefulWalker entry {\n        report f\"Node {self.jid} is updating walker. Old counter: {visitor.counter}\";\n        visitor.counter += self.increment;\n        report f\"New counter: {visitor.counter}\";\n    }\n}\n\nwith entry {\n    n1 = spawn node::StateChanger(increment=5);\n    n2 = spawn node::StateChanger(increment=10);\n    n1 ++> n2;\n\n    w = spawn walker::StatefulWalker();\n    n1 spawn w;\n    assert w.counter == 15;\n}",
    "integration_root_ability_01": "walker Initializer {\n    has setup_complete: bool = False;\n    can initialize;\n}\n\nimpl Initializer.initialize {\n    can initialize with `root entry {\n        report \"Initializer walker starting at root node.\";\n        visitor.setup_complete = True;\n    }\n\n    visit [-->] {\n        report f\"Visiting {here.name}, setup is {visitor.setup_complete}\";\n    }\n}\n\nwith entry {\n    w = spawn walker::Initializer();\n    root spawn w;\n    assert w.setup_complete == True;\n}",
    "integration_edge_traversal_01": "node City { has name: str; }\nedge Route { has distance: int; }\n\nwalker RouteInspector {\n    can inspect_routes;\n}\n\nwith entry {\n    sf = spawn node::City(name=\"San Francisco\");\n    la = spawn node::City(name=\"Los Angeles\");\n    sf +>:Route(distance=380):+> la;\n\n    w = spawn walker::RouteInspector();\n    sf spawn w;\n}\n\nimpl RouteInspector.inspect_routes {\n    for edge in [here --->] {\n        report f\"Found route to {edge.target.name} with distance {edge.distance}\";\n    }\n}"
  }
}