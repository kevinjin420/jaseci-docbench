{
  "metadata": {
    "model": "gemini/gemini-2.5-pro-preview-03-25",
    "model_alias": "gemini-pro",
    "variant": "mini_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n}",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#* This is a multi-line comment. *#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    message: str = f\"Hello, {name}!\";\n    print(message);\n}",
    "basic_08": "with entry {\n    value: str | int = \"hello\";\n}",
    "basic_09": "with entry {\n    squares: list[int] = [i*i for i in [1, 2, 3, 4, 5]];\n    print(squares);\n}",
    "basic_10": "with entry {\n    num: int = 5;\n    if num > 0 {\n        print(\"Positive\");\n    } elif num < 0 {\n        print(\"Negative\");\n    } else {\n        print(\"Zero\");\n    }\n}",
    "control_01": "with entry {\n    i: int = 1;\n    while i <= 5 {\n        print(i);\n        i += 1;\n    }\n}",
    "control_02": "with entry {\n    value: int = 2;\n    match value {\n        case 1: {\n            print(\"One\");\n        }\n        case 2: {\n            print(\"Two\");\n        }\n        case _: {\n            print(\"Other\");\n        }\n    }\n}",
    "control_03": "with entry {\n    for i = 0 to i < 10 by i += 1 {\n        if i == 5 {\n            break;\n        }\n        print(i);\n    }\n}",
    "control_04": "with entry {\n    for i = 1 to i <= 10 by i += 1 {\n        if i % 2 == 0 {\n            continue;\n        }\n        print(i);\n    }\n}",
    "collection_01": "with entry {\n    my_set: set[int] = {1, 2};\n    my_set.add(3);\n    print(my_set);\n}",
    "collection_02": "with entry {\n    person: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares_dict: dict[int, int] = {i: i*i for i in [1, 2, 3, 4, 5]};\n    print(squares_dict);\n}",
    "collection_04": "with entry {\n    names: list[str] = [\"Alice\", \"Bob\", \"Charlie\"];\n    for name in names {\n        print(name);\n    }\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30, \"Bob\": 25};\n    age: int|None = ages.get(\"Alice\");\n    print(age);\n}",
    "type_01": "with entry {\n    value: any = \"hello\";\n    if isinstance(value, str) {\n        print(\"It is a string.\");\n    }\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n    def get_info(self) -> str {\n        return f\"{self.year} {self.brand}\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    has value: int;\n    def postinit(self) {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square = lambda x: int: x * x;\n    result: int = square(5);\n    print(result);\n}",
    "obj_06": "obj Secret {\n    has :priv: data: str = \"top secret\";\n}",
    "obj_07": "obj PublicInfo {\n    has :pub: info: str = \"This is public\";\n}",
    "obj_08": "def my_decorator(func) {\n    def wrapper() {\n        print(\"Something is happening before the function is called.\");\n        func();\n        print(\"Something is happening after the function is called.\");\n    }\n    return wrapper;\n}\n\n@my_decorator\ndef say_hello() {\n    print(\"Hello!\");\n}",
    "obj_09": "def greet() {\n    print(\"Hello from callback!\");\n}\n\ndef execute_callback(callback: any) {\n    callback();\n}\n\nwith entry {\n    execute_callback(greet);\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City { has name: str; }\n\nwith entry {\n    sf: City = City(name=\"San Francisco\");\n    la: City = City(name=\"Los Angeles\");\n    sf <++> la;\n}",
    "graph_03": "node City { has name: str; }\nedge Road { has distance: float; }\n\nwith entry {\n    sf: City = City(name=\"San Francisco\");\n    la: City = City(name=\"Los Angeles\");\n    sf +>:Road(distance=383.1):+> la;\n}",
    "graph_04": "walker GenericWalker {}\n\nnode Location {\n    has name: str;\n    can greet with GenericWalker entry {\n        print(f\"Welcome to {self.name}!\");\n    }\n}",
    "graph_05": "walker MyWalker { has name: str; }\n\nnode MyNode {\n    can interact with MyWalker entry {\n        print(f\"Walker {visitor.name} has arrived!\");\n    }\n}",
    "graph_06": "node Point {}\n\nwith entry {\n    a: Point = Point();\n    b: Point = Point();\n    a ++> b;\n}",
    "graph_07": "node MyData { has value: int; }\n\nwith entry {\n    data_node: MyData = MyData(value=42);\n    `root ++> data_node;\n}",
    "graph_08": "walker PathWalker {}\n\nnode Checkpoint {\n    has id: int;\n    can say_goodbye with PathWalker exit {\n        print(f\"Leaving checkpoint {self.id}.\");\n    }\n}",
    "graph_09": "edge TollRoad {\n    has fee: float;\n    can charge_toll {\n        print(f\"Toll of {self.fee} paid.\");\n    }\n}",
    "graph_10": "node Step {}\n\nwith entry {\n    s1: Step = Step();\n    s2: Step = Step();\n    s3: Step = Step();\n    s1 ++> s2 ++> s3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "node Place {}\n\nwalker Traveler {\n    can travel {\n        visit [-->];\n    }\n}",
    "walker_03": "node City {}\nnode Town {}\n\nwalker Inspector {\n    can inspect_cities {\n        visit [--> (`?City)];\n    }\n}",
    "walker_04": "node Location { has name: str; }\n\nwalker Tourist {\n    can arrive with Location entry {\n        print(f\"Arrived at {here.name}\");\n    }\n}",
    "walker_05": "node Item { has value: int; }\n\nwalker Collector {\n    can collect {\n        report here.value;\n    }\n}",
    "walker_06": "node MyNode {}\nwalker MyWalker { can run; }\nwith entry {\n    n = MyNode();\n    n spawn MyWalker();\n}",
    "walker_07": "walker RootWalker { can run; }\nwith entry {\n    root spawn RootWalker();\n}",
    "walker_08": "walker IncomingWalker {\n    can traverse;\n    with entry {\n        visit [<--];\n    }\n}",
    "walker_09": "walker ExitLogger {\n    has log: list[str] = [];\n    with exit {\n        self.log.append(\"Walker finished.\");\n        print(\"Walker exited.\");\n    }\n}",
    "walker_10": "walker NodeReporter {\n    can report_location;\n    with entry {\n        report here;\n    }\n}",
    "advanced_01": "node User {\n    has status: str;\n}\n\nwalker FindActiveUsers {\n    can find;\n    with entry {\n        visit [-->](?status==\"active\");\n    }\n}",
    "advanced_02": "edge Follows {}\nnode User {}\n\nwalker FollowerWalker {\n    can find_followers;\n    with entry {\n        visit [->:Follows:->];\n    }\n}",
    "advanced_03": "walker DeepTraverser {\n    can go_deep;\n    with entry {\n        visit [-->-->-->];\n    }\n}",
    "advanced_04": "walker ConditionalExit {\n    has limit: int = 5;\n    has count: int = 0;\n    can run;\n    with entry {\n        visit [-->] {\n            self.count += 1;\n            if self.count >= self.limit {\n                disengage;\n            }\n        }\n    }\n}",
    "advanced_05": "walker MyWalker {}\n\nedge MyEdge {\n    has triggered: bool = False;\n    can on_visit with MyWalker entry {\n        self.triggered = True;\n    }\n}",
    "advanced_06": "walker DfsWalker {\n    has visited: set[node] = {};\n    can traverse;\n    with entry {\n        if(here not in self.visited) {\n            self.visited.add(here);\n            report here;\n            visit [-->];\n        }\n    }\n}",
    "advanced_07": "node Target {}\n\nwalker MultiVisitor {\n    has targets: list[Target];\n    can run;\n    with entry {\n        visit self.targets;\n    }\n}",
    "advanced_08": "node Person {\n    has age: int;\n}\n\nwalker AdultFinder {\n    can find;\n    with entry {\n        visit [-->(`?Person)](?age > 18);\n    }\n}",
    "advanced_09": "edge WeightedLink {\n    has weight: float;\n}\n\nwalker HeavyLinkFinder {\n    can find;\n    with entry {\n        visit [->:WeightedLink:weight > 5.0:->];\n    }\n}",
    "advanced_10": "with entry {\n    n1 = node();\n    n2 = node();\n    edge_ref = n1 ++> n2;\n    del edge_ref;\n}",
    "ai_01": "import from byllm { Model };",
    "ai_02": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm { Model };\n\nglob llm: Model = Model();\n\ndef generate_greeting(topic: str)->str by llm(\"Generate a short greeting about {topic}.\");",
    "ai_04": "obj Person {\n    has name: str sem \"The full name of the individual.\";\n    has age: int sem \"The age of the person in years.\";\n}",
    "ai_05": "import from byllm { Model };\n\nglob llm: Model = Model();\n\nenum Sentiment { POSITIVE, NEGATIVE, NEUTRAL }\n\ndef classify_sentiment(text: str)->Sentiment by llm;",
    "ai_06": "import from byllm { Model };\n\nglob llm: Model = Model();\n\ndef solve_riddle(riddle: str)->str by llm(method='Reason');",
    "ai_07": "import from byllm { Model };\n\nglob llm: Model = Model();\n\ndef get_stock_price(ticker: str)->float;\n\ndef answer_finance_question(question: str)->str by llm(method='ReAct', tools=[get_stock_price]);",
    "ai_08": "import from byllm { Image };",
    "ai_09": "import from byllm { Model };\n\nglob llm: Model = Model();\n\nobj Character {\n    has description: str;\n    def generate_dialogue(situation: str)->str by llm(\"My character is {self.description}. Generate dialogue for the situation: {situation}\");\n}",
    "ai_10": "import from byllm { Model };\n\nglob llm: Model = Model();\n\nobj UserProfile {\n    has username: str;\n    has location: str;\n}\n\ndef extract_user_profile(text: str)->UserProfile by llm;",
    "cloud_01": "walker api_handler {\n    obj __specs__ {\n        static has methods: list[str] = [\"GET\", \"POST\"];\n    }\n    can process_request;\n}",
    "cloud_02": "walker public_api {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n    can get_public_data;\n}",
    "cloud_03": "walker custom_endpoint {\n    obj __specs__ {\n        static has path: str = \"/api/v2/data\";\n    }\n    can serve_data;\n}",
    "cloud_04": "walker search_walker {\n    has query: str;\n    has limit: int;\n    obj __specs__ {\n        static has as_query: str = \"*\";\n    }\n    can perform_search;\n}",
    "cloud_05": "walker internal_utility {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n    can do_internal_work;\n}",
    "cloud_06": "async walker long_running_job {\n    can execute;\n    with entry {\n        #* Simulate a long task *#\n    }\n}",
    "cloud_07": "with entry {\n    async walker my_task{};\n    task_handle = spawn my_task();\n    task_id = task_handle;\n    task_ref = &task_id;\n    status = task_ref.__jac__.status;\n}",
    "cloud_08": "walker websocket_listener {\n    obj __specs__ {\n        static has methods: list[str] = [\"WEBSOCKET\"];\n    }\n    can handle_connection;\n}",
    "cloud_09": "node User {\n    has name: str;\n}\n\nwith entry {\n    new_user = User(name=\"jason\");\n    root ++> new_user;\n    commit();\n}",
    "cloud_10": "obj ApiResponse {\n    has status: str;\n    has data: list[str];\n}\n\nwalker data_fetcher {\n    can fetch()->ApiResponse;\n}\n\nimpl data_fetcher.fetch {\n    return ApiResponse(status=\"ok\", data=[\"item1\", \"item2\"]);\n}",
    "import_01": "import os;\n\nwith entry {\n    print(os.getcwd());\n}",
    "import_02": "import from datetime { datetime, timedelta };\n\nwith entry {\n    now = datetime.now();\n    print(now);\n}",
    "import_03": "import from \"./my_lib.jac\" { MyObject };",
    "import_04": "import numpy as np;\n\nwith entry {\n    arr = np.array([1, 2, 3]);\n    print(arr);\n}",
    "file_01": "with entry {\n    with open(\"config.txt\", \"r\") as f {\n        config = f.read();\n    }\n}",
    "file_02": "with entry {\n    with open(\"log.txt\", \"w\") as f {\n        f.write(\"Log entry.\");\n    }\n}",
    "file_03": "import json;\n\nwith entry {\n    with open(\"settings.json\", \"r\") as f {\n        settings = json.load(f);\n    }\n}",
    "impl_01": "obj Greeter {\n    has name: str;\n    def greet()->str;\n}\n\nimpl Greeter.greet {\n    return f\"Hello, {self.name}!\";\n}",
    "advanced_func_01": "def sum_numbers(*args: int|float)->int|float {\n    total: int|float = 0;\n    for n in args {\n        total += n;\n    }\n    return total;\n}",
    "advanced_func_02": "def create_user(**kwargs: str|int)->dict[str, str|int] {\n    user_data: dict[str, str|int] = {};\n    for key, value in kwargs.items() {\n        user_data[key] = value;\n    }\n    return user_data;\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since_year: int;\n}\n\nwalker FriendFinder {\n    can find_friends;\n    can find_friends with Person entry {\n        report f\"{here.name}'s friends:\";\n        for friend in [here-->] {\n            report friend.name;\n        }\n    }\n}\n\nwith entry {\n    alice = spawn node::Person(name=\"Alice\");\n    bob = spawn node::Person(name=\"Bob\");\n    charlie = spawn node::Person(name=\"Charlie\");\n\n    alice +>:Friendship(since_year=2020):+> bob;\n    alice +>:Friendship(since_year=2021):+> charlie;\n\n    alice spawn FriendFinder();\n}",
    "integration_02": "node State {\n    has name: str;\n}\n\nedge Transition {\n    has event: str;\n}\n\nwalker StateMachine {\n    has current_state: State;\n    def trigger(event_name: str) {\n        for next_state in [self.current_state -:Transition: event==event_name :->] {\n            self.current_state = next_state;\n            report f\"Transitioned to {self.current_state.name}\";\n            return;\n        }\n        report f\"No transition for event {event_name} from state {self.current_state.name}\";\n    }\n}\n\nwith entry {\n    locked = spawn node::State(name=\"Locked\");\n    unlocked = spawn node::State(name=\"Unlocked\");\n    locked +>:Transition(event=\"coin\"):+> unlocked;\n    unlocked +>:Transition(event=\"push\"):+> locked;\n\n    sm = StateMachine(current_state=locked);\n    sm.trigger(\"coin\");\n    sm.trigger(\"push\");\n}",
    "integration_03": "walker ErrorHandler {\n    can perform_division(a: float, b: float);\n    can perform_division with `root entry {\n        try {\n            if b == 0.0 {\n                raise ZeroDivisionError();\n            }\n            result = a / b;\n            report f\"Result: {result}\";\n        } except ZeroDivisionError as e {\n            report \"Error: Division by zero is not allowed.\";\n        }\n    }\n}\n\nwith entry {\n    w = ErrorHandler();\n    w.perform_division(a=10.0, b=2.0);\n    w.perform_division(a=10.0, b=0.0);\n}",
    "integration_04": "import from \"asyncio\" { sleep };\n\nasync def fetch_remote_data(source: str) -> str {\n    await sleep(0.1);\n    return f\"Data from {source}\";\n}\n\nasync walker AsyncDataFetcher {\n    can fetch_all;\n    can fetch_all with `root entry {\n        data1 = await fetch_remote_data(\"API_1\");\n        data2 = await fetch_remote_data(\"API_2\");\n        report data1;\n        report data2;\n    }\n}\n\nwith entry {\n    spawn AsyncDataFetcher();\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker CrudManager {\n    def create_item(name: str, value: int) -> Item {\n        new_item = spawn root ++> node::Item(name=name, value=value);\n        save(new_item);\n        commit();\n        report f\"Created item: {name}\";\n        return new_item;\n    }\n\n    def read_item(name: str) -> Item|None {\n        items = [root-->(`?Item)](?name==name);\n        if items.length > 0 {\n            report items[0];\n            return items[0];\n        }\n        report \"Item not found\";\n        return None;\n    }\n\n    def update_item(name: str, new_value: int) {\n        item = self.read_item(name);\n        if item {\n            item.value = new_value;\n            save(item);\n            commit();\n            report f\"Updated {name} with value {new_value}\";\n        }\n    }\n\n    def delete_item(name: str) {\n        item = self.read_item(name);\n        if item {\n            del item;\n            commit();\n            report f\"Deleted item: {name}\";\n        }\n    }\n}",
    "integration_06": "import from byllm { Model };\n\nnode Concept {\n    has name: str;\n    has description: str;\n}\n\ndef explain_connection(c1: str, c2: str) -> str by llm(\n    \"Explain the relationship between {c1} and {c2} in one sentence.\"\n);\n\nwalker AiGraphExplorer {\n    can explore;\n    can explore with Concept entry {\n        report f\"At concept: {here.name}\";\n        for neighbor in [here-->] {\n            explanation = explain_connection(here.name, neighbor.name);\n            report f\"  -> {neighbor.name}: {explanation}\";\n        }\n    }\n}\n\nwith entry {\n    ml = spawn node::Concept(name=\"Machine Learning\", description=\"...\");\n    dl = spawn node::Concept(name=\"Deep Learning\", description=\"...\");\n    ml ++> dl;\n    ml spawn AiGraphExplorer();\n}",
    "integration_07": "node DataEntry {\n    has content: str;\n    has timestamp: str;\n}\n\nwalker ApiHandler {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/add_entry\";\n    }\n\n    can add_entry(content: str);\n\n    can add_entry with `root entry {\n        import from \"datetime\" { datetime };\n        new_entry = spawn here ++> node::DataEntry(\n            content=content,\n            timestamp=datetime.utcnow().isoformat()\n        );\n        report {\"status\": \"success\", \"id\": new_entry.jid};\n    }\n}",
    "integration_08": "node City { has name: str; }\n\nwalker BfsWalker {\n    has visited: set[node] = {};\n    has queue: list[node] = [];\n\n    can traverse(start_node: City);\n\n    can traverse with `root entry {\n        self.queue.append(start_node);\n        self.visited.add(start_node);\n        while self.queue.length > 0 {\n            current = self.queue.pop(0);\n            report f\"Visiting {current.name}\";\n            visit current;\n        }\n    }\n\n    can traverse with City entry {\n        for neighbor in [here-->] {\n            if neighbor not in self.visited {\n                self.visited.add(neighbor);\n                self.queue.append(neighbor);\n            }\n        }\n    }\n}",
    "integration_09": "walker Workflow {\n    has state: dict = {};\n    can run_flow;\n}\n\nnode StepA {\n    can run_flow with Workflow entry {\n        report \"Executing Step A\";\n        visitor.state[\"step_a_complete\"] = True;\n    }\n}\n\nnode StepB {\n    can run_flow with Workflow entry {\n        if visitor.state.get(\"step_a_complete\") {\n            report \"Executing Step B\";\n            visitor.state[\"step_b_complete\"] = True;\n        } else {\n            report \"Step A must be completed first.\";\n            disengage;\n        }\n    }\n}\n\nwith entry {\n    step1 = spawn node::StepA();\n    step2 = spawn node::StepB();\n    step1 ++> step2;\n    step1 spawn Workflow();\n}",
    "integration_10": "node User { has name: str; }\nnode Movie { has title: str; }\nedge Likes;\nedge Friend;\n\nwalker Recommender {\n    can recommend_movies;\n    can recommend_movies with User entry {\n        my_movies = {m for m in [here-->:Likes:-->]};\n        recommendations: set[Movie] = {};\n        \n        # Find movies liked by friends (friend-of-a-friend)\n        friends_movies = [here-->:Friend:-->:User:-->:Likes:-->:Movie];\n        \n        for movie in friends_movies {\n            if movie not in my_movies {\n                recommendations.add(movie);\n            }\n        }\n        report {\"user\": here.name, \"recommendations\": [m.title for m in recommendations]};\n    }\n}",
    "prod_websocket_01": "import from jaclang.core.jac_socket { JacSocket };\n\nwalker RealtimeNotifier {\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n    }\n\n    can notify(channel: str, message: str, socket: JacSocket);\n\n    can notify with `root entry {\n        event_data = {\"type\": \"notification\", \"message\": message};\n        socket.notify_channels([channel], event_data);\n        report {\"status\": \"sent\", \"channel\": channel};\n    }\n}",
    "prod_permissions_01": "import from jaclang.core.permissions { WritePerm, ReadPerm, NoPerm };\n\nglob current_user_id: str = \"user_123\";\n\nnode Document {\n    has owner_id: str;\n    has content: str;\n\n    def __jac_access__() -> WritePerm|ReadPerm|NoPerm {\n        if self.owner_id == :g:current_user_id {\n            return WritePerm;\n        } else {\n            return ReadPerm;\n        }\n    }\n}",
    "prod_cache_01": "import from \"time\" { time };\n\nwalker CachingWalker {\n    has cache: dict = {};\n    has ttl: int = 60; # Time-to-live in seconds\n\n    def get_data(key: str) -> str {\n        now = time();\n        if key in self.cache and now < self.cache[key][\"expiry\"] {\n            report \"Returning cached value\";\n            return self.cache[key][\"value\"];\n        }\n\n        # Simulate expensive operation\n        new_value = f\"Generated data for {key} at {now}\";\n        self.cache[key] = {\"value\": new_value, \"expiry\": now + self.ttl};\n        report \"Generated and cached new value\";\n        return new_value;\n    }\n}",
    "prod_validation_01": "obj ValidationError { has message: str; }\n\nwalker InputValidator {\n    can register_user(email: str, age: int);\n\n    can register_user with `root entry {\n        if \"@\" not in email {\n            report ValidationError(message=\"Invalid email format.\");\n            disengage;\n        }\n        if age < 18 {\n            report ValidationError(message=\"User must be at least 18 years old.\");\n            disengage;\n        }\n        report \"User registration data is valid.\";\n    }\n}",
    "prod_pagination_01": "node Product { has name: str; }\n\nwalker ProductPaginator {\n    def list_products(page: int = 1, page_size: int = 10) {\n        all_products = [root-->(`?Product)];\n        total_items = all_products.length;\n        \n        start_index = (page - 1) * page_size;\n        end_index = start_index + page_size;\n        \n        paginated_items = all_products[start_index:end_index];\n        \n        report {\n            \"total\": total_items,\n            \"page\": page,\n            \"page_size\": page_size,\n            \"items\": paginated_items\n        };\n    }\n}",
    "prod_scheduler_01": "walker DailyCleanup {\n    obj __specs__ {\n        static has schedule: dict = {\n            \"trigger\": \"cron\",\n            \"hour\": 2, \n            \"minute\": 30\n        };\n        static has save: bool = True;\n    }\n\n    can run_cleanup;\n\n    can run_cleanup with `root entry {\n        # Logic for daily cleanup task\n        report \"Running daily cleanup task.\";\n        # ... delete old logs, etc.\n        commit();\n    }\n}",
    "prod_versioning_01": "node Document { has title: str; }\nnode Version { has content: str; has version_number: int; }\nedge HasVersion;\n\nwalker VersionManager {\n    def create_version(doc: Document, content: str) {\n        existing_versions = [doc-->:HasVersion:-->];\n        next_version_num = existing_versions.length + 1;\n        \n        new_version = spawn node::Version(\n            content=content, \n            version_number=next_version_num\n        );\n        doc +>:HasVersion:+> new_version;\n        save(doc);\n        save(new_version);\n        commit();\n        report f\"Created version {next_version_num} for {doc.title}\";\n    }\n}",
    "prod_softdelete_01": "node Message {\n    has content: str;\n    has is_deleted: bool = False;\n}\n\nwalker MessageManager {\n    def soft_delete(msg: Message) {\n        msg.is_deleted = True;\n        save(msg);\n        commit();\n        report \"Message soft-deleted.\";\n    }\n\n    def get_active_messages() -> list[Message] {\n        active_msgs = [root-->(`?Message)](?is_deleted == False);\n        report active_msgs;\n        return active_msgs;\n    }\n}",
    "prod_audit_01": "import from \"datetime\" { datetime };\n\nnode AuditLog {\n    has user_id: str;\n    has action: str;\n    has timestamp: str;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    can log_action(user_id: str, action: str, details: dict);\n\n    can log_action with `root entry {\n        log_entry = spawn here ++> node::AuditLog(\n            user_id=user_id,\n            action=action,\n            timestamp=datetime.utcnow().isoformat(),\n            details=details\n        );\n        save(log_entry);\n        commit();\n        report \"Action logged.\";\n    }\n}",
    "prod_ratelimit_01": "import from \"time\" { time };\n\nglob request_logs: dict[str, list[float]] = {};\n\nwalker RateLimiter {\n    can process_request(client_id: str) {\n        now = time();\n        window_seconds = 60;\n        max_requests = 100;\n\n        if client_id not in :g:request_logs {\n            :g:request_logs[client_id] = [];\n        }\n\n        client_timestamps = :g:request_logs[client_id];\n        valid_timestamps = [t for t in client_timestamps if now - t <= window_seconds];\n\n        if valid_timestamps.length >= max_requests {\n            report {\"error\": \"Rate limit exceeded\"};\n            disengage;\n        }\n\n        valid_timestamps.append(now);\n        :g:request_logs[client_id] = valid_timestamps;\n        report {\"status\": \"Request processed\"};\n    }\n}",
    "advanced_ai_stream_01": "import from byllm { Model };\n\ndef generate_poem(topic: str) -> str by llm(stream=True, model_name=\"gpt-4o\");\n\nwith entry {\n    print(f\"--- Poem about {topic} ---\");\n    topic = \"the Jac programming language\";\n    for token in generate_poem(topic) {\n        print(token, end=\"\");\n    }\n    print(\"\\n---------------------\");\n}",
    "advanced_ai_multimodal_01": "import from byllm { Model, Image };\n\ndef analyze_image_content(image: Image, query: str) -> str by llm(\n    model_name=\"gpt-4o\"\n);\n\nwalker ImageProcessor {\n    can process(image_path: str, query: str);\n\n    can process with `root entry {\n        img = Image(image_path);\n        analysis = analyze_image_content(image=img, query=query);\n        report analysis;\n    }\n}",
    "advanced_ai_react_01": "def get_stock_price(symbol: str) -> float {\n    # Mock function\n    if symbol == \"JAC\" { return 123.45; }\n    return 0.0;\n}\n\ndef execute_trade(symbol: str, quantity: int, action: str) -> str {\n    # Mock function\n    return f\"Executed {action} of {quantity} shares of {symbol}\";\n}\n\ndef financial_assistant(query: str) -> str by llm(\n    method='ReAct',\n    tools=[get_stock_price, execute_trade]\n);\n\nwith entry {\n    response = financial_assistant(\"What is the price of JAC and then buy 10 shares?\");\n    print(response);\n}",
    "advanced_ai_structured_01": "import from byllm { Model };\n\nobj ExtractedInfo {\n    has name: str;\n    has company: str;\n    has project: str|None;\n}\n\ndef extract_details(text: str) -> ExtractedInfo by llm(\n    \"Extract the person's name, company, and project from the text.\"\n);\n\nwith entry {\n    bio = \"Sarah works at Jac Inc. on the new AI core project.\";\n    info = extract_details(bio);\n    print(f\"Name: {info.name}, Company: {info.company}, Project: {info.project}\");\n}",
    "advanced_graph_complex_filter_01": "node User { has name: str; has age: int; has is_active: bool; }\nedge Follows { has strength: float; }\n\nwith entry {\n    # Assume graph is already populated\n    start_user = spawn node::User(name=\"start\", age=30, is_active=True);\n    \n    # Query for active users over 25, followed with strength > 0.8\n    results = [start_user -:Follows: strength > 0.8 :-> (`?User)](?age > 25, ?is_active == True);\n    \n    for user in results {\n        print(user.name);\n    }\n}",
    "advanced_graph_pathfind_01": "import from \"math\" { inf };\n\nedge Route { has distance: int; }\nnode Location { has name: str; }\n\nwalker DijkstraPathfinder {\n    has distances: dict[node, float];\n    has previous: dict[node, node|None];\n    has unvisited: set[node];\n\n    def find_path(start: Location, end: Location) {\n        all_nodes = [root-->(`?Location)];\n        self.unvisited = set(all_nodes);\n        self.distances = {n: inf for n in all_nodes};\n        self.distances[start] = 0.0;\n\n        while self.unvisited.length > 0 {\n            current = min(self.unvisited, key=lambda n: self.distances[n]);\n            if current == end { break; }\n\n            self.unvisited.remove(current);\n\n            for edge_obj in [current --->] {\n                neighbor = edge_obj.target;\n                alt_path = self.distances[current] + edge_obj.distance;\n                if alt_path < self.distances[neighbor] {\n                    self.distances[neighbor] = alt_path;\n                    self.previous[neighbor] = current;\n                }\n            }\n        }\n        report self.distances[end];\n    }\n}",
    "advanced_graph_cycle_01": "node Task { has name: str; }\nedge DependsOn;\n\nwalker CycleDetector {\n    has visited: set[node] = {};\n    has recursion_stack: list[node] = [];\n\n    def find_cycle(start_node: Task) -> bool {\n        self.visited.add(start_node);\n        self.recursion_stack.append(start_node);\n\n        for neighbor in [start_node-->:DependsOn:-->] {\n            if neighbor not in self.visited {\n                if self.find_cycle(neighbor) {\n                    report \"Cycle found!\";\n                    return True;\n                }\n            } elif neighbor in self.recursion_stack {\n                report \"Cycle found!\";\n                return True;\n            }\n        }\n        self.recursion_stack.pop();\n        return False;\n    }\n}",
    "advanced_persist_transaction_01": "node User { has name: str; }\nnode Profile { has bio: str; }\n\nwith entry {\n    # Create a user and their profile in a single transaction\n    user1 = spawn root ++> node::User(name=\"Alex\");\n    profile1 = spawn root ++> node::Profile(bio=\"Loves Jac\");\n    \n    # Queue changes for saving\n    save(user1);\n    save(profile1);\n    \n    # Commit all queued changes to the database at once\n    commit();\n    print(\"User and profile committed.\");\n}",
    "advanced_persist_reference_01": "node Product { has name: str; has price: float; }\nobj Order { has product_id_ref: str; has quantity: int; }\n\nwith entry {\n    # Create and persist a product\n    laptop = spawn root ++> node::Product(name=\"JacBook Pro\", price=1999.99);\n    save(laptop);\n    commit();\n\n    # Create an order object that references the product by its ID\n    order = Order(product_id_ref=laptop.jid, quantity=2);\n\n    # Later, retrieve the product using the reference\n    product_node = &order.product_id_ref;\n    print(f\"Order for {order.quantity} of {product_node.name}\");\n    assert product_node.price == 1999.99;\n}",
    "advanced_cloud_webhook_01": "import from jaclang.core.auth { jac_token_check };\n\nwalker SecureWebhook {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has auth: bool = True; # Enables default auth check\n        static has path: str = \"/hooks/secure_data\";\n    }\n\n    # This walker will only run if the request provides a valid Jac auth token\n    can process_payload(payload: dict);\n\n    can process_payload with `root entry {\n        report {\"status\": \"authenticated\", \"message\": \"Payload received successfully\"};\n        # Process the payload here\n    }\n}",
    "advanced_cloud_async_retrieve_01": "import from \"asyncio\" { sleep };\n\nasync walker HeavyComputation {\n    can compute;\n    can compute with `root entry {\n        report \"Starting heavy computation...\";\n        await sleep(0.2); # Simulate long-running task\n        report \"Computation finished.\";\n    }\n}\n\nwith entry {\n    # Spawn the async walker, which runs in the background\n    task_handle = spawn HeavyComputation();\n    task_id = task_handle;\n    print(f\"Task started with ID: {task_id}\");\n\n    # Get a reference to the running task\n    task = &task_id;\n\n    # Poll for status (in a real app, you'd do this from another endpoint)\n    while task.__jac__.status == \"running\" {\n        print(\"Task is still running...\");\n        # In a real scenario, you would not block like this\n    }\n\n    print(f\"Task finished with status: {task.__jac__.status}\");\n    print(f\"Reports: {task.__jac__.reports}\");\n}",
    "advanced_cloud_query_params_01": "node Item { has name: str; has category: str; }\n\nwalker ItemSearch {\n    obj __specs__ {\n        static has methods: list = [\"get\"];\n        static has path: str = \"/search/items\";\n        # Only 'category' and 'limit' will be taken from URL query params\n        static has as_query: list = [\"category\", \"limit\"];\n    }\n\n    can find_items(category: str, limit: int = 10, sort_by: str = \"name\");\n\n    can find_items with `root entry {\n        # 'sort_by' would need to be in the request body for a GET, which is unusual,\n        # or the default value is used.\n        results = [root-->(`?Item)](?category==category);\n        report {\"found\": results[:limit]};\n    }\n}",
    "integration_error_handling_01": "obj ConfigError { has details: str; }\n\nwalker ConfigLoader {\n    def load(config_data: dict) -> str {\n        try {\n            api_key = config_data[\"api_key\"];\n            if api_key.length < 10 {\n                raise ConfigError(details=\"API key is too short\");\n            }\n            return \"Config loaded successfully\";\n        } except KeyError as e {\n            print(\"Error: Missing 'api_key' in config.\");\n            return \"fallback_config\"; // Fallback value\n        } except ConfigError as e {\n            print(f\"Error: Invalid config - {e.details}\");\n            return \"fallback_config\"; // Fallback value\n        }\n    }\n}",
    "integration_external_api_01": "import from \"requests\" { get, HTTPError };\n\nwalker ApiClient {\n    def fetch_user_data(user_id: int) -> dict {\n        url = f\"https://jsonplaceholder.typicode.com/users/{user_id}\";\n        try {\n            response = get(url);\n            response.raise_for_status(); # Raises HTTPError for bad responses (4xx or 5xx)\n            data = response.json();\n            report data;\n            return data;\n        } except HTTPError as e {\n            error_msg = f\"HTTP error occurred: {e}\";\n            report {\"error\": error_msg};\n            return {\"error\": error_msg};\n        } except Exception as e {\n            error_msg = f\"An unexpected error occurred: {e}\";\n            report {\"error\": error_msg};\n            return {\"error\": error_msg};\n        }\n    }\n}",
    "integration_conditional_visit_01": "node Step { has is_final: bool = False; }\n\nwalker WorkflowRunner {\n    can run;\n    can run with Step entry {\n        report here;\n        if here.is_final {\n            report \"Reached final step.\";\n            disengage;\n        }\n        # Only visit next if there is a next step\n        visit [-->] else {\n            report \"Workflow finished at the end of the path.\";\n            disengage;\n        };\n    }\n}\n\nwith entry {\n    s1 = spawn node::Step();\n    s2 = spawn node::Step();\n    s3 = spawn node::Step(is_final=True);\n    s4 = spawn node::Step();\n    s1 ++> s2 ++> s3 ++> s4;\n    s1 spawn WorkflowRunner();\n}",
    "integration_multi_ability_01": "walker LifecycleWalker {\n    can process;\n}\n\nnode ProcessingNode {\n    has data: str;\n\n    can process with LifecycleWalker entry {\n        report f\"Entering node with data: {self.data}\";\n        # Modify data on entry\n        self.data = self.data.upper();\n    }\n\n    can process with LifecycleWalker exit {\n        report f\"Exiting node. Final data: {self.data}\";\n    }\n}\n\nwith entry {\n    p_node = spawn node::ProcessingNode(data=\"hello\");\n    p_node spawn LifecycleWalker();\n}",
    "integration_batch_process_01": "node Record { has value: str; }\n\nwalker BatchIngestor {\n    def ingest(data_list: list[str]) {\n        report f\"Ingesting {data_list.length} records.\";\n        for item in data_list {\n            new_record = spawn root ++> node::Record(value=item);\n            save(new_record); # Queue each new record for saving\n        }\n        # Commit all queued records in a single transaction\n        commit();\n        report \"Batch ingest complete and committed.\";\n    }\n}\n\nwith entry {\n    w = BatchIngestor();\n    w.ingest([\"data1\", \"data2\", \"data3\"]);\n}",
    "integration_visitor_communication_01": "walker PathCounter {\n    has nodes_visited: int = 0;\n    can count_path;\n}\n\nnode PathNode {\n    can count_path with PathCounter entry {\n        # Access and modify the walker's state via the 'visitor' keyword\n        visitor.nodes_visited += 1;\n        report f\"Visited node. Count is now: {visitor.nodes_visited}\";\n    }\n}\n\nwith entry {\n    n1 = spawn node::PathNode();\n    n2 = spawn node::PathNode();\n    n3 = spawn node::PathNode();\n    n1 ++> n2 ++> n3;\n    n1 spawn PathCounter();\n}",
    "integration_root_ability_01": "walker Initializer {\n    has setup_complete: bool = false;\n    can initialize;\n\n    can initialize with `root entry {\n        report \"Performing setup on root node.\";\n        self.setup_complete = True;\n    }\n\n    can initialize with node entry {\n        if not self.setup_complete {\n            report \"Error: Setup must be run on root first.\";\n            disengage;\n        }\n        report \"Visiting a regular node after setup.\";\n    }\n}\n\nwith entry {\n    root spawn Initializer();\n}",
    "integration_edge_traversal_01": "node User { has name: str; }\nedge Follows { has since: int; }\n\nwalker FollowerAnalyzer {\n    can analyze_follows;\n    can analyze_follows with User entry {\n        report f\"Analyzing outgoing follows for {here.name}:\";\n        # Use [here --->] to get all outgoing edge objects\n        outgoing_edges = [here --->];\n        if outgoing_edges.length == 0 {\n            report \"  No outgoing follows.\";\n        }\n        for edge_obj in outgoing_edges {\n            followed_user = edge_obj.target;\n            report f\"  Follows {followed_user.name} since {edge_obj.since}\";\n        }\n    }\n}\n\nwith entry {\n    u1 = spawn node::User(name=\"User1\");\n    u2 = spawn node::User(name=\"User2\");\n    u3 = spawn node::User(name=\"User3\");\n    u1 +>:Follows(since=2022):+> u2;\n    u1 +>:Follows(since=2023):+> u3;\n    u1 spawn FollowerAnalyzer();\n}"
  }
}