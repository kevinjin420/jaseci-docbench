{
  "metadata": {
    "model": "gemini/gemini-2.5-pro-preview-03-25",
    "model_alias": "gemini-pro",
    "variant": "mini_v3",
    "test_suite": "full",
    "total_tests": 130,
    "temperature": 0.1,
    "max_tokens": 16000,
    "batch_size": 45,
    "num_batches": 3
  },
  "responses": {
    "basic_01": "with entry {\n    print(\"Hello, Jac!\");\n}",
    "basic_02": "glob counter: int = 0;\n\nwith entry {\n    print(:g:counter);\n}",
    "basic_03": "enum Status {\n    PENDING,\n    ACTIVE,\n    COMPLETED\n}",
    "basic_04": "def add_numbers(a: int, b: int) -> int {\n    return a + b;\n}",
    "basic_05": "with entry {\n    for i = 1 to i <= 5 by i += 1 {\n        print(i);\n    }\n}",
    "basic_06": "#*\nThis is a multi-line comment.\n*#",
    "basic_07": "with entry {\n    name: str = \"Jac\";\n    message: str = f\"Hello, {name}!\";\n    print(message);\n}",
    "basic_08": "with entry {\n    my_var: str | int = \"hello\";\n}",
    "basic_09": "with entry {\n    squares: list[int] = [i * i for i in [1, 2, 3, 4, 5]];\n    print(squares);\n}",
    "basic_10": "with entry {\n    num: int = 0;\n    if num > 0 {\n        print(\"Positive\");\n    } elif num < 0 {\n        print(\"Negative\");\n    } else {\n        print(\"Zero\");\n    }\n}",
    "control_01": "with entry {\n    i: int = 1;\n    while i <= 5 {\n        print(i);\n        i += 1;\n    }\n}",
    "control_02": "with entry {\n    value: int = 2;\n    match value {\n        case 1: print(\"One\");\n        case 2: print(\"Two\");\n        case _: print(\"Other\");\n    }\n}",
    "control_03": "with entry {\n    for i = 0 to i < 10 by i += 1 {\n        if i == 5 {\n            break;\n        }\n        print(i);\n    }\n}",
    "control_04": "with entry {\n    for i = 1 to i <= 10 by i += 1 {\n        if i % 2 == 0 {\n            continue;\n        }\n        print(i);\n    }\n}",
    "collection_01": "with entry {\n    my_set: set[int] = {1, 2};\n    my_set.add(3);\n    print(my_set);\n}",
    "collection_02": "with entry {\n    person_data: tuple[str, int] = (\"Alice\", 30);\n}",
    "collection_03": "with entry {\n    squares_dict: dict[int, int] = {x: x * x for x in [1, 2, 3]};\n    print(squares_dict);\n}",
    "collection_04": "with entry {\n    names: list[str] = [\"Alice\", \"Bob\"];\n    for name in names {\n        print(name);\n    }\n}",
    "collection_05": "with entry {\n    ages: dict[str, int] = {\"Alice\": 30};\n    age: int | None = ages.get(\"Alice\");\n    print(age);\n}",
    "type_01": "with entry {\n    value: any = \"hello\";\n    if isinstance(value, str) {\n        print(\"It is a string.\");\n    }\n}",
    "obj_01": "obj Person {\n    has name: str;\n    has age: int;\n}",
    "obj_02": "obj Car {\n    has brand: str;\n    has year: int;\n\n    def get_info(self) -> str {\n        return f\"{self.year} {self.brand}\";\n    }\n}",
    "obj_03": "obj Person {\n    has name: str;\n    has age: int;\n}\n\nobj Student(Person) {\n    has grade: str;\n}",
    "obj_04": "obj MyObject {\n    has value: int;\n\n    def postinit(self) {\n        print(\"Object initialized\");\n    }\n}",
    "obj_05": "with entry {\n    square = lambda x: int: x * x;\n    print(square(5));\n}",
    "obj_06": "obj Secret {\n    :priv: has secret_code: str = \"1234\";\n}",
    "obj_07": "obj PublicInfo {\n    :pub: has info: str = \"This is public\";\n}",
    "obj_08": "def my_decorator(func) {\n    def wrapper() {\n        print(\"Before\");\n        func();\n        print(\"After\");\n    }\n    return wrapper;\n}\n\n@my_decorator\ndef say_hello() {\n    print(\"Hello\");\n}",
    "obj_09": "from typing import Callable;\n\ndef execute(callback: Callable[[], None]) {\n    callback();\n}\n\ndef my_func() {\n    print(\"Called!\");\n}\n\nwith entry {\n    execute(my_func);\n}",
    "obj_10": "def greet(name: str = \"World\") -> str {\n    return f\"Hello, {name}!\";\n}",
    "graph_01": "node City {\n    has name: str;\n    has population: int;\n}",
    "graph_02": "node City {\n    has name: str;\n}\n\nwith entry {\n    sf = spawn node::City(name=\"SF\");\n    la = spawn node::City(name=\"LA\");\n    sf <++> la;\n}",
    "graph_03": "node City { has name: str; }\nedge Road { has distance: float; }\n\nwith entry {\n    sf = spawn node::City(name=\"SF\");\n    la = spawn node::City(name=\"LA\");\n    sf +>:Road(distance=380.0):+> la;\n}",
    "graph_04": "node Place {\n    has name: str;\n    can greet with entry {\n        print(f\"Welcome to {self.name}!\");\n    }\n}",
    "graph_05": "walker Explorer { has name: str; }\n\nnode Place {\n    has name: str;\n    can announce with entry {\n        print(f\"{visitor.name} has arrived at {self.name}.\");\n    }\n}",
    "graph_06": "node Point;\n\nwith entry {\n    a = spawn node::Point;\n    b = spawn node::Point;\n    a ++> b;\n}",
    "graph_07": "node MyData;\n\nwith entry {\n    my_node = spawn node::MyData;\n    `root ++> my_node;\n}",
    "graph_08": "node Room {\n    has name: str;\n    can farewell with exit {\n        print(f\"Leaving {self.name}.\");\n    }\n}",
    "graph_09": "edge TollRoad {\n    has fee: float;\n    can charge with entry {\n        print(f\"Toll paid: ${self.fee}\");\n    }\n}",
    "graph_10": "node Step;\n\nwith entry {\n    s1 = spawn node::Step;\n    s2 = spawn node::Step;\n    s3 = spawn node::Step;\n    s1 ++> s2 ++> s3;\n}",
    "walker_01": "walker Explorer {\n    has visited_count: int = 0;\n}",
    "walker_02": "node Place;\n\nwalker Traverser {\n    can traverse with `root entry {\n        visit [-->];\n    }\n}",
    "walker_03": "node City;\nnode Town;\n\nwalker CityVisitor {\n    can visit_cities with `root entry {\n        visit [-->(`?City)];\n    }\n}",
    "walker_04": "node Place { has name: str; }\n\nwalker Inspector {\n    can inspect with Place entry {\n        print(f\"Inspecting: {here.name}\");\n    }\n}",
    "walker_05": "node Item { has value: int; }\n\nwalker Collector {\n    can collect with Item entry {\n        report here.value;\n    }\n}",
    "walker_06": "node MyNode;\nwalker MyWalker;\n\nwith entry {\n    start_node = spawn node MyNode;\n    start_node spawn MyWalker();\n}",
    "walker_07": "walker MyWalker;\n\nwith entry {\n    `root spawn MyWalker();\n}",
    "walker_08": "walker IncomingWalker {\n    visit [<--];\n}",
    "walker_09": "walker ExitingWalker {\n    can on_exit;\n    can on_exit with `root exit {\n        print(\"Walker has finished its traversal.\");\n    }\n}",
    "walker_10": "walker ReportCurrentNodeWalker {\n    visit [-->] {\n        report here;\n    }\n}",
    "advanced_01": "node Product {\n    has name: str;\n    has price: int;\n}\n\nwalker CostlyProductFinder {\n    visit [--> (`?Product)](?price > 100);\n}",
    "advanced_02": "node User;\nedge Follows;\n\nwalker FollowerWalker {\n    visit [->:Follows:->];\n}",
    "advanced_03": "node Step;\n\nwalker ThreeHopWalker {\n    visit [-->-->-->] {\n        report here;\n    }\n}",
    "advanced_04": "walker EarlyExitWalker {\n    has count: int = 0;\n    visit [-->] {\n        self.count += 1;\n        if self.count >= 5 {\n            disengage;\n        }\n    }\n}",
    "advanced_05": "node Checkpoint;\nwalker Player;\n\nedge Path {\n    can announce_arrival with Player entry {\n        print(\"Player is on the path.\");\n    }\n}",
    "advanced_06": "walker DfsWalker {\n    has visited: set[node] = {};\n\n    def traverse(current: node) {\n        if current not in self.visited {\n            self.visited.add(current);\n            report current;\n            for neighbor in [current-->] {\n                self.traverse(neighbor);\n            }\n        }\n    }\n\n    with entry {\n        self.traverse(here);\n    }\n}",
    "advanced_07": "node Waypoint;\n\nwalker ItineraryWalker {\n    has path: list[Waypoint];\n    with entry {\n        visit self.path;\n    }\n}",
    "advanced_08": "node Person {\n    has name: str;\n    has age: int;\n}\n\nwalker AdultFinder {\n    visit [--> (`?Person)](?age > 18);\n}",
    "advanced_09": "node City;\nedge Route {\n    has distance: int;\n}\n\nwalker LongRouteWalker {\n    visit [->:Route:distance > 500:->];\n}",
    "advanced_10": "with entry {\n    n1 = spawn node {};\n    n2 = spawn node {};\n    n1 ++> n2;\n    del [n1 ---> n2];\n}",
    "ai_01": "import from byllm { Model };",
    "ai_02": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");",
    "ai_03": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef generate_greeting(topic: str) -> str by llm(\"Generate a simple greeting about {topic}.\");",
    "ai_04": "obj Book {\n    sem \"Represents a book with a title and author.\"\n    has title: str;\n    has author: str;\n}",
    "ai_05": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\nenum Sentiment {\n    POSITIVE,\n    NEGATIVE,\n    NEUTRAL\n}\n\ndef classify_sentiment(text: str) -> Sentiment by llm;",
    "ai_06": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef solve_logic_puzzle(puzzle: str) -> str by llm(method='Reason');",
    "ai_07": "import from byllm { Model };\n\ndef get_stock_price(symbol: str) -> float {\n    # Dummy implementation\n    return 150.0;\n}\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\ndef stock_analyzer(query: str) -> str by llm(method='ReAct', tools=[get_stock_price]);",
    "ai_08": "import from byllm { Image };",
    "ai_09": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\nobj Recipe {\n    has name: str;\n    has ingredients: list[str];\n\n    def suggest_variation(self) -> str by llm(\"Suggest a variation for the recipe '{self.name}'.\");\n}",
    "ai_10": "import from byllm { Model };\n\nglob llm: Model = Model(model_name=\"gpt-4o-mini\");\n\nobj User {\n    has name: str;\n    has email: str;\n}\n\ndef parse_user_info(text: str) -> User by llm;",
    "cloud_01": "walker user_api {\n    obj __specs__ {\n        static has methods: list[str] = [\"GET\", \"POST\"];\n    }\n}",
    "cloud_02": "walker public_api {\n    obj __specs__ {\n        static has auth: bool = False;\n    }\n}",
    "cloud_03": "walker custom_endpoint {\n    obj __specs__ {\n        static has path: str = \"/api/v2/data\";\n    }\n}",
    "cloud_04": "walker search_walker {\n    has query: str;\n    has limit: int;\n\n    obj __specs__ {\n        static has as_query: list[str] = [\"*\"];\n    }\n}",
    "cloud_05": "walker internal_utility {\n    obj __specs__ {\n        static has private: bool = True;\n    }\n}",
    "cloud_06": "async walker background_job {\n    has url: str;\n    with entry {\n        print(f\"Starting job for {self.url}\");\n        # Simulate async work\n    }\n}",
    "cloud_07": "with entry {\n    task_id = \"some_async_task_id\";\n    task_ref = &task_id;\n    status = task_ref.__jac__.status;\n    print(status);\n}",
    "cloud_08": "walker github_webhook {\n    obj __specs__ {\n        static has methods: list[str] = [\"POST\"];\n        static has path: str = \"/webhooks/github\";\n        static has auth: bool = False;\n    }\n}",
    "cloud_09": "node UserProfile {\n    has username: str;\n}\n\nwith entry {\n    new_user = spawn node UserProfile(username=\"jason\");\n    `root ++> new_user;\n}",
    "cloud_10": "obj ApiResponse {\n    has status: str;\n    has data: dict[str, any];\n}\n\nwalker data_fetcher {\n    def get_data(self) -> ApiResponse {\n        return ApiResponse(status=\"success\", data={\"id\": 1, \"value\": \"test\"});\n    }\n    with entry {\n        report self.get_data();\n    }\n}",
    "import_01": "import math;\n\nwith entry {\n    val = math.sqrt(25);\n    print(val);\n}",
    "import_02": "import from os { path };\n\nwith entry {\n    cwd = path.abspath(\".\");\n    print(cwd);\n}",
    "import_03": "include \"another_module.jac\";",
    "import_04": "import json as j;\n\nwith entry {\n    json_string = j.dumps({\"key\": \"value\"});\n    print(json_string);\n}",
    "file_01": "with entry {\n    with open(\"readme.txt\", \"r\") as f {\n        content = f.read();\n        print(content);\n    }\n}",
    "file_02": "with entry {\n    with open(\"log.txt\", \"w\") as f {\n        f.write(\"Log entry.\");\n    }\n}",
    "file_03": "import json;\n\nwith entry {\n    with open(\"data.json\", \"r\") as f {\n        data = json.load(f);\n        print(data);\n    }\n}",
    "impl_01": "obj Greeter {\n    def say_hello(name: str) -> str;\n}\n\nimpl Greeter.say_hello {\n    return f\"Hello, {name}!\";\n}",
    "advanced_func_01": "def sum_numbers(*args: int|float) -> float {\n    total: float = 0.0;\n    for num in args {\n        total += num;\n    }\n    return total;\n}",
    "advanced_func_02": "def create_user(**kwargs: str|int) {\n    for key, value in kwargs.items() {\n        print(f\"Setting {key} to {value}\");\n    }\n}",
    "integration_01": "node Person {\n    has name: str;\n}\n\nedge Friendship {\n    has since: str;\n}\n\nwalker SocialGrapher {\n    can traverse;\n    def traverse(start_node: Person) {\n        visit start_node;\n        report here.name;\n        visit [-->];\n    }\n}\n\nwith entry {\n    p1 = spawn node::Person(name=\"Alice\");\n    p2 = spawn node::Person(name=\"Bob\");\n    p3 = spawn node::Person(name=\"Charlie\");\n    p1 +>:Friendship(since=\"2022\"):+> p2;\n    p2 +>:Friendship(since=\"2023\"):+> p3;\n    p1 +>:Friendship(since=\"2021\"):+> p3;\n    spawn p1 walker::SocialGrapher;\n}",
    "integration_02": "enum StateType { START, MIDDLE, END }\n\nnode State {\n    has type: StateType;\n}\n\nedge Transition {\n    has event: str;\n}\n\nwalker StateMachine {\n    has current_state: State;\n    can process_event(event_name: str) {\n        visit self.current_state;\n        visit [->:Transition:event==event_name:->] else {\n            report \"Invalid transition\";\n            disengage;\n        }\n        self.current_state = here;\n        report f\"Transitioned to {here.type}\";\n    }\n}\n\nwith entry {\n    start = spawn node::State(type=StateType.START);\n    middle = spawn node::State(type=StateType.MIDDLE);\n    end = spawn node::State(type=StateType.END);\n    start +>:Transition(event=\"go\"):+> middle;\n    middle +>:Transition(event=\"finish\"):+> end;\n    sm = spawn walker::StateMachine(current_state=start);\n    sm.process_event(event_name=\"go\");\n    sm.process_event(event_name=\"finish\");\n}",
    "integration_03": "enum CustomError { DIVIDE_BY_ZERO }\n\nwalker ErrorHandler {\n    can perform_calculation(a: int, b: int) {\n        try {\n            if b == 0 {\n                # In a real scenario, you might raise a custom error\n                # For this example, we simulate the condition and report\n                report {\"error\": \"Division by zero attempted\"};\n            } else {\n                result = a / b;\n                report {\"result\": result};\n            }\n        } except Exception as e {\n            report f\"An unexpected error occurred: {e}\";\n        }\n    }\n}\n\nwith entry {\n    w = spawn walker::ErrorHandler();\n    w.perform_calculation(a=10, b=2);\n    w.perform_calculation(a=10, b=0);\n}",
    "integration_04": "import from \"asyncio\" as asyncio;\n\nasync def fetch_data(url: str) -> dict {\n    # Simulate a network request\n    print(f\"Fetching from {url}...\");\n    await asyncio.sleep(1);\n    print(\"Fetch complete.\");\n    return {\"data\": \"some data\"};\n}\n\nwith entry {\n    result = await fetch_data(\"https://example.com\");\n    print(result);\n}",
    "integration_05": "node Item {\n    has name: str;\n    has value: int;\n}\n\nwalker CrudWalker {\n    can create_item(name: str, value: int) -> Item {\n        new_item = spawn node::Item(name=name, value=value);\n        root ++> new_item;\n        commit();\n        report new_item;\n        return new_item;\n    }\n\n    can read_item(item_id: str) -> Item|None {\n        item = &item_id;\n        if item {\n            report item;\n            return item;\n        }\n        report null;\n        return null;\n    }\n\n    can update_item(item_id: str, new_name: str) -> bool {\n        item = &item_id;\n        if item {\n            item.name = new_name;\n            commit();\n            report true;\n            return true;\n        }\n        report false;\n        return false;\n    }\n\n    can delete_item(item_id: str) -> bool {\n        item = &item_id;\n        if item {\n            del item;\n            commit();\n            report true;\n            return true;\n        }\n        report false;\n        return false;\n    }\n}\n\nwith entry {\n    crud = spawn walker::CrudWalker();\n    item = crud.create_item(name=\"Test\", value=100);\n    item_id = item.jid;\n    crud.read_item(item_id=item_id);\n    crud.update_item(item_id=item_id, new_name=\"Updated Test\");\n    crud.delete_item(item_id=item_id);\n}",
    "integration_06": "import from byllm { Model };\n\nnode Document {\n    has content: str;\n}\n\ndef summarize(text: str) -> str by llm(model_name=\"gpt-4o\");\n\nwalker DocSummarizer {\n    can summarize_all_docs() {\n        visit root;\n        visit [-->(`?Document)];\n        summary = summarize(text=here.content);\n        report {\"doc_id\": here.jid, \"summary\": summary};\n    }\n}\n\nwith entry {\n    doc1 = spawn node::Document(content=\"Jac is a programming language designed for AI and graph-based applications.\");\n    doc2 = spawn node::Document(content=\"It combines object-oriented, node-based, and agent-oriented programming paradigms.\");\n    root ++> doc1;\n    root ++> doc2;\n    commit();\n    summarizer = spawn walker::DocSummarizer();\n    summarizer.summarize_all_docs();\n}",
    "integration_07": "node DataPoint {\n    has key: str;\n    has value: any;\n}\n\nwalker ApiHandler {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/data\";\n        static has auth: bool = false;\n    }\n\n    can add_data(key: str, value: any) {\n        new_point = spawn node::DataPoint(key=key, value=value);\n        root ++> new_point;\n        # Auto-persists because it's connected to root\n        report {\"status\": \"created\", \"id\": new_point.jid};\n    }\n}\n\nwith entry {\n    # This walker is designed to be used via Jac Cloud `jac serve`\n    # To test locally, you can spawn and call it.\n    handler = spawn walker::ApiHandler();\n    handler.add_data(key=\"test_key\", value=\"test_value\");\n    print([root-->]);\n}",
    "integration_08": "node City {\n    has name: str;\n}\n\nwalker BfsWalker {\n    has visited: set[str] = {};\n    has queue: list[City] = [];\n\n    can traverse(start_node: City) {\n        self.queue.append(start_node);\n        self.visited.add(start_node.jid);\n\n        while self.queue {\n            current_node = self.queue.pop(0);\n            report current_node.name;\n            \n            visit current_node;\n            for neighbor in [-->] {\n                if neighbor.jid not in self.visited {\n                    self.visited.add(neighbor.jid);\n                    self.queue.append(neighbor);\n                }\n            }\n        }\n    }\n}\n\nwith entry {\n    a = spawn node::City(name=\"A\");\n    b = spawn node::City(name=\"B\");\n    c = spawn node::City(name=\"C\");\n    d = spawn node::City(name=\"D\");\n    a ++> b; a ++> c; b ++> d;\n    w = spawn walker::BfsWalker();\n    w.traverse(start_node=a);\n}",
    "integration_09": "enum TaskStatus { PENDING, IN_PROGRESS, COMPLETED }\n\nnode Task {\n    has name: str;\n    has status: TaskStatus = TaskStatus.PENDING;\n    can execute with WorkflowManager entry {\n        if self.status == TaskStatus.PENDING {\n            self.status = TaskStatus.IN_PROGRESS;\n            report f\"Task '{self.name}' started.\";\n            # Simulate work\n            self.status = TaskStatus.COMPLETED;\n            report f\"Task '{self.name}' completed.\";\n            visitor.completed_tasks.append(self.name);\n        }\n    }\n}\n\nedge DependsOn {}\n\nwalker WorkflowManager {\n    has completed_tasks: list[str] = [];\n    can run_workflow(start_task: Task) {\n        visit start_task;\n        visit [-->:DependsOn:-->];\n    }\n}\n\nwith entry {\n    t1 = spawn node::Task(name=\"Step 1\");\n    t2 = spawn node::Task(name=\"Step 2\");\n    t3 = spawn node::Task(name=\"Step 3\");\n    t2 +>:DependsOn:+> t1;\n    t3 +>:DependsOn:+> t2;\n    manager = spawn walker::WorkflowManager();\n    manager.run_workflow(start_task=t3);\n}",
    "integration_10": "node User {\n    has name: str;\n}\n\nnode Product {\n    has name: str;\n}\n\nedge Liked {}\n\nwalker Recommender {\n    can recommend_for(user: User) -> list[Product] {\n        liked_products = [user-->:Liked:-->];\n        friends = [user<--:Liked:<--:Liked:-->];\n        recommendations: set = {};\n\n        for friend in friends {\n            if friend.jid != user.jid {\n                friend_likes = [friend-->:Liked:-->];\n                for product in friend_likes {\n                    if product not in liked_products {\n                        recommendations.add(product);\n                    }\n                }\n            }\n        }\n        report recommendations;\n        return list(recommendations);\n    }\n}\n\nwith entry {\n    u1 = spawn node::User(name=\"Alice\");\n    u2 = spawn node::User(name=\"Bob\");\n    p1 = spawn node::Product(name=\"Apple\");\n    p2 = spawn node::Product(name=\"Banana\");\n    p3 = spawn node::Product(name=\"Cherry\");\n\n    u1 +>:Liked:+> p1;\n    u1 +>:Liked:+> p2;\n    u2 +>:Liked:+> p2;\n    u2 +>:Liked:+> p3;\n\n    rec = spawn walker::Recommender();\n    rec.recommend_for(user=u1);\n}",
    "prod_websocket_01": "import from jaclang.core.jac_socket as socket;\n\nwalker BroadcastWalker {\n    obj __specs__ {\n        static has methods: list = [\"websocket\"];\n        static has path: str = \"/ws/broadcast\";\n    }\n\n    can send_message(channel: str, message: str) with `root entry {\n        # This would be triggered by a client message\n        # Here we simulate the broadcast action\n        payload = {\"channel\": channel, \"content\": message};\n        socket.notify_channels([channel], payload);\n        report f\"Message sent to channel {channel}\";\n    }\n}\n\nwith entry {\n    # This walker is intended for a Jac Cloud server environment.\n    # Spawning it here demonstrates its structure.\n    w = spawn walker::BroadcastWalker();\n    print(\"BroadcastWalker is ready for WebSocket connections.\");\n}",
    "prod_permissions_01": "import from jaclang.core.permissions as perm;\n\nnode Document {\n    has owner_id: str;\n    has content: str;\n\n    def __jac_access__(self, accessor: walker) -> list[str] {\n        if accessor.owner_id == self.owner_id {\n            return [perm.ReadPerm, perm.WritePerm, perm.ConnectPerm];\n        } else {\n            return [perm.ReadPerm];\n        }\n    }\n}\n\nwalker UserSession {\n    has owner_id: str;\n\n    can read_doc(doc: Document) {\n        # _.check_read_access(doc) would be called implicitly\n        report doc.content;\n    }\n\n    can write_doc(doc: Document, new_content: str) {\n        # _.check_write_access(doc) would be called implicitly\n        doc.content = new_content;\n        commit();\n        report \"Write successful\";\n    }\n}\n\nwith entry {\n    doc = spawn node::Document(owner_id=\"user-123\", content=\"secret\");\n    \n    owner_session = spawn walker::UserSession(owner_id=\"user-123\");\n    other_session = spawn walker::UserSession(owner_id=\"user-456\");\n\n    # This will succeed\n    owner_session.write_doc(doc=doc, new_content=\"new secret\");\n\n    # This would fail in a real environment with permission checks\n    # other_session.write_doc(doc=doc, new_content=\"hacked\");\n}",
    "prod_cache_01": "import from \"time\" as time;\n\nwalker CachingWalker {\n    has cache: dict = {};\n    has expiry: dict = {};\n    has ttl: int = 60; # Time-to-live in seconds\n\n    def get_expensive_data(key: str) -> str {\n        # Simulate a slow operation\n        print(\"Regenerating data...\");\n        time.sleep(1);\n        return f\"Data for {key} at {time.time()}\";\n    }\n\n    can fetch(key: str) -> str {\n        current_time = time.time();\n        if key in self.cache and current_time < self.expiry.get(key, 0) {\n            report \"Returning from cache\";\n            return self.cache[key];\n        } else {\n            report \"Cache miss or expired\";\n            data = self.get_expensive_data(key);\n            self.cache[key] = data;\n            self.expiry[key] = current_time + self.ttl;\n            return data;\n        }\n    }\n}\n\nwith entry {\n    w = spawn walker::CachingWalker();\n    w.fetch(\"my_key\"); // Regenerates\n    w.fetch(\"my_key\"); // From cache\n}",
    "prod_validation_01": "obj UserProfile {\n    has username: str;\n    has age: int;\n}\n\nwalker ProfileValidator {\n    can create_profile(username: str, age: int) -> UserProfile|None {\n        if len(username) < 3 or len(username) > 20 {\n            report {\"error\": \"Username must be between 3 and 20 characters\"};\n            return null;\n        }\n        if age < 18 or age > 120 {\n            report {\"error\": \"Age must be between 18 and 120\"};\n            return null;\n        }\n        profile = spawn obj::UserProfile(username=username, age=age);\n        report {\"success\": true, \"profile\": profile};\n        return profile;\n    }\n}\n\nwith entry {\n    validator = spawn walker::ProfileValidator();\n    validator.create_profile(username=\"Al\", age=25); // Fails username\n    validator.create_profile(username=\"Alice\", age=17); // Fails age\n    validator.create_profile(username=\"Alice\", age=30); // Succeeds\n}",
    "prod_pagination_01": "node Product {\n    has name: str;\n    has category: str;\n}\n\nwalker ProductFinder {\n    can find_products(category: str, page: int=1, page_size: int=10) -> dict {\n        all_matches = [root-->(`?Product)](?category==category);\n        total_items = len(all_matches);\n        \n        start_index = (page - 1) * page_size;\n        end_index = start_index + page_size;\n        \n        paginated_items = all_matches[start_index:end_index];\n        \n        result = {\n            \"total\": total_items,\n            \"page\": page,\n            \"page_size\": page_size,\n            \"items\": paginated_items\n        };\n        report result;\n        return result;\n    }\n}\n\nwith entry {\n    for i=0 to i<25 by i+=1 {\n        p = spawn node::Product(name=f\"Item {i}\", category=\"A\");\n        root ++> p;\n    }\n    commit();\n    finder = spawn walker::ProductFinder();\n    finder.find_products(category=\"A\", page=2, page_size=10);\n}",
    "prod_scheduler_01": "node Report {\n    has generated_at: str;\n}\n\nwalker DailyReportGenerator {\n    # This __specs__ configuration is hypothetical, based on common patterns\n    # for cloud-based schedulers.\n    obj __specs__ {\n        static has schedule: str = \"0 0 * * *\"; # Daily at midnight\n        static has save: bool = True; # Auto-commit changes\n    }\n\n    can run() with `root entry {\n        import from \"datetime\" as datetime;\n        now = datetime.datetime.utcnow().isoformat();\n        new_report = spawn node::Report(generated_at=now);\n        root ++> new_report;\n        report f\"Daily report generated at {now}\";\n    }\n}\n\nwith entry {\n    # This walker would be automatically triggered by Jac Cloud.\n    # We can manually run it for testing.\n    w = spawn walker::DailyReportGenerator();\n    w.run();\n}",
    "prod_versioning_01": "node Document {\n    has name: str;\n}\n\nnode Version {\n    has content: str;\n    has version_number: int;\n}\n\nedge CurrentVersion {}\nedge PreviousVersion {}\n\nwalker DocManager {\n    can create_doc(name: str, content: str) -> Document {\n        doc = spawn node::Document(name=name);\n        v1 = spawn node::Version(content=content, version_number=1);\n        doc +>:CurrentVersion:+> v1;\n        commit();\n        return doc;\n    }\n\n    can update_doc(doc: Document, new_content: str) {\n        current_v_node = [doc-->:CurrentVersion:-->][0];\n        new_version_num = current_v_node.version_number + 1;\n        new_v_node = spawn node::Version(content=new_content, version_number=new_version_num);\n        \n        new_v_node +>:PreviousVersion:+> current_v_node;\n        del [doc-->:CurrentVersion:-->];\n        doc +>:CurrentVersion:+> new_v_node;\n        commit();\n    }\n}\n\nwith entry {\n    manager = spawn walker::DocManager();\n    my_doc = manager.create_doc(name=\"MyDoc\", content=\"Initial content.\");\n    manager.update_doc(doc=my_doc, new_content=\"Updated content.\");\n}",
    "prod_softdelete_01": "node Item {\n    has name: str;\n    has is_deleted: bool = False;\n}\n\nwalker ItemManager {\n    can add_item(name: str) {\n        item = spawn node::Item(name=name);\n        root ++> item;\n        commit();\n    }\n\n    can soft_delete(item: Item) {\n        item.is_deleted = True;\n        commit();\n    }\n\n    can get_active_items() -> list[Item] {\n        active_items = [root-->(`?Item)](?is_deleted == False);\n        report active_items;\n        return active_items;\n    }\n}\n\nwith entry {\n    manager = spawn walker::ItemManager();\n    manager.add_item(name=\"Active Item\");\n    deleted_item = spawn node::Item(name=\"Deleted Item\");\n    root ++> deleted_item;\n    commit();\n\n    manager.soft_delete(item=deleted_item);\n    manager.get_active_items();\n}",
    "prod_audit_01": "node AuditLog {\n    has timestamp: float;\n    has user_id: str;\n    has action: str;\n    has details: dict;\n}\n\nwalker AuditLogger {\n    can log(user_id: str, action: str, details: dict) {\n        import from \"time\" as time;\n        log_entry = spawn node::AuditLog(\n            timestamp=time.time(),\n            user_id=user_id,\n            action=action,\n            details=details\n        );\n        root ++> log_entry;\n        commit();\n        report \"Action logged\";\n    }\n}\n\nwith entry {\n    logger = spawn walker::AuditLogger();\n    logger.log(\n        user_id=\"user-123\",\n        action=\"LOGIN_SUCCESS\",\n        details={\"ip_address\": \"192.168.1.1\"}\n    );\n}",
    "prod_ratelimit_01": "import from \"time\" as time;\n\nglob request_logs: dict[str, list[float]] = {};\n\nwalker RateLimiter {\n    has user_id: str;\n    has limit: int = 5; # requests\n    has window: int = 60; # seconds\n\n    can check() -> bool {\n        current_time = time.time();\n        if self.user_id not in :g:request_logs {\n            :g:request_logs[self.user_id] = [];\n        }\n\n        user_requests = :g:request_logs[self.user_id];\n        \n        # Filter out old timestamps\n        valid_requests = [t for t in user_requests if current_time - t < self.window];\n        :g:request_logs[self.user_id] = valid_requests;\n\n        if len(valid_requests) >= self.limit {\n            report {\"error\": \"Rate limit exceeded\"};\n            return false;\n        }\n        \n        :g:request_logs[self.user_id].append(current_time);\n        report {\"status\": \"Request allowed\"};\n        return true;\n    }\n}\n\nwith entry {\n    limiter = spawn walker::RateLimiter(user_id=\"user-abc\");\n    for i=0 to i<7 by i+=1 {\n        limiter.check();\n    }\n}",
    "advanced_ai_stream_01": "import from byllm { Model };\n\ndef stream_story(topic: str) -> str by llm(model_name=\"gpt-4o\", stream=True);\n\nwith entry {\n    print(f\"Streaming a story about a brave knight:\");\n    for token in stream_story(topic=\"a brave knight\") {\n        print(token, end=\"\");\n    }\n    print();\n}",
    "advanced_ai_multimodal_01": "import from byllm { Model, Image };\n\ndef describe_image(image: Image) -> str by llm(model_name=\"gpt-4o\");\n\nwalker ImageAnalyzer {\n    can analyze(image_path: str) {\n        try {\n            img_obj = Image(image_path);\n            description = describe_image(image=img_obj);\n            report description;\n        } except Exception as e {\n            report f\"Error processing image: {e}\";\n        }\n    }\n}\n\nwith entry {\n    # This requires a valid image file at 'path/to/your/image.jpg'\n    # We will simulate the call without a real file for this test.\n    analyzer = spawn walker::ImageAnalyzer();\n    print(\"Walker is ready to analyze an image. Call analyzer.analyze('path/to/image.jpg')\");\n}",
    "advanced_ai_react_01": "import from byllm { Model };\n\ndef get_stock_price(symbol: str) -> float {\n    # Mock function\n    if symbol == \"JAC\" {\n        return 123.45;\n    }\n    return 0.0;\n}\n\ndef get_weather(city: str) -> str {\n    # Mock function\n    return f\"The weather in {city} is sunny.\";\n}\n\ndef react_agent(query: str) -> str by llm(\n    model_name=\"gpt-4o\",\n    method='ReAct',\n    tools=[get_stock_price, get_weather]\n);\n\nwith entry {\n    response = react_agent(query=\"What is the stock price of JAC and the weather in London?\");\n    print(response);\n}",
    "advanced_ai_structured_01": "import from byllm { Model };\n\nobj PersonInfo {\n    has name: str;\n    has age: int;\n    has city: str;\n}\n\ndef extract_person_info(text: str) -> PersonInfo by llm(model_name=\"gpt-4o\");\n\nwith entry {\n    bio = \"John Doe is a 42-year-old software engineer living in San Francisco.\";\n    info = extract_person_info(text=bio);\n    if info {\n        print(f\"Name: {info.name}, Age: {info.age}, City: {info.city}\");\n    }\n}",
    "advanced_graph_complex_filter_01": "node User {\n    has name: str;\n    has age: int;\n    has city: str;\n}\n\nedge Follows {\n    has since_year: int;\n}\n\nwith entry {\n    u1 = spawn node::User(name=\"Alice\", age=34, city=\"NY\");\n    u2 = spawn node::User(name=\"Bob\", age=28, city=\"LA\");\n    u3 = spawn node::User(name=\"Charlie\", age=45, city=\"NY\");\n    u4 = spawn node::User(name=\"Diana\", age=38, city=\"NY\");\n\n    u1 +>:Follows(since_year=2020):+> u3;\n    u1 +>:Follows(since_year=2022):+> u4;\n\n    # Find users Alice follows who are over 40 and live in NY\n    results = [u1 ->:Follows:since_year>2019:-> (`?User)](?age > 40 and ?city == \"NY\");\n    for r in results {\n        print(r.name);\n    }\n}",
    "advanced_graph_pathfind_01": "node Location {\n    has name: str;\n}\n\nedge Route {\n    has distance: int;\n}\n\nwalker PathFinder {\n    has distances: dict[str, int|float];\n    has previous: dict[str, Location|None];\n    has unvisited: set[Location];\n\n    can find_shortest_path(start: Location, end: Location) {\n        self.distances = {};\n        self.previous = {};\n        all_nodes = [start-->(`?Location)] + [start<-->(`?Location)] + [start];\n        self.unvisited = set(all_nodes);\n\n        for node in self.unvisited {\n            self.distances[node.jid] = float('inf');\n        }\n        self.distances[start.jid] = 0;\n\n        while self.unvisited {\n            current = min(self.unvisited, key=lambda n: self.distances[n.jid]);\n            self.unvisited.remove(current);\n\n            if current == end {break;}\n\n            for edge in [current--->] {\n                neighbor = edge.target;\n                alt_dist = self.distances[current.jid] + edge.distance;\n                if alt_dist < self.distances[neighbor.jid] {\n                    self.distances[neighbor.jid] = alt_dist;\n                    self.previous[neighbor.jid] = current;\n                }\n            }\n        }\n        report self.distances;\n    }\n}\n\nwith entry {\n    a=spawn node::Location(name=\"A\"); b=spawn node::Location(name=\"B\"); c=spawn node::Location(name=\"C\");\n    a +>:Route(distance=10):+> b; b +>:Route(distance=5):+> c; a +>:Route(distance=20):+> c;\n    w = spawn walker::PathFinder();\n    w.find_shortest_path(start=a, end=c);\n}",
    "advanced_graph_cycle_01": "node Step {}\n\nwalker CycleDetector {\n    has visited: set[str] = {};\n    has recursion_stack: set[str] = {};\n    has cycle_found: bool = false;\n\n    def detect(self, current_node: Step) {\n        self.visited.add(current_node.jid);\n        self.recursion_stack.add(current_node.jid);\n\n        for neighbor in [current_node-->] {\n            if neighbor.jid not in self.visited {\n                self.detect(neighbor);\n            } elif neighbor.jid in self.recursion_stack {\n                self.cycle_found = True;\n                report f\"Cycle detected involving node {neighbor.jid}\";\n            }\n        }\n        self.recursion_stack.remove(current_node.jid);\n    }\n\n    can run(start_node: Step) {\n        self.detect(start_node);\n        if not self.cycle_found {\n            report \"No cycles found\";\n        }\n    }\n}\n\nwith entry {\n    n1=spawn node::Step; n2=spawn node::Step; n3=spawn node::Step;\n    n1 ++> n2; n2 ++> n3; n3 ++> n1; # Create a cycle\n    w = spawn walker::CycleDetector();\n    w.run(start_node=n1);\n}",
    "advanced_persist_transaction_01": "obj DataRecord {\n    has key: str;\n    has value: str;\n}\n\nwith entry {\n    # Create multiple objects\n    rec1 = spawn obj::DataRecord(key=\"k1\", value=\"v1\");\n    rec2 = spawn obj::DataRecord(key=\"k2\", value=\"v2\");\n    rec3 = spawn obj::DataRecord(key=\"k3\", value=\"v3\");\n\n    # Queue them for saving\n    save(rec1);\n    save(rec2);\n    save(rec3);\n\n    # Flush all queued objects to the database in a single operation\n    commit();\n    print(\"3 records committed.\");\n}",
    "advanced_persist_reference_01": "node User {\n    has name: str;\n}\n\nglob user_id_store: str|None = null;\n\nwith entry {\n    # Phase 1: Create and store ID\n    if :g:user_id_store is null {\n        new_user = spawn node::User(name=\"Alice\");\n        root ++> new_user;\n        :g:user_id_store = new_user.jid;\n        commit();\n        print(f\"User created with ID: {:g:user_id_store}\");\n    }\n\n    # Phase 2: Retrieve using ID reference\n    if :g:user_id_store is not null {\n        retrieved_user = &:g:user_id_store;\n        if retrieved_user {\n            print(f\"Retrieved user: {retrieved_user.name}\");\n        } else {\n            print(\"Failed to retrieve user.\");\n        }\n    }\n}",
    "advanced_cloud_webhook_01": "walker WebhookReceiver {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/webhook/github\";\n        # Hypothetical spec for requiring a specific header\n        static has auth: dict = {\"type\": \"header\", \"name\": \"X-Hub-Signature-256\"};\n    }\n\n    # The 'request' object would be provided by the Jac Cloud runtime\n    can process_webhook(payload: dict, request: any) {\n        # In a real scenario, you would validate the signature from the header\n        # signature = request.headers.get(\"X-Hub-Signature-256\")\n        # if not is_valid(signature, payload):\n        #     return {\"status\": 403, \"error\": \"Invalid signature\"}\n        \n        report {\"status\": \"received\", \"payload\": payload};\n    }\n}\n\nwith entry {\n    # This walker is designed for a Jac Cloud server environment.\n    print(\"WebhookReceiver is configured and ready.\");\n}",
    "advanced_cloud_async_retrieve_01": "async walker LongTask {\n    can run() {\n        import from \"asyncio\" as asyncio;\n        report \"Task started\";\n        await asyncio.sleep(2);\n        report \"Task finished\";\n    }\n}\n\nwith entry {\n    # Spawn the async walker, which returns immediately\n    result = spawn LongTask();\n    task_id = result;\n    print(f\"Task spawned with ID: {task_id}\");\n\n    # Get a reference to the task object\n    task = &task_id;\n\n    # Check its status (e.g., PENDING, RUNNING, DONE)\n    status = task.__jac__.status;\n    print(f\"Initial task status: {status}\");\n\n    # In a real app, you would poll this status until it's DONE\n    # and then retrieve reports or errors.\n    # reports = task.__jac__.reports;\n}",
    "advanced_cloud_query_params_01": "node Item {\n    has name: str;\n    has category: str;\n}\n\nwalker ItemSearch {\n    obj __specs__ {\n        static has methods: list = [\"post\"];\n        static has path: str = \"/search/items\";\n        # 'limit' and 'offset' will be URL query params, 'query' will be in the body\n        static has as_query: list = [\"limit\", \"offset\"];\n    }\n\n    can find(query: str, category: str, limit: int = 10, offset: int = 0) {\n        # This walker would be called via an API endpoint like:\n        # POST /search/items?limit=5&offset=10\n        # with body: {\"query\": \"some item\", \"category\": \"books\"}\n        report f\"Searching for '{query}' in '{category}' with limit {limit}, offset {offset}\";\n    }\n}\n\nwith entry {\n    # This walker is designed for a Jac Cloud server environment.\n    print(\"ItemSearch walker is configured with query parameters.\");\n}",
    "integration_error_handling_01": "enum MathError { INVALID_OPERATION }\n\nwalker SafeCalculator {\n    can divide(a: float, b: float) -> float|None {\n        try {\n            if b == 0.0 {\n                # In a real app, you might raise a custom error\n                # Here we report and return a fallback\n                report {\"error\": MathError.INVALID_OPERATION, \"message\": \"Cannot divide by zero\"};\n                return null;\n            }\n            return a / b;\n        } except Exception as e {\n            report {\"error\": \"UNEXPECTED_ERROR\", \"details\": str(e)};\n            return null;\n        }\n    }\n}\n\nwith entry {\n    calc = spawn walker::SafeCalculator();\n    result1 = calc.divide(10.0, 2.0);\n    print(f\"Result 1: {result1}\");\n    result2 = calc.divide(5.0, 0.0);\n    print(f\"Result 2: {result2}\");\n}",
    "integration_external_api_01": "import from \"requests\" as requests;\n\nwalker ApiFetcher {\n    can get_data(url: str) -> dict {\n        try {\n            response = requests.get(url);\n            response.raise_for_status(); # Raises an exception for bad status codes\n            data = response.json();\n            report data;\n            return data;\n        } except requests.exceptions.RequestException as e {\n            error_msg = f\"API request failed: {e}\";\n            report {\"error\": error_msg};\n            return {\"error\": error_msg};\n        }\n    }\n}\n\nwith entry {\n    fetcher = spawn walker::ApiFetcher();\n    # This is a public test API\n    fetcher.get_data(\"https://jsonplaceholder.typicode.com/todos/1\");\n    fetcher.get_data(\"https://example.com/nonexistent\");\n}",
    "integration_conditional_visit_01": "node Step {\n    has name: str;\n}\n\nwalker Workflow {\n    can run(start_node: Step) {\n        visit start_node;\n        report f\"At {here.name}\";\n        \n        visit [-->] else {\n            report \"End of workflow reached. Disengaging.\";\n            disengage;\n        }\n        report f\"Moved to {here.name}\";\n    }\n}\n\nwith entry {\n    step1 = spawn node::Step(name=\"Step 1\");\n    step2 = spawn node::Step(name=\"Step 2\");\n    step1 ++> step2;\n\n    w = spawn walker::Workflow();\n    w.run(start_node=step1);\n}",
    "integration_multi_ability_01": "walker Processor {\n    has state: list[str] = [];\n    can process(start_node: node) {\n        visit start_node;\n    }\n}\n\nnode Stage {\n    has name: str;\n\n    can on_enter with Processor entry {\n        report f\"Entering stage: {self.name}\";\n        visitor.state.append(f\"ENTER_{self.name}\");\n    }\n\n    can on_exit with Processor exit {\n        report f\"Exiting stage: {self.name}\";\n        visitor.state.append(f\"EXIT_{self.name}\");\n    }\n}\n\nwith entry {\n    s1 = spawn node::Stage(name=\"A\");\n    s2 = spawn node::Stage(name=\"B\");\n    s1 ++> s2;\n\n    p = spawn walker::Processor();\n    p.process(start_node=s1);\n    print(p.state);\n}",
    "integration_batch_process_01": "node Record {\n    has data: str;\n}\n\nwalker BatchProcessor {\n    can process_list(items: list[str]) {\n        for item_data in items {\n            new_record = spawn node::Record(data=item_data);\n            root ++> new_record;\n            save(new_record); # Queue for saving\n            report f\"Queued record: {item_data}\";\n        }\n        commit(); # Commit all queued records at once\n        report \"Batch commit complete.\";\n    }\n}\n\nwith entry {\n    data_to_process = [\"item1\", \"item2\", \"item3\"];\n    processor = spawn walker::BatchProcessor();\n    processor.process_list(items=data_to_process);\n}",
    "integration_visitor_communication_01": "walker CounterWalker {\n    has count: int = 0;\n    can traverse(start_node: node) {\n        visit start_node;\n        visit [-->];\n    }\n}\n\nnode CounterNode {\n    has increment_by: int = 1;\n\n    can increment_visitor with CounterWalker entry {\n        report f\"Node incrementing visitor.count by {self.increment_by}\";\n        visitor.count += self.increment_by;\n    }\n}\n\nwith entry {\n    n1 = spawn node::CounterNode(increment_by=5);\n    n2 = spawn node::CounterNode(increment_by=10);\n    n1 ++> n2;\n\n    w = spawn walker::CounterWalker();\n    w.traverse(start_node=n1);\n    print(f\"Final walker count: {w.count}\");\n}",
    "integration_root_ability_01": "walker Initializer {\n    has is_initialized: bool = false;\n\n    can setup with `root entry {\n        report \"Initializer running on root node.\";\n        self.is_initialized = True;\n    }\n\n    can run() {\n        spawn root walker::Initializer;\n    }\n}\n\nwith entry {\n    init_walker = spawn walker::Initializer();\n    init_walker.run();\n    print(f\"Walker initialized: {init_walker.is_initialized}\");\n}",
    "integration_edge_traversal_01": "node City {\n    has name: str;\n}\n\nedge Flight {\n    has flight_number: str;\n}\n\nwalker FlightExplorer {\n    can list_flights(from_city: City) {\n        visit from_city;\n        report f\"Flights from {here.name}:\";\n        for flight_edge in [here --->] {\n            if flight_edge is edge::Flight {\n                report f\" - Flight {flight_edge.flight_number} to {flight_edge.target.name}\";\n            }\n        }\n    }\n}\n\nwith entry {\n    sfo = spawn node::City(name=\"SFO\");\n    lax = spawn node::City(name=\"LAX\");\n    jfk = spawn node::City(name=\"JFK\");\n\n    sfo +>:Flight(flight_number=\"UA123\"):+> lax;\n    sfo +>:Flight(flight_number=\"DL456\"):+> jfk;\n\n    explorer = spawn walker::FlightExplorer();\n    explorer.list_flights(from_city=sfo);\n}"
  }
}